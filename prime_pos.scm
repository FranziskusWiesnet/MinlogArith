;; 2025-04-02.  prime_pos.scm.  Based on Franziskus Wiesnet's
;; div_pos.scm and gcd_pos.scm

;; (load "~/git/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (exload "arith/gcd_nat.scm")
;; (exload "arith/prime_nat.scm")
;; (libload "pos.scm")
;; (exload "arith/gcd_pos.scm")
;; (set! COMMENT-FLAG #t)

;; PosComposed, PosPrime
;; =====================

(add-program-constant "PosComposed" (py "pos=>boole"))
(add-computation-rules
 "PosComposed p" "ExBPos(PosSqrt p)([q]1<q andb PosDiv q p)")

(set-totality-goal "PosComposed")
(fold-alltotal)
(assume "p")
(use "TotalVar")
;; (cp)
(save-totality)

(add-program-constant "PosPrime" (py "pos=>boole"))
(add-computation-rules
 "PosPrime p" "negb(PosComposed p) andb 1<p")

(set-totality-goal "PosPrime")
(fold-alltotal)
(assume "p")
(use "TotalVar")
;; (cp)
(save-totality)

;; PosPrimeProd
(set-goal "all p,q0,q1(PosPrime p -> q0*q1=p -> q0=1 orb q1=1)")
(assume "p" "q0")
(cases (pt "q0=1"))
(search)
(assume 1)
(assume "q1")
(cases (pt "q1=1"))
(search)
(assume 2)
(simp "PosPrime0CompRule")
(simp "PosComposed0CompRule")
(assume 3 4)
(assert "ExBPos(PosSqrt p)([q]1<q andb PosDiv q p)")
(cases (pt "q0<=PosSqrt p"))
(assume 5)
(use "ExBPosIntro" (pt "q0"))
(use 5)
(bpe-ng)
(split)
(use "PosNotLeToLt")
(use 1)
(use "PosProdToDiv" (pt "q1"))
(simp "PosTimesComm")
(use 4)
(assume 5)
(assert "q1<=PosSqrt p")
(use "PosNotLtToLe")
(assume 6)
(inst-with "PosNotLeToLt" (pt "q0") (pt "PosSqrt p") 5)
(inst-with "PosSquareSqrtLowBound" (pt "p") (pt "q1") 6)
(inst-with "PosSquareSqrtLowBound" (pt "p") (pt "q0") 7)
(assert "p*p<p*p")
(use "PosLtLeTrans" (pt "PosSquare q1*PosSquare q0"))
(use "PosLtMonTimes")
(use 8)
(use 9)
(simp "PosSquare0CompRule")
(simp "PosSquare0CompRule")
(ng #t)
(simp "PosTimesComm")
(use "PosLeTrans" (pt "q0*(q1*q0*q1)"))
(use "PosLeMonTimes")
(use "Truth")
(simp "PosTimesComm")
(ng #t)
(simp "PosTimesComm")
(use "Truth")
(use "PosLeTrans" (pt "(q0*q1)*(q0*q1)"))
(use "Truth")
(simp 4)
(use "Truth")
(search)
(assume 6)
(use "ExBPosIntro" (pt "q1"))
(use 6)
(bpe-ng)
(split)
(use "PosNotLeToLt")
(use 2)
(use "PosProdToDiv" (pt "q0"))
(use 4)
(assume 5)
(simphyp 3 5)
(use 6)
;; (cp)
(save "PosPrimeProd")

;; PosProdToPrime
(set-goal "all p(1<p -> all q0,q1(q0*q1=p -> q0=1 orb q1=1) -> PosPrime p)")
(assume "p" 1 2)
(simp "PosPrime0CompRule")
(simp "PosComposed0CompRule")
(split)
(assert "ExBPos(PosSqrt p)([q]1<q andb PosDiv q p) -> F")
(assume 3)
(use "ExBPosElim" (pt "PosSqrt p") (pt "[q]1<q andb PosDiv q p"))
(use 3)
(assume "q1" 4 5)
(bpe-ng)
(inst-with "PosDivToProd" (pt "q1") (pt "p") "?")
(by-assume 6 "q0" 7)
(inst-with 2 (pt "q0") (pt "q1") 7)
(cases (pt "q0=1"))
(assume 9)
(simphyp 7 9)
(ng 10)
(inst-with "PosEqSqrtToOne" (pt "p") "?")
(simphyp 10 11)
(simphyp 5 12)
(use 13)
(simphyp 4 10)
(use 11)
(assume 9)
(simphyp 8 9)
(ng 10)
(simphyp 5 10)
(use 11)
(use 5)
(assume 3)
(simp 3)
(use "Truth")
(use 1)
;; (cp)
(save "PosProdToPrime")

;; PosPrimeToNatPrime
(set-goal "all p(PosPrime p -> NatPrime(PosToNat p))")
(strip)
(use "NatProdToPrime")
(simphyp 1 "PosPrime0CompRule")
(simp "<-" "NatToPosLt")
(simp "NatToPosToNatId")
(use 2)
(use "NatLtZeroPos")
(use "Truth")
(assume "l0" "l1" 2)
(inst-with
 "PosPrimeProd" (pt "p") (pt "NatToPos l0") (pt "NatToPos l1") 1 "?")
(cases (pt "NatToPos l0 = 1"))
(assume 4)
(simp "<-" "PosToNatToPosId")
(simp 4)
(use "Truth")
(use "NatNotLeToLt")
(assume 5)
(simphyp 2 5)
(ng 6)
(inst-with "NatLtZeroPos" (pt "p"))
(simphyp 7 6)
(use 8)
(assume 4)
(simphyp 3 4)
(simphyp 5 "OrConst2CompRule")
(assert "l1=Succ Zero")
(simp "<-" "PosToNatToPosId")
(simp 6)
(use "Truth")
(use "NatNotLeToLt")
(assume 7)
(simphyp 2 7)
(ng 8)
(inst-with "NatLtZeroPos" (pt "p"))
(simphyp 9 8)
(use 10)
(assume 7)
(simp 7)
(use "Truth")
(simp "<-" "NatToPosTimes")
(simp 2)
(use "NatToPosToNatId")
(use "NatNotLeToLt")
(assume 3)
(simphyp 2 3)
(inst-with "NatLtZeroPos" (pt "p"))
(ng 4)
(simphyp 5 4)
(use 6)
(use "NatNotLeToLt")
(assume 3)
(simphyp 2 3)
(inst-with "NatLtZeroPos" (pt "p"))
(ng 4)
(simphyp 5 4)
(use 6)
;; (cp)
(save "PosPrimeToNatPrime")

;; NatPrimeToPosPrime
(set-goal "all n(NatPrime n -> PosPrime(NatToPos n))")
(strip)
(simphyp 1 "NatPrime0CompRule")
(use "PosProdToPrime")
(simp "<-" "PosToNatLt")
(simp "PosToNatToPosId")
(use 2)
(use "NatLtTrans" (pt "Succ Zero"))
(use "Truth")
(use 2)
(assume "q0" "q1" 3)
(inst-with
 "NatPrimeProd" (pt "n") (pt "PosToNat q0") (pt "PosToNat q1") 1 "?")
(cases (pt "PosToNat q0=Succ Zero"))
(assume 5)
(simp "<-" "NatToPosToNatId")
(simp 5)
(use "Truth")
(assume 5)
(simphyp 4 5)
(simphyp 6 "OrConst2CompRule")
(assert "q1=1")
(simp "<-" "NatToPosToNatId")
(simp 7)
(use "Truth")
(assume 8)
(simp 8)
(use "Truth")
(simp "<-" "PosToNatTimes")
(simp 3)
(use "PosToNatToPosId")
(use "NatLtTrans" (pt "Succ Zero"))
(use "Truth")
(use 2)
;; (cp)
(save "NatPrimeToPosPrime")

(add-program-constant "PosLeastFactorAux" (py "pos=>pos"))
(add-computation-rules
 "PosLeastFactorAux 1" "2"
 "PosLeastFactorAux(SZero p)"
 "NatToPos(NatLeast(PosSqrt(SZero p)+1)([n]1<n andb
  ExBPos(SZero p)([q1]q1*n=SZero p)))"
 "PosLeastFactorAux(SOne p)"
 "NatToPos(NatLeast(PosSqrt(SOne p)+1)([n]1<n andb
  ExBPos(SOne p)([q1]q1*n=SOne p)))")

(set-totality-goal "PosLeastFactorAux")
(fold-alltotal)
(cases)
(use "TotalVar")
(assume "p")
(ng #t)
(use "TotalVar")
(assume "p")
(ng #t)
(use "TotalVar")
;; (cp)
(save-totality)

;; PosLeastFactorAuxLemma
(set-goal "all p  PosLeastFactorAux p=
 NatToPos(NatLeast(PosSqrt p+1)([n]1<n andb ExBPos p([q1]q1*n=p)))")
(cases)
(use "Truth")
(assume "p")
(use "Truth")
(assume "p")
(use "Truth")
;; (cp)
(save "PosLeastFactorAuxLemma")

;; PosLeastFactorAuxToPosPrime
(set-goal "all p(1<p -> PosLeastFactorAux p=PosSqrt p+1 -> PosPrime p)")
(assume "p" 1)
(simp "PosLeastFactorAuxLemma")
(assume 2)
(use "PosProdToPrime")
(use 1)
(assume "q0" "q1" 3)
(cases (pt "q0=1"))
(search)
(assume 4)
(cases (pt "q1=1"))
(search)
(assume 5)
(cases (pt "q0<=PosSqrt p"))
(assume 7)
(inst-with "NatLeastLeIntro" (pt "PosToNat(PosSqrt p+1)")
	   (pt "PosToNat q0")
	   (pt "[n]1<n andb ExBPos p([q]q*n=PosToNat p)")
	   "?")
(assert "NatLeast(PosToNat(PosSqrt p+1))
    ([n]1<n andb ExBPos p([q]q*n=PosToNat p))
   <=PosSqrt p")
(use "NatLeTrans" (pt "PosToNat q0"))
(use 7)
(simp "<-" "NatToPosLe")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(use 6)
(use "NatLtZeroPos")
(use "NatLtZeroPos")
(simp "<-" "NatToPosLe")
(simp 2)
(simp "NatToPosToNatId")
(search)
(use "NatLtZeroPos")
(use "NatNotLeToLt")
(assume 8)
(simphyp 2 (pf "NatLeast(PosToNat(PosSqrt p+1))
    ([n]1<n andb ExBPos p([q]q*n=PosToNat p)) = Zero"))
(assert "1<PosSqrt p+1")
(use "Truth")
(simp "<-" 9)
(search)
(use 8)
(bpe-ng)
(split)
(simp "PosToNatLt")
(use "PosNotLeToLt")
(use 4)
(use "ExBPosIntro" (pt "q1"))
(simp "<-" 3)
(simp "PosTimesComm")
(use "PosLeTimesPos")
(use "Truth")
(bpe-ng)
(simp "<-" "PosToNatTimes")
(simp "PosTimesComm")
(simp 3)
(use "Truth")
(assume 6)
(inst-with "NatLeastLeIntro" (pt "PosToNat(PosSqrt p+1)")
	   (pt "PosToNat q1")
	   (pt "[n]1<n andb ExBPos p([q]q*n=PosToNat p)")
	   "?")
(assert "NatLeast(PosToNat(PosSqrt p+1))
    ([n]1<n andb ExBPos p([q]q*n=PosToNat p))
   <=PosSqrt p")
(use "NatLeTrans" (pt "PosToNat q1"))
(use 7)
(simp "<-" "NatToPosLe")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(use "PosNotLtToLe")
(assume 8)
(inst-with "PosSqrtTimesLowBound" (pt "p") (pt "q0") (pt "q1") "?" 8)
(simphyp 9 3)
(use 10)
(use "PosNotLeToLt")
(use 6)
(use "NatLtZeroPos")
(use "NatLtZeroPos")
(simp "<-" "NatToPosLe")
(simp 2)
(simp "NatToPosToNatId")
(search)
(use "NatLtZeroPos")
(use "NatNotLeToLt")
(assume 8)
(simphyp 2 (pf "NatLeast(PosToNat(PosSqrt p+1))
    ([n]1<n andb ExBPos p([q]q*n=PosToNat p)) = Zero"))
(assert "1<PosSqrt p+1")
(use "Truth")
(simp "<-" 9)
(search)
(use 8)
(bpe-ng)
(split)
(simp "PosToNatLt")
(use "PosNotLeToLt")
(use 5)
(use "ExBPosIntro" (pt "q0"))
(simp "<-" 3)
(use "PosLeTimesPos")
(use "Truth")
(bpe-ng)
(simp "<-" "PosToNatTimes")
(simp 3)
(use "Truth")
;; (cp)
(save "PosLeastFactorAuxToPosPrime")

(add-program-constant "PosLeastFactor" (py "pos=>pos"))
(add-computation-rules
 "PosLeastFactor p"
 "[if (PosLeastFactorAux p=PosSqrt p+1) p (PosLeastFactorAux p)]")

(set-totality-goal "PosLeastFactor")
(fold-alltotal)
(assume "p")
(simp "PosLeastFactor0CompRule")
(use "TotalVar")
;; (cp)
(save-totality)

;; PosToNatLeastFactor
(set-goal "all p PosToNat(PosLeastFactor p)=NatLeastFactor(PosToNat p)")
(assume "p")
(cases (pt "p=1"))
(assume 1)
(simp 1)
(use "Truth")
(assume  1)
(assert "1<p")
(use "PosNotLeToLt")
(use 1)
(assume 2)
(drop 1)
(simp "PosLeastFactor0CompRule")
(simp "NatLeastFactor0CompRule")
(cases (pt "PosLeastFactorAux p=PosSqrt p+1"))
;; if p is prime
(assume 1)
(simp "IfTrue")
(inst-with "PosLeastFactorAuxToPosPrime" (pt "p") 2 3)
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(assume 5)
(inst-with
 "NatLeastLtElim"
 (pt "PosToNat p")
 (pt "[m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p)")
 5)
(bpe-ng)
(use "ExBNatElim"
     (pt "[l]
      l*
      NatLeast(PosToNat p)
      ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l0]l0*m=PosToNat p))=
      PosToNat p")
     (pt "Succ(PosToNat p)"))
(use 6)
(assume "m" 1 2)
(bpe-ng)
(inst-with
 "NatPrimeProd"
 (pt "PosToNat p")
 (pt "m")
 (pt "NatLeast(PosToNat p)
      ([m0]Succ Zero<m0 andb ExBNat(Succ(PosToNat p))([l]l*m0=PosToNat p))")
 "?"
 8)
(cases (pt "m=Succ Zero"))
(assume 10)
(simphyp 8 10)
(assert "PosToNat p <PosToNat p")
(use "NatLeLtTrans" (pt "NatLeast(PosToNat p)
     ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))"))
(simp (pf "NatLeast(PosToNat p)
     ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))=
     Succ Zero*
     NatLeast(PosToNat p)
     ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))"))
(simp 11)
(use "Truth")
(use "Truth")
(use 5)
(search)
(assume 10)
(simphyp 9 10)
(simphyp 11 "OrConst2CompRule")
(inst-with
 "NatLeastLtElim"
 (pt "PosToNat p")
 (pt "[m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p)")
 5)
(bpe-ng)
(simphyp 13 12)
(use 14)
(use "PosPrimeToNatPrime")
(use 4)
(use "NatLeastBound")
;; p is not prime
(simp "PosLeastFactorAuxLemma")
(simp "IfFalse")
(assume 2)
;; Assertion 1
(assert "Succ Zero<
    NatLeast(PosToNat(PosSqrt p+1))
     ([n]1<n andb ExBPos p([q]q*n=PosToNat p))")
(use "NatNotLeToLt")
(assume 4)
(inst-with
 "NatLeastLtElim"
 (pt "PosToNat(PosSqrt p+1)")
 (pt "[n]1<n andb ExBPos p([q]q*n=PosToNat p)")
 "?")
 (bpe-ng)
 (assert "Succ Zero<Succ Zero")
(use "NatLtLeTrans"
     (pt "NatLeast(PosToNat(PosSqrt p+1))([n]1<n andb
          ExBPos p([q]q*n=PosToNat p))"))
 (use 5)
 (use 4)
 (search)
 (use "NatLeLtTrans" (pt "Succ Zero"))
 (use 4)
 (simp "PosToNatPlus")
 (simp "PosToNat0CompRule")
 (use "NatLeLtTrans" (pt "Zero+Succ Zero"))
 (use "Truth")
 (use "NatLtMonPlus1")
 (use "NatLtZeroPos")
 (use "Truth")
(assume 4)
;; Assertion 2
(assert "Succ Zero<
    NatLeast(PosToNat p)
    ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))")
 (use "NatNotLeToLt")
 (assume 4)
(inst-with
 "NatLeastLtElim"
 (pt "PosToNat p")
 (pt "[m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p)")
 "?")
 (bpe-ng)
 (assert "Succ Zero<Succ Zero")
 (use "NatLtLeTrans" (pt "NatLeast(PosToNat p)
    ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))"))
 (use 6)
 (use 5)
 (search)
 (use "NatLeLtTrans" (pt "PosToNat 1"))
 (use 5)
 (simp "PosToNatLt")
 (use 2)
(assume 5)
;; Assertion 3
(assert "NatToPos
    (NatLeast(PosToNat(PosSqrt p+1))
     ([n]1<n andb ExBPos p([q]q*n=PosToNat p)))< PosSqrt p+1")
 (use "PosLeNotEqToLt")
 (use "PosLeTrans" (pt "NatToPos(PosToNat(PosSqrt p+1))"))
 (simp "NatToPosLe")
 (use "NatLeastBound")
 (use "NatLtZeroPos")
 (use "NatLtTrans" (pt "Succ Zero"))
 (use "Truth")
 (use 4)
 (simp "NatToPosToNatId")
 (use "Truth")
 (use 3)
 (assume 5)
;; Assertion 4
(assert "ExBPos p
    ([q]
      q*
      NatLeast(PosToNat(PosSqrt p+1))
      ([n]1<n andb ExBPos p([q0]q0*n=PosToNat p))=
      PosToNat p)")
 (inst-with "NatLeastLtElim"
	   (pt "PosToNat(PosSqrt p+1)")
	   (pt "[n]1<n andb ExBPos p([q]q*n=PosToNat p)")
	   "?")
 (bpe-ng)
 (use 7)
 (simp "<-" "NatToPosLt")
 (simp "NatToPosToNatId")
 (use 6)
 (use "NatLtZeroPos")
 (use "NatLtTrans" (pt "Succ Zero"))
 (use "Truth")
 (use 4)
(assume 7)
;; ExB Elimition
(use "ExBPosElim" (pt "p")
                  (pt "[q]
      q*
      NatLeast(PosToNat(PosSqrt p+1))
      ([n]1<n andb ExBPos p([q0]q0*n=PosToNat p))=
      PosToNat p"))
 (use 7)
 (assume "q" 8 9)
(drop 7)
(bpe-ng)
;; Assertion 5
(assert " ExBNat(Succ(PosToNat p))
     ([l]
       l*
       NatLeast(PosToNat p)
       ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l0]l0*m=PosToNat p))=
       PosToNat p)")
(inst-with
 "PropNatLeast"
 (pt "PosToNat p")
 (pt "PosToNat p")
 (pt "[m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p)")
 "Truth"
 "?")
 (bpe-ng)
 (use 10)
 (bpe-ng)
 (split)
 (simp "<-" "NatToPosLt")
 (simp "NatToPosToNatId")
 (use 2)
 (use "NatLtZeroPos")
 (use "Truth")
 (use "ExBNatIntro" (pt "Succ Zero"))
 (use "NatLtZeroPos")
 (use "Truth")
(assume 10)
;;ExB Elimition 
(use "ExBNatElim"
     (pt "[l]
       l*
       NatLeast(PosToNat p)
       ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l0]l0*m=PosToNat p))=
       PosToNat p")
     (pt "Succ(PosToNat p)"))
 (use 10)
 (assume "l" 11 12)
(drop 10)
(bpe-ng)
;; Assertion 6
(assert "NatLeast(PosToNat p)
    ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l]l*m=PosToNat p))<
    PosToNat p")
 (use "NatLeLtTrans" (pt "NatLeast(PosToNat(PosSqrt p+1))
    ([n]1<n andb ExBPos p([q0]q0*n=PosToNat p))"))
 (use "NatLeastLeIntro")
 (bpe-ng)
 (split)
 (use 4)
 (use "ExBNatIntro" (pt "PosToNat q"))
 (use "NatLeToLtSucc")
 (simp "PosToNatLe")
 (use 8)
 (use 9)
 (use "NatLtLeTrans" (pt "PosToNat(PosSqrt p+1)"))
 (simp "<-" "NatToPosLt")
 (simp "NatToPosToNatId")
 (use 6)
 (use "NatLtZeroPos")
 (use "NatLtTrans" (pt "Succ Zero"))
 (use "Truth")
 (use 4)
 (simp (pf "PosToNat(PosSqrt p+1)=Succ(PosToNat(PosSqrt p))"))
 (use "NatLtToSuccLe")
 (simp "PosToNatLt")
 (use "PosLtSqrt")
 (use 2)
 (simp "PosToNatPlus")
 (use "Truth")
 (assume 13)
;; Assertion 7
(assert "1<l")
(use "NatNotLeToLt")
(assume 14)
(assert "PosToNat p<PosToNat p")
(use "NatLeLtTrans" (pt "l*
     NatLeast(PosToNat p)
     ([m]Succ Zero<m andb ExBNat(Succ(PosToNat p))([l0]l0*m=PosToNat p))"))
(simp 12)
(use "Truth")
(use "NatLtLeTrans" (pt "l *p"))
(use "NatLtMonTimesLeft")
(use "NatNotLeToLt")
(assume 15)
(simphyp 12 15)
(ng 16)
(inst-with "NatLtZeroPos" (pt "p"))
(simphyp 17 16)
(use 18)
(use 13)
(use "NatLeTrans" (pt "Succ Zero *p"))
(use "NatLeMonTimes")
(use 14)
(use "Truth")
(use "Truth")
(search)
(assume 14)
;; Proper Proof
(simp "PosToNatToPosId")
(use "NatLeAntiSym")   ;(1)
 ;; Frist Part of (1)
 (use "NatLeastLeIntro")
 (bpe-ng)
 (split)
 (use 5)
 (use "ExBPosIntro" (pt "NatToPos l"))
 (simp "<-" "PosToNatLe")
 (use "NatLtSuccToLe")
 (simp "PosToNatToPosId")
 (use 11)
 (use "NatLtTrans" (pt "Succ Zero"))
 (use "Truth")
 (use 14)
 (bpe-ng)
 (simp "PosToNatToPosId")
 (use 12)
 (use "NatLtTrans" (pt "Succ Zero"))
 (use "Truth")
 (use 14)
 ;; Secound Part of (1) 
 (use "NatLeastLeIntro")
 (bpe-ng)
 (split)
 (use 4) 
 (use "ExBNatIntro" (pt "PosToNat q"))
 (use "NatLeToLtSucc")
 (simp "PosToNatLe")
 (use 8)
 (bpe-ng)
 (use 9)
(use "NatLtTrans" (pt "Succ Zero"))
(use "Truth")
(use 4)
;; (cp)
(save "PosToNatLeastFactor")

;; NatToPosLeastFactor
(set-goal "all n(
 Zero<n -> NatToPos(NatLeastFactor n)=PosLeastFactor(NatToPos n))")
(assume "n" 1)
(inst-with "PosToNatLeastFactor" (pt "NatToPos n"))
(simphyp 2 "PosToNatToPosId")
(simp "<-" 3)
(use "NatToPosToNatId")
(use 1)
;; (cp)
(save "NatToPosLeastFactor")

;; PosLeastFactorPrime
(set-goal "all p(1<p -> PosPrime(PosLeastFactor p))")
(assume "p" 1)
(simp "<-" (pf "NatToPos(PosToNat p)=p"))
(simp "<-" "NatToPosLeastFactor")
(use "NatPrimeToPosPrime")
(use "NatLeastFactorPrime")
(use "NatLeLtTrans" (pt "PosToNat(NatToPos (Succ Zero))"))
(simp "PosToNatToPosId")
(use "Truth")
(use "Truth")
(simp "PosToNatLt")
(use 1)
(use "NatLtZeroPos")
(use "NatToPosToNatId")
;; (cp)
(save "PosLeastFactorPrime")

;; PosOneLtLeastFactor
(set-goal "all p(1<p -> 1<PosLeastFactor p)")
(assume "p" 1)
(inst-with "PosLeastFactorPrime" (pt "p") 1)
(simphyp 2 "PosPrime0CompRule")
(use 3)
;; (cp)
(save "PosOneLtLeastFactor")

;; PosLeastFactorDiv
(set-goal "all p(PosDiv(PosLeastFactor p) p)")
(assume "p")
(cases (pt "p=1"))
(assume 1)
(simp 1)
(use "Truth")
(assume 1)
(inst-with "NatLeastFactorProp1" (pt "PosToNat p") "?")
(use "ExBNatElim"
 (pt "[l]l*NatLeastFactor(PosToNat p)=PosToNat p")(pt "Succ(PosToNat p)"))
(use 2)
(assume "m" 2 3)
(bpe-ng)
(use "PosProdToDiv" (pt "NatToPos m"))
(simp (pf "PosLeastFactor p=(NatToPos(PosToNat(PosLeastFactor p)))"))
(simp "PosToNatLeastFactor")
(simp "<-" "NatToPosTimes")
(simp 4)
(use "NatToPosToNatId")
(use "NatNotLeToLt")
(assume 5)
(simphyp 4 (pf "NatLeastFactor(PosToNat p)=Zero"))
(inst-with "NatLtZeroPos" (pt "p"))
(simphyp 7 6)
(use 8)
(use 5)
(use "NatNotLeToLt")
(assume 5)
(simphyp 4 (pf "m=Zero"))
(inst-with "NatLtZeroPos" (pt "p"))
(simphyp 7 6)
(use 8)
(use 5)
(use "PosEqSym")
(use "NatToPosToNatId")
(use "NatNotLeToLt")
(assume 2)
(use 1)
(use "PosLeAntiSym")
(simp "<-" "PosToNatLe")
(use 2)
(use "Truth")
;; (cp)
(save "PosLeastFactorDiv")

;; PosDivPrime
(set-goal "all p,q(PosPrime p -> PosDiv q p -> q=1 oru q=p)")
(strip)
(inst-with "PosDivToProd" (pt "q") (pt "p") 2)
(by-assume 3 "q0" 4)
(inst-with "PosPrimeProd" (pt "p") (pt "q0") (pt "q") 1 4)
(cases (pt "q0=1"))
(assume 6)
(simphyp 4 6)
(intro 1)
(use 7)
(assume 6)
(cases (pt "q=1"))
(assume 7)
(intro 0)
(use "Truth")
(assume 7)
(simphyp 5 6)
(simphyp 8 7)
(intro 0)
(use 9)
;; (cp)
(save "PosDivPrime")

;; PosDivPrimeToEq
(set-goal "all p,q(PosPrime p -> PosPrime q -> PosDiv p q -> p=q)")
(assume "p" "q" 1 2 3)
(inst-with "PosDivPrime" (pt "q") (pt "p") 2 3)
(elim 4)
(assume 5)
(simphyp 1 "PosPrime0CompRule")
(simphyp 6 5)
(use "EfAtom")
(use 7)
(search)
;; (cp)
(save "PosDivPrimeToEq")

;; PosGcdPrime
(set-goal "all p,q(PosPrime q -> PosGcd p q=1 oru PosGcd p q=q)")
(assume "p" "q" 1)
(use "PosDivPrime") 
(use 1)
(use "PosGcdDiv1")
;; (cp)
(save "PosGcdPrime")

;; Lists of Prime Numbers
;; ======================

(add-program-constant "PosPrimes" (py "(nat=>pos)=>nat=>boole"))
(add-computation-rules
 "PosPrimes ps Zero" "True"
 "PosPrimes ps(Succ n)" "PosPrime(ps n) andb PosPrimes ps n")

(set-totality-goal "PosPrimes")
(fold-alltotal)
(assume "ps")
(fold-alltotal)
(ind)
(use "TotalVar")
(assume "n" 1)
(simp "PosPrimes1CompRule")
(use "AndConstTotal")
(use "TotalVar")
(use 1)
;; (cp)
(save-totality)

;; PosPrimesCompat
(set-goal "all ps,qs,m(
 all n(n<m -> ps n=qs n) -> PosPrimes ps m=PosPrimes qs m)")
(assume "ps" "qs")
(ind)
(search)
(assume "n" 1 2)
(simp "PosPrimes1CompRule")
(simp "PosPrimes1CompRule")
(simp (pf "ps n=qs n"))
(simp (pf "PosPrimes ps n=PosPrimes qs n"))
(use "Truth")
(use 1)
(assume "l" 3)
(use 2)
(use "NatLtTrans" (pt "n"))
(use 3)
(use "Truth")
(use 2)
(use "Truth")
;; (cp)
(save "PosPrimesCompat")

;; NatPrimesToPosPrimes
(set-goal "all ns,n(NatPrimes ns n -> PosPrimes([l]NatToPos(ns l))n)")
(assume "ns")
(ind)
(search)
(assume "n" 1)
(simp "PosPrimes1CompRule")
(simp "NatPrimes1CompRule")
(assume 2)
(split)
(bpe-ng)
(use "NatPrimeToPosPrime")
(use 2)
(use 1)
(use 2)
;; (cp)
(save "NatPrimesToPosPrimes")

;; PosPrimesToNatPrimes
(set-goal "all ps,n(PosPrimes ps n -> NatPrimes([l]PosToNat(ps l))n)")
(assume "ps")
(ind)
(search)
(assume "n" 1)
(simp "PosPrimes1CompRule")
(simp "NatPrimes1CompRule")
(assume 2)
(split)
(bpe-ng)
(use "PosPrimeToNatPrime")
(use 2)
(use 1)
(use 2)
;; (cp)
(save "PosPrimesToNatPrimes")

;; PosPrimesToPrime
(set-goal "all m,n,ps(PosPrimes ps m -> n<m -> PosPrime(ps n))")
(ind)
(strip)
(use "EfAtom")
(use 2)
(assume "m" 1 "n" "ps")
(simp "PosPrimes1CompRule")
(assume 2 3)
(cases (pt "n=m"))
(assume 4)
(simp 4)
(use 2)
(assume 4)
(use 1)
(use 2)
(use "NatLtSuccNotEqToLt")
(use 3)
(use 4)
;; (cp)
(save "PosPrimesToPrime")

;; New number for a list
;; =====================

(add-ids (list (list "PosNewNumber"
 (make-arity (py "pos") (py "nat=>pos") (py "nat")) ))
	 '("PosNewNumber p ps Zero" "PosNewNumberInit")
	 '("all p,n,ps(PosNewNumber p ps n -> (ps n=p -> F) ->
                       PosNewNumber p ps (Succ n))" "PosNewNumberCons"))

;; EfPosNewNumber
(set-goal "all p,ps,n(F -> PosNewNumber p ps n)")
(assume "p" "ps" "n")
(assume 1)
(simp (pf "n=Zero"))
(intro 0)
(use "EfAtom")
(use 1)
;; (cp)
(save "EfPosNewNumber")

;; PosNewNumberConsRev
(set-goal "all n,ps,p(
 PosNewNumber p ps(Succ n) -> PosNewNumber p ps n andnc (ps n=p -> F))")
(assert "all n,ps,p(
  PosNewNumber p ps n -> all n0(Succ n0=n ->
  PosNewNumber p ps n0 andnc (ps n0=p -> F)))")
(assume "n" "ps" "p")
(elim)
(ng)
(strip)
(split)
(use "EfPosNewNumber")
(use 2)
(assume 3)
(use 2)
(assume "q" "m" "qs" 2 3 4)
(assume "l" 5)
(ng 5)
(simp 5)
(split)
(use 2)
(use 4)
(strip)
(use 1 (pt "Succ n"))
(use 2)
(use "Truth")
;; (cp)
(save "PosNewNumberConsRev")

;; PosNewNumberDecidable
(set-goal "all n,p,ps(PosNewNumber p ps n ori (PosNewNumber p ps n -> F))")
(ind)
(assume "p" "ps")
(intro 0)
(intro 0)
(assume "n" 1 "p" "ps")
(inst-with 1 (pt "p") (pt "ps"))
(elim 2)
(assume 3)
(cases (pt "ps n=p"))
(assume 4)
(intro 1)
(assume 5)
(inst-with "PosNewNumberConsRev" (pt "n") (pt "ps") (pt "p") 5)
(use 6)
(use 4)
(assume 4)
(intro 0)
(intro 1 (pt "p") (pt "ps"))
(use 3)
(use 4)
(assume 3)
(intro 1)
(assume 4)
(inst-with "PosNewNumberConsRev" (pt "n") (pt "ps") (pt "p") 4)
(use 3)
(use 5)
;; (cp)
(save "PosNewNumberDecidable")

;; PosProd
;; =======

;; PosNotDivProdToNewNumber
(set-goal "all p,ps,n(
 (PosDiv p(PosProd Zero n ps) -> F) -> PosNewNumber p ps n)")
(assume "p" "ps")
(ind)
(assume 1)
(intro 0)
(assume "n" 1 2)
(intro 1 (pt "p") (pt "ps"))
(use 1)
(assume 3)
(use 2)
(simp "PosProd1CompRule")
(inst-with "PosDivToProd" (pt "p") (pt "PosProd Zero n ps") 3)
(by-assume 4 "q" 5)
(use "PosProdToDiv" (pt "q*ps n"))
(ng #t)
(simp "<-" "PosTimesAssoc")
(simp (pf "ps n*p=p*ps n"))
(simp "PosTimesAssoc")
(simp 5)
(use "Truth")
(use "PosTimesComm")
(assume 3)
(use 2)
(simp "PosProd1CompRule")
(use "PosProdToDiv" (pt "PosProd Zero n ps"))
(ng #t)
(simp 3)
(use "Truth")
;; (cp)
(save "PosNotDivProdToNewNumber")

;; PosNotNewNumberToDivProd
(set-goal "all p,ps,n(
 (PosNewNumber p ps n -> F) -> PosDiv p(PosProd Zero n ps))")
(strip)
(cases (pt "PosDiv p (PosProd Zero n ps)"))
(assume 2)
(use "Truth")
(assume 2)
(use 1)
(use "PosNotDivProdToNewNumber")
(use 2)
;; (cp)
(save "PosNotNewNumberToDivProd")

;; PosDivProdPlusOneToNewNumber
(set-goal "all ps,p,n(
 1<p -> PosDiv p(PosProd Zero n ps+1)  -> PosNewNumber p ps n)")
(strip)
(use "PosNotDivProdToNewNumber")
(assume 3)
(assert "p=1")
(use "PosDivAntiSym")
(use "PosDivPlusRev" (pt "PosProd Zero n ps"))
(use 3)
(use 2)
(use "Truth")
(assume 4)
(simphyp 1 4)
(use 5)
;; (cp)
(save "PosDivProdPlusOneToNewNumber")


;; Euclid's proof of the infinitude of prime numbers
;; ================================================

;; PosPrimesToNewPrime
(set-goal "all m,ps(
 PosPrimes ps m -> exl p(PosPrime p andnc PosNewNumber p ps m))")
(assume "m" "ps" 1)
(intro 0 (pt "PosLeastFactor (PosProd Zero m ps+1)"))
(inst-with "PosLeastFactorPrime" (pt "PosProd Zero m ps+1") "Truth")
(split)
(use 2)
(simphyp 2 "PosPrime0CompRule")
(use "PosDivProdPlusOneToNewNumber")
(use 3)
(use "PosLeastFactorDiv")
;; (cp)
(save "PosPrimesToNewPrime")

;; PosPrimeToIrred (Euclid's lemma)
(set-goal "all p,q1,q2(
 PosPrime p -> PosDiv p(q1*q2) -> PosDiv p q1 orb PosDiv p q2)")
(assume "p" "q1" "q2" 1 2)
(inst-with "PosGcdToLinComb" (pt "p") (pt "q1"))
(elim 3)
;;Case 0
(assume 4)
(by-assume 4 "p1" 5)
(assert "PosDiv p q1")
(use "PosProdToDiv" (pt "p1"))
(use 5)
(assume 6)
(simp 6)
(use "Truth")
;;Case 1
(elim)
(assume 5)
(by-assume 5 "p1" 6)
(inst-with "PosPrimeProd" (pt "p") (pt "p1") (pt "q1") 1 6)
(cases (pt "p1=1"))
(assume 8)
(simphyp 6 8)
(simp 9)
(simp "PosDivRefl")
(use "Truth")
(assume 8)
(simphyp 7 8)
(ng 9)
(simphyp 2 9)
(simp 10)
(use "Truth")
;;Cases 2 3
(drop 3 4)
(inst-with "PosGcdPrime"  (pt "q1") (pt "p") 1)
(inst-with "PosDivToProd" (pt "p") (pt "q1*q2") 2)
(by-assume 6 "p0" 7)
;;Case 2 
(elim)
(assume 9)
(by-assume 9 "p1" 10)
(by-assume 10 "p2" 11)
(elim 5)
(assume 12)
(simphyp 12 "PosGcdComm")
(simphyp 11 13)
(assert "p||q2")
(use "PosDivPlusRev" (pt "q2*p1*p"))
(use "PosProdToDiv" (pt "q2*p1"))
(use "Truth")
(simp "PosPlusComm")
(simp (pf "q2+q2*p1*p=q2*(1+p1*p)"))
(simp 14)
(simp "PosTimesComm")
(simp "<-" "PosTimesAssoc")
(simp "<-" 7)
(use "PosProdToDiv" (pt "p2*p0"))
(use "Truth")
(simp "PosTimesPlusDistr")
(use "Truth")
(assume 15)
(simp 15)
(use "Truth")
(assume 12)
(simphyp 12 "PosGcdComm")
(simp 13)
(use "Truth")
;;Case 3
(elim)
(assume "p1")
(elim)
(assume "p2" 11)
(elim 5)
(assume 12)
(simphyp 12 "PosGcdComm")
(simphyp 11 13)
(assert "PosDiv p q2")
(use "PosDivPlusRev" (pt "p2*p0*p"))
(use "PosProdToDiv" (pt "p2*p0"))
(use "Truth")
(simp "<-" "PosTimesAssoc")
(simp 7)
(simp (pf "p2*(q1*q2)+q2=q2*(1+p2*q1)"))
(simp 14)
(use "PosProdToDiv" (pt "q2*p1"))
(use "Truth")
(simp "PosTimesComm")
(simp "PosPlusComm")
(simp "PosTimesPlusDistr")
(simp (pf "q1*q2*p2=q2*(p2*q1)"))
(use "Truth")
(simp "<-" "PosTimesAssoc")
(simp "PosTimesComm")
(simp "PosTimesAssoc")
(use "Truth")
(assume 15)
(simp 15)
(use "Truth")
(assume 12)
(simphyp 12 "PosGcdComm")
(simp 13)
(use "Truth")
;; (cp)
(save "PosPrimeToIrred")

;; PosPrimeToIrredRev
(set-goal "all p,q1,q2(
  PosPrime p -> PosDiv q1(p*q2) -> PosDiv p q1 orb PosDiv q1 q2)")
(strip)
(inst-with "PosDivToProd" (pt "q1") (pt "p*q2") 2)
(by-assume 3 "q3" 4)
(inst-with "PosPrimeToIrred" (pt "p") (pt "q3") (pt "q1") 1 "?")
(cases (pt "p||q3"))
(assume 6)
(inst-with "PosDivToProd" (pt "p") (pt "q3") 6)
(by-assume 7 "q4" 8)
(assert "PosDiv q1 q2")
(use "PosProdToDiv" (pt "q4"))
(use "PosTimesCancelL" (pt "p"))
(ng #t)
(simp "<-" 4)
(simp "<-" 8)
(simp (pf "p*q4=q4*p"))
(use "Truth")
(use "PosTimesComm")
(assume 9)
(simp 9)
(use "Truth")
(assume 6)
(simphyp 5 6)
(simp 7)
(use "Truth")
(use "PosProdToDiv" (pt "q2"))
(use "PosEqSym")
(use "PosEqTrans" (pt "p*q2"))
(use 4)
(use "PosTimesComm")
;; (cp)
(save "PosPrimeToIrredRev")

;; PosPrimeDivProdToDiv
(set-goal "all ps,p,m(PosPrime p -> PosDiv p(PosProd Zero m ps) ->
 exi l(l<m andi PosDiv p(ps l)))")
(assume "ps" "p")
(ind)
(assume 1 2)
(assert "p=1")
(use "PosDivAntiSym")
(simp "PosDiv0CompRule")
(use 2)
(use "Truth")
(assume 3)
(simphyp 1 3)
(intro 0 (pt "Zero"))
(split)
(use 4)
(use "EfAtom")
(use 4)
(assume "m" 1 2 3)
(simphyp 3 "PosProd1CompRule")
(drop 3)
(inst-with
 "PosPrimeToIrred" (pt "p") (pt "PosProd Zero m ps") (pt "ps m") 2 3)
(cases (pt "p||PosProd Zero m ps"))
(assume 6)
(inst-with 1 2 6)
(by-assume 7 "l1" 8)
(intro 0 (pt "l1"))
(split)
(use "NatLtTrans" (pt "m"))
(use 8)
(use "Truth")
(use 8)
(assume 6)
(simphyp 5 6)
(intro 0 (pt "m"))
(split)
(use "Truth")
(use 7)
;; (cp)
(save "PosPrimeDivProdToDiv")

;; (ppc (proof-to-extracted-term))

;; PosPrimeDivProdPrimesToInPrimes
(set-goal "all ps,p,m(
 PosPrime p -> 
 PosPrimes ps m -> PosDiv p(PosProd Zero m ps) -> exl l(l<m andnc ps l=p))")
(strip)
(inst-with "PosPrimeDivProdToDiv" (pt "ps") (pt "p") (pt "m") 1 3)
(by-assume 4 "l" 5)
(intro 0 (pt "l"))
(split)
(use 5)
(use "PosDivAntiSym")
(inst-with "PosDivToProd" (pt "p") (pt "ps l") "?")
(by-assume 6 "q" 7)
(inst-with "PosPrimeProd" (pt "ps l") (pt "q") (pt "p") "?" 7)
(cases (pt "q=1"))
(assume 9)
(simphyp 7 9)
(simp 10)
(use "PosDivRefl")
(assume 9)
(simphyp 8 9)
(simphyp 10 "OrConst2CompRule")
(simphyp 1 "PosPrime0CompRule")
(simphyp 12 11)
(use "EfAtom")
(use 13)
(use "PosPrimesToPrime" (pt "m"))
(use 2)
(use 5)
(use 5)
(use 5)
;; (cp)
(save "PosPrimeDivProdPrimesToInPrimes")

