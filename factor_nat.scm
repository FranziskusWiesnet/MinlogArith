;; 2025-04-03.  factor_nat.scm.  Based on Franziskus Wiesnet's
;; div_nat.scm gcd_nat.scm prime_nat.scm FTA_nat.scm and Factor_nat.scm

;; (load "~/git/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (exload "arith/gcd_nat.scm")
;; (exload "arith/prime_nat.scm")
;; (set! COMMENT-FLAG #t)

;; NatSqrtBoundHalfPred
(set-goal "all n(
     NatEven(Pred n) -> 
     1<n -> (n=3 -> F) -> (n=5 -> F) -> NatSqrt n<=NatHalf(Pred n))")
(cases)
(search)
(cases)
(search)
(cases)
(search)
(cases)
(search)
(cases)
(search)
(cases)
(search)
(cases)
(search)
(assume "n" 1  2 3 4)
(simp "NatSqrt0CompRule")
(use "NatLeastLeIntro")
(ng)
(use "NatLeTrans" (pt "NatHalf n+NatHalf n"))
(simp "NatDoublePlusEq")
(simp "NatDoubleHalfEven")
(use "Truth")
(use 1)
(use "NatLeTrans"
 (pt "Succ(NatHalf n*NatHalf n+NatHalf n+NatHalf n+NatHalf n+
           NatHalf n+NatHalf n+NatHalf n)"))
(use "NatLeTrans" (pt "NatHalf n*NatHalf n+NatHalf n+
                       NatHalf n+NatHalf n+NatHalf n+NatHalf n+NatHalf n"))
(auto)
;; (cp)
(save "NatSqrtBoundHalfPred")

;; NatOddProdToDiffSq
(set-goal "all n,l0,l1(
     NatEven(Succ n) -> 
     Succ Zero<l0 -> 
     Succ Zero<l1 -> 
     n=l0*l1 -> 
     exnc m0,m1(
      m0<m1 andnc 
      m1<NatHalf(Pred n) andnc n=m1*m1--m0*m0))")
(assert "all n,l0,l1(
     NatEven(Succ n) -> 
     Succ Zero<l0 -> 
     Succ Zero<l1 -> 
     n=l0*l1 -> 
     l0<l1 -> 
     exnc m,m0(
      m<m0 andnc 
      m0<NatHalf(Pred n) andnc n=m0*m0--m*m))")
(assume "n" "l0" "l1")
(strip)
(intro 0 (pt "NatHalf(l1--l0)"))
(intro 0 (pt "NatHalf(l1+l0)"))
(simphyp 1 4)
(inst-with "NatOddTimesToOdd0" (pt "l0") (pt "l1") 6)
(inst-with "NatOddTimesToOdd1" (pt "l0") (pt "l1") 6)
(inst-with "NatEvenPlus" (pt "Succ l1") (pt "Succ l0") 8 7)
(inst-with "NatEvenMinus" (pt "Succ l0") (pt "Succ l1") 7 8)
(ng 9 10)
;; Proof of the first part of the disjunction
(split)
 (use "NatHalfLtMonEven")
 (use 10)
 (use 9)
 (use "NatLtTrans" (pt "l1--Zero"))
 (use "NatLtMonMinusRight")
 (use "NatLtTrans" (pt "1"))
 (use "Truth")
 (use 2)
 (use "NatLtToLe")
 (use 5)
 (ng)
 (use "NatLeLtTrans" (pt "l1+Zero"))
 (use "Truth")
 (use "NatLtMonPlus2")
 (use "Truth")
 (use "NatLtTrans" (pt "(Succ Zero)"))
 (use "Truth")
 (use 2)
;; Proof of the secound part of the disjunction
(split)
 (use "NatHalfLtMonEven")
 (use 9)
 (simp "<-" "NatEven2CompRule")
 (cases (pt "n"))
 (assume 11)
 (use "Truth")
 (assume "n0" 11)
 (ng #t)
 (simphyp 1 11)
 (use 12)
 (simp (pf "l1+l0=Pred(Succ (l1+l0))"))
 (use "NatLtMonPred")
 (use "Truth")
 (simp 4)
 (use "NatSuccPlusLtTimes")
 (use "NatLeNotEqToLt")
 (use "NatLtToSuccLe")
 (use 2)
 (assume 11)
 (simphyp 7 (pf "l0=Succ (Succ Zero)"))
 (use 12)
 (use "NatEqSym")
 (use 11)
 (use "NatLeNotEqToLt")
 (use "NatLtToSuccLe")
 (use 3)
 (assume 11)
 (simphyp 8 (pf "l1=Succ (Succ Zero)"))
 (use 12)
 (use "NatEqSym")
 (use 11)
 (use "Truth")
;; Proof of the secound part of the disjunction
 (simp "NatHalfTimes")
 (simp "NatHalfTimes")
 (simp "NatHalfMinus")
 (simp "NatHalfMinus")
 (simp "NatThirdBinom")
 (simp (pf "l1+l0+(l1--l0)= NatDouble l1"))
 (simp (pf "l1+l0--(l1--l0)=NatDouble l0"))
 (simp "NatTimesDouble")
 (simp "NatHalfDouble")
 (simp "NatHalfDouble")
 (simp "NatTimesComm")
 (use 4)
 (use "NatEqTrans" (pt "l0+l0"))
 (use "NatMinusNatMinus")
 (use 5)
 (use "NatDoublePlusEq")
 (simp "<-" "NatPlusAssoc")
 (simp "NatPlusMinusAssoc")
 (simp (pf "l0+l1=l1+l0"))
 (use "NatDoublePlusEq")
 (use "NatPlusComm")
 (use "NatLtToLe")
 (use 5)
 (use "NatEvenTimes")
 (use 10)
 (use "NatEvenTimes")
 (use 9)
 (simp (pf "l1--l0=NatDouble(NatHalf(l1--l0))"))
 (simp "<-" "NatDoubleTimes2")
 (simp "NatHalfDouble")
 (use "NatEvenTimes")
 (use "NatEvenDouble")
 (simp "NatDoubleHalfEven")
 (auto)
 (simp (pf "l1+l0=NatDouble(NatHalf(l1+l0))"))
 (simp "<-" "NatDoubleTimes2")
 (simp "NatHalfDouble")
 (use "NatEvenTimes")
 (use "NatEvenDouble")
 (simp "NatDoubleHalfEven")
 (auto)
(assume 1)
(strip)
(cases (pt "l0<l1"))
(assume 6)
(use 1 (pt "l0") (pt "l1"))
(auto)
(assume 6)
(cases (pt "l1<l0"))
(assume 7)
(use 1 (pt "l1") (pt "l0"))
(auto)
(simp "NatTimesComm")
(auto)
(assume 7)
(assert "l0=l1")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(use 7)
(use "NatNotLtToLe")
(use 6)
(assume 8)
(intro 0 (pt "Zero"))
(intro 0 (pt "l0"))
(split)
(use "NatLtTrans" (pt "Succ Zero"))
(auto)
(split)
(simp 5)
(simp 8)
(cases (pt "l1"))
(assume 9)
(simphyp 4 9)
(use 10)
(cases)
(assume 9)
(simphyp 4 9)
(use 10)
(cases)
(assume 9)
(simphyp 5 8)
(simphyp 10 9)
(simphyp 2 11)
(use 12)
(assume "l3" 10)
(ng)
(use "NatLeToLtSucc")
(use "NatLeTrans" (pt "NatHalf(l3+l3)"))
(simp "NatDoublePlusEq")
(simp "NatHalfDouble")
(use "Truth")
(use "NatLeMonHalf")
(use "Truth")
(simp 5)
(simp 8)
(use "Truth")
;; (cp)
(save "NatOddProdToDiffSq")

(add-program-constant "NatSquare" (py "nat=>boole"))
(add-computation-rules
 "NatSquare n" "([m]m*m=n)(cNatSqr n)")

(set-totality-goal "NatSquare")
(fold-alltotal)
(assume "n")
(use "TotalVar")
(save-totality)

;;PrimeOrComposedFermat
(set-goal "all n(
     Succ Zero<n -> 
     NatPrime n orr exd l0 exl l1(1<l0 andnc 1<l1 andnc n=l0*l1))")
(assume "n" 1)
(inst-with "NatEvenOrOdd" (pt "n"))
(elim 2)
;; Case Even n
 (assume 3)
 (cases (pt "n=2"))
 ;; Case n=2
  (assume 4)
  (intro 0)
  (simp 4)
  (use "Truth")
 ;; Case n=2 -> F
  (assume 4)
  (intro 1)
  (intro 0 (pt "(Succ (Succ Zero))"))
  (intro 0 (pt "NatHalf n"))
  (split)
  (use "Truth")
  (split)
  (simp (pf "1=NatHalf (Succ (Succ Zero))"))
  (use "NatHalfLtMonEven")
  (use "Truth")
  (use 3)
  (use "NatLeNotEqToLt")
  (use "NatLtToSuccLe")
  (use 1)
  (assume 5)
  (use 4)
  (use "NatEqSym")
  (use 5)
  (use "Truth")
  (use "NatEqTrans" (pt "NatHalf n + NatHalf n"))
  (simp "NatDoublePlusEq")
  (use "NatEqSym")
  (use "NatDoubleHalfEven")
  (use 3)
  (use "Truth")
;; Case Odd n
 (assume 3)
 (cases (pt "n=Succ(Succ(Succ Zero))"))
 ;; Case n=3
  (assume 4)
  (intro 0)
  (simp 4)
  (use "Truth")
 ;; Case n=3 -> F
  (assume 4)
  (cases (pt "n=Succ(Succ(Succ(Succ(Succ Zero))))"))
  ;; Case n=5
   (assume 5)
   (intro 0)
   (simp 5)
   (use "Truth")
  ;; Case n=5->F
   (assume 5)
   ;; Abbreviation l
   (assert
     "exi l(l=NatLeastUp(cNatSqr n)(NatHalf(Pred n))([l]NatSquare(l*l--n)))")
    (intro 0 (pt "NatLeastUp(cNatSqr n)(NatHalf(Pred n))([l]NatSquare(l*l--n))"))
    (use "Truth")
    (assume 6)
    (by-assume 6 "l" 7)
   (cases (pt "l=NatHalf(Pred n)"))
   ;; Case l=NatHalf(Pred n)
    (assume 8)
    (intro 0)
    (use "NatProdToPrime")
    (use 1) 
    (assume "l0" "l1" 7)
    (assert "Succ Zero<l0-> Succ Zero<l1 -> F")
    (assume 10 11)
    (inst-with "NatOddProdToDiffSq" (pt "n") (pt "l0") (pt "l1") 3 10 11 "?")
    (by-assume 12 "m0" 13)
    (by-assume 13 "m1" 14)
    (inst-with "NatLeastUpLeIntro"
	       (pt "(cNatSqr n)")
	       (pt "NatHalf(Pred n)")
	       (pt "m1")
	       (pt "[l]NatSquare (l*l--n)")
	       "?"
	       "?")
    (assert "m1<m1")
     (use "NatLtLeTrans" (pt "NatHalf(Pred n)"))
     (use 14)
     (simp "<-" 8)
     (simp 7)
     (use 15)
    (assume 16)
    (use 16)
    (simp (pf "n=m1*m1--m0*m0"))
    (simp "NatSqrExFree")
    (simp "NatSqrt0CompRule")
    (use "NatLeastLeIntro")
    (use "Truth")
    (use 14)
    (assert "NatSquare(m1*m1--n)")
     (simp (pf "m1*m1--n=m0*m0"))
     (simp "NatSquare0CompRule")
     (simp "NatSqrExFree")
     (simp "NatSquareSqrtId")
     (use "Truth")
     (simp (pf "n=m1*m1--m0*m0"))
     (simp "NatMinusMinus")
     (simp "NatPlusComm")
     (use "Truth")
     (use "Truth")
     (use "NatLeMonTimes")
     (use "NatLtToLe")
     (use 14)
     (use "NatLtToLe")
     (use 14)
     (use 14)
    (assume 15)
    (use 15)
    (use "NatEqSym")
    (use 9)
    (assume 10)
    (cases (pt "l0"))
     (assume 11)
     (simphyp 9 11)
     (simphyp 1 (pf "n=Zero"))
     (use "EfAtom")
     (use 13)
     (use "NatEqSym")
     (use 12)
     (cases)
     (search)
    (assume "l2")
    (cases (pt "l1"))
     (assume 11 12)
     (simphyp 9 11)
     (simphyp 1 (pf "n=Zero"))
     (use "EfAtom")
     (use 14)
     (use "NatEqSym")
     (use 13)
     (cases)
     (search)
    (assume "l3" 11 12)
    (use "EfAtom")
    (use 10)
    (simp 12)
    (use "Truth")
    (simp 11)
    (use "Truth")
    (assume 8)
    (intro 1)
    (assert "NatSquare(l*l--n)")
    (simp 7)
    (use-with "NatLeastUpLtElim"
              (pt "cNatSqr n") (pt "NatHalf(Pred n)")
              (pt "[l0]NatSquare(l0*l0--n)") "?" "?")
    (use "NatLeastUpLBound")
    (simp "NatSqrExFree")
    (simp "NatSqrt0CompRule")
    (use "NatLeastLeIntro")
    (bpe-ng)
    (use "NatLeTrans" (pt "NatSqrt n*NatSqrt n"))
    (use "NatSqrtLeToLeSquare")
    (use "Truth")
    (use "NatLeMonSquare")
    (use "NatSqrtBoundHalfPred")
    (simp "<-" "NatEven2CompRule")
    (simp "NatSuccPred")
    (use 3)
    (use "NatLtTrans" (pt "Succ Zero"))
    (use "Truth")
    (use 1)
    (use 1)
    (use 4)
    (use 5)
    (use "NatLeNotEqToLt")
    (use "NatLeastUpBound")
    (simp "<-" 7)
    (use 8)
    (assume 9)
    (assert "exl m(m=cNatSqr(l*l--n))")
     (intro 0 (pt "cNatSqr(l*l--n)"))
     (use "Truth")
     (assume 10)
     (by-assume 10 "m" 11)
    ;;The proper proof.
    (intro 0 (pt "l+m"))
    (intro 0 (pt "l--m"))
    ;; The frist two parts of the conjunction follow by the last one,
    ;; hence we prove it first:
    (assert "n=(l+m)*(l--m)")
     (simp "<-" "NatThirdBinom")
     (simphyp 9 "NatSquare0CompRule")
     (bpe-ng)
     (simp 11)
     (simp 12)
     (simp "NatMinusMinus")
     (simp "NatPlusComm")
     (use "Truth")
     (use "Truth")
     (use "NatLeTrans" (pt "cNatSqr n*cNatSqr n"))
     (use "NatSqrtLeToLeSquare")
     (simp "NatSqrExFree")
     (use "Truth")
     (use "NatLeMonSquare")
     (simp 7)
     (use "NatLeastUpLBound")
     (simp "NatSqrExFree")
     (use "NatSqrtBoundHalfPred")
     (simp "<-" "NatEven2CompRule")
     (simp "NatSuccPred")
     (use 3)
     (use "NatLtTrans" (pt "1"))
     (use "Truth")
     (use 1)
     (use 1)
     (use 4)
     (use 5)
    (assume 12)
    ;; The secound part of the conjunction needs the first part.
    ;; Therefore, we prove the first part outside the conjunction.
    (assert "1<l+m")
     (use "NatLtLeTrans" (pt "l"))
     (use "NatSuccLeToLt")
     (inst-with "NatLeastUpLBound"
      (pt "cNatSqr n") (pt "NatHalf(Pred n)") (pt "[l0]NatSquare(l0*l0--n)") "?")
     (use "NatLeTrans" (pt "cNatSqr n"))
     (simp "NatSqrExFree")
     (simp "NatSqrt0CompRule")
     (use "NatNotLtToLe")
     (assume 14)
     (inst-with "NatLeastLtElim" (pt "Succ n") (pt "[m]n<=m*m") "?")
     (assert "n<n")
      (use "NatLeLtTrans" (pt "1*1"))
      (use "NatLeTrans"
           (pt "NatLeast(Succ n)([m]n<=m*m)*NatLeast(Succ n)([m]n<=m*m)"))
      (use 15)
      (use "NatLeMonSquare")
      (use "NatLtSuccToLe")
      (use 14)
      (use 1)
      (assume 16)
     (use 16)
     (use "NatLeToLtSucc")
     (use "NatSqrtBound")
     (simp 7)
     (use 13)
     (simp "NatSqrExFree")
     (use "NatSqrtBoundHalfPred")
     (simp "<-" "NatEven2CompRule")
     (simp "NatSuccPred")
     (use 3)
     (use "NatLtTrans" (pt "1"))
     (use "Truth")
     (use 1)
     (use 1)
     (use 4)
     (use 5)
     (use "Truth")
    (assume 13)
    ;; First part of the conjunction is already proven
    (split)
     (use 13)
    ;; Second part of the conjunction
    (split)
    (cases (pt "l--m"))
    ;; Cases l--m=0
     (assume 14)
     (simphyp 12 14)
     (simphyp 1 15)
     (use 16)
    ;; Case l--m=Succ ...
    (cases)
    ;; Case l--m=Succ Zero
    (assume 14)
    (simphyp 12 14)
    (assert "m<l")
     (use "NatNotLeToLt")
     (assume 16)
     (inst-with "NatMinusZero" (pt "l") (pt "m") 16)
     (simphyp 17 14)
     (use 18)
    (assume 16)
    (assert "m<m")
     (use "NatLtLeTrans" (pt "l"))
     (use 16)
     (simp 7)
     (simp (pf "NatHalf(Pred n)=m"))
     (use "NatLeastUpBound")
     (simp 15)
     (simp (pf "l=m+1"))
     (ng #t)
     (simp "NatDoublePlusEq")
     (use "NatHalfDouble")
     (simp "<-" 14)
     (simp "NatPlusComm")
     (use "NatEqSym")
     (use "NatMinusPlusEq")
     (use "NatLtToLe")
     (use 16)
    (assume 17)
    (use 17)
   ;; Case l--m=Succ Succ ...
    (assume "n0" 14)
    (use "Truth")
   ;; Last part of the conjunction is already proven
   (use 12)
;; (cp)
(save "PrimeOrComposedFermat")
