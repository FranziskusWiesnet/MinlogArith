;; 2026-01-29.  sdcode.scm

#|
(load "~/git/minlog/init.scm")
(set! COMMENT-FLAG #f)
(libload "nat.scm")
(libload "list.scm")
(libload "pos.scm")
(libload "int.scm")
(libload "rat.scm")
(libload "rea.scm")
(load "~/git/minlog/examples/analysis/digits.scm")
;; (set! COMMENT-FLAG #t)
|#

(display "loading sdcode.scm ...") (newline)

;; Inductive predicate I
;; =====================

;; str renamed into ai (algebra for I), similar to ag and ah for gray
;; code.  Reason: str is a parametrized algebra treated in lib/str.scm

(add-algs "ai" '("C" "sd=>ai=>ai"))
(remove-var-name "w")
(add-var-name "u" "v" "w" (py "ai"))

(add-eqpnc "ai")
;; ok, inductively defined predicate constant EqPAiNc added

(add-co "EqPAiNc")
;; ok, coinductively defined predicate constant CoEqPAiNc added
;; ok, CoEqPAiNcClause has been added as a new theorem.

;; (display-idpc "CoEqPAiNc")

(pp (term-to-type (pt "(CoRec gamma=>ai)")))
;; gamma=>(gamma=>sd yprod(ai ysum gamma))=>ai

;; This type can be explicitly generated by

(pp
 (make-arrow
  (py "gamma")
  (make-arrow
   (make-arrow
    (py "gamma")
    (make-alg "yprod"
	      (make-alg "sd")
	      (make-alg "ysum" (make-alg "ai") (py "gamma"))))
   (make-alg "ai"))))

;; To create the cotype with coai instead of ai we use

;; (make-arrow
;;  (py "gamma")
;;  (make-arrow
;;   (make-arrow
;;    (py "gamma")
;;    (make-alg "yprod"
;; 	     (make-alg "sd")
;; 	     (make-alg "ysum" (make-alg "coai") (py "gamma"))))
;;   (make-alg "coai")))

(add-totality "ai")

;; This adds the c.r. predicate TotalAi of type ai with clause
;; TotalAiC: allnc s^(TotalSd s^ -> allnc u^(TotalAi u^ -> TotalAi(C s^ u^)))

(add-totalnc "ai")
(add-co "TotalAi")
(deanimate "CoTotalAiClause")
(add-co "TotalAiNc")

(add-mr-ids "TotalAi")
(add-co "TotalAiMR")

(add-ids
 (list (list "I" (make-arity (py "rea")) "ai"))
 '("allnc d,x,y(Sd d -> Real x -> abs x<<=1 -> I x -> y===(1#2)*(x+d) -> I y)"
   "GenI"))

(add-mr-ids "I")
(add-co "IMR")

;; General properties of I
;; =======================

;; By the least-fixed-point (or elimination) axiom I is a fixed point.
;; Hence the inverse implication holds as well.

;; Recall (1) and-junctors are rightassociative, and (2) andi (and
;; used interactively) determines decorations automatically).  Example:
;; (pp (pf "Pvar1 andi Pvar^2 andi Pvar3 andi Pvar^4"))
;; Pvar1 andd Pvar^2 andr Pvar3 andl Pvar^4

;; IClauseInv
(set-goal
 "allnc x(I x -> exr d,x0(
 Sd d andi Real x0 andi abs x0<<=1 andi I x0 andi x===(1#2)*(x0+d)))")
(assume "x" "Ix")
(elim "Ix")
(assume "d" "x1" "y1" "Sdd" "Rx1" "x1Bd" "Ix1" "ExHyp" "EqHyp")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(split)
(use "Sdd")
(split)
(use "Rx1")
(split)
(use "x1Bd")
(split)
(use "Ix1")
(use "EqHyp")
;; Proof finished.
;; (cp)
(save "IClauseInv")

(add-var-name "su" (py "sd yprod ai"))

;; (add-sound "IClauseInv")

;; (pp (nf (theorem-name-to-formula "IClauseInvSound")))

;; all x,u^(
;;  IMR x u^ -> 
;;  (ExRTMR int
;;    sd yprod ai
;;    (cterm (d,su^) 
;;    (ExRTMR rea
;;      sd yprod ai
;;      (cterm (x0,su^0) 
;;      (AndDMR (cterm (s^) SdMR d s^)
;;        (cterm (u^0) 
;;        (AndRMR (cterm () Real x0)
;;          (cterm (u^1) 
;;          (AndRMR (cterm () abs x0<<=1)
;;            (cterm (u^2) 
;;            (AndLMR (cterm (u^3) IMR x0 u^3) (cterm () x===(1#2)*(x0+d)))u^2))
;;          u^1))
;;        u^0))
;;      su^0))
;;    su^))
;;  [if u^ (PairConstr sd ai)])

;; (pp "cIClauseInv0CompRule")
;; cIClauseInv eqd([u][if u (PairConstr sd ai)])

(deanimate "IClauseInv")

;; We now add the companion predicate CoI for I, meant to be the
;; greatest-fixed-point of the I clauses.  We also provide GfpCoIMR,
;; needed for soundness proofs when coinduction for CoI was used.

(add-co "I" (list "RealEq"))

;; (pp "CoIClause")
;; allnc x(
;;  CoI x -> 
;;  exr d,x0,y(
;;   Sd d andd 
;;   Real x0 andr abs x0<<=1 andr CoI x0 andl y===(1#2)*(x0+d) andnc x===y))

;; RealClBound
(set-goal "allnc d,x(Real x -> Sd d -> abs x<<=1 -> abs((1#2)*(x+d))<<=1)")
(assume "d" "x" "Rx" "Sdd" "xBd")
(simpreal "RealAbsTimes")
(use "RealLeTimesCancelL" (pt "RealConstr([n](2#1))([p]Zero)") (pt "1"))
(autoreal)
(use "Truth")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealLeTrans" (pt "abs x+RealAbs d"))
(use "RealLeAbsPlus")
(autoreal)
(simpreal (pf "2===RealPlus 1 1"))
(use "RealLeMonPlusTwo")
(use "xBd")
(use "RatLeToRealLe")
(use "SdBound")
(use "Sdd")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "RealClBound")

;; Preparations for AiCoRecExtNc and GfpCoIMR

;; (pp (term-to-type (pt "(CoRec gamma=>ai)")))
;; gamma=>(gamma=>sd yprod(ai ysum gamma))=>ai

(add-var-name "f" (py "gamma=>sd yprod(ai ysum gamma)"))
(remove-var-name "w")
(add-var-name "w" (py "gamma"))

;; AiCoRecL
(set-goal "all f^,w^,s^,u^1(
 f^ w^ eqd(s^ pair(InL ai gamma)u^1) -> (CoRec gamma=>ai)w^ f^ eqd C s^ u^1)")
(assume "f^" "w^" "s^" "u^1" "EqHyp")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst (py "gamma=>ai"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "InitEqD")
;; Proof finished.
;; (cp)
(save "AiCoRecL")

;; AiCoRecR
(set-goal "all f^,w^,s^,w^1(
     f^ w^ eqd(s^ pair(InR gamma ai)w^1) -> 
     (CoRec gamma=>ai)w^ f^ eqd
     C s^((CoRec gamma=>ai)w^1 f^))")
(assume "f^" "w^" "s^" "w^1" "EqHyp")
(assert "all u^2(
 C s^((CoRec gamma=>ai)w^1 f^)eqd u^2 -> (CoRec gamma=>ai)w^ f^ eqd u^2)")
 (assume "u^2" "EqHyp2")
 (simp-with (make-proof-in-aconst-form
 	    (alg-or-arrow-types-to-corec-aconst (py "gamma=>ai"))))
 (ng)
 (simp "EqHyp")
 (ng)
 (use "EqHyp2")
(assume "Assertion")
(use "Assertion")
(use "InitEqD")
;; Proof finished.
;; (cp)
(save "AiCoRecR")

;; AiCoRecExtNcAux is written in a form which makes
;; imp-formulas-to-coind-proof applicable.  AiCoRecExtNc then replaces
;; the existential premise by forall outside.

;; AiCoRecExtNcAux
(set-goal "all f^,f^0(
     all w^,w^0(
      EqPNc w^ w^0 -> 
      exnc s^,u^,s^0,u^0(
       f^ w^ eqd(s^ pair(InL ai gamma)u^) andnc 
       f^0 w^0 eqd(s^0 pair(InL ai gamma)u^0) andnc 
       EqPSdNc s^ s^0 andnc CoEqPAiNc u^ u^0) ornc 
      exnc s^,w^1,s^0,w^2(
       f^ w^ eqd(s^ pair(InR gamma ai)w^1) andnc 
       f^0 w^0 eqd(s^0 pair(InR gamma ai)w^2) andnc 
       EqPSdNc s^ s^0 andnc EqPNc w^1 w^2)) -> 
     all u^,u^0(
      exnc w^,w^0(
       u^ eqd(CoRec gamma=>ai)w^ f^ andnc 
       u^0 eqd(CoRec gamma=>ai)w^0 f^0 andnc EqPNc w^ w^0) -> 
      CoEqPAiNc u^ u^0))")
(assume "f^" "f^0" "f=f0" "u^" "u^0")
(use (imp-formulas-to-coind-proof
      (pf "exnc w^,w^0(
     u^ eqd(CoRec gamma=>ai)w^ f^ andnc 
     u^0 eqd(CoRec gamma=>ai)w^0 f^0 andnc EqPNc w^ w^0) -> 
    CoEqPAiNc u^ u^0")))
(assume "u^1" "u^2" "ExHyp")
(by-assume "ExHyp" "w^" "wProp")
(by-assume "wProp" "w^0" "ww0Prop")
(assert "EqPNc w^ w^0")
(use "ww0Prop")
(assume "w=w0")
(inst-with-to "f=f0" (pt "w^") (pt "w^0") "w=w0" "f=f0Inst")
(drop "f=f0")
(elim "f=f0Inst")
;; 17,18
(drop "f=f0Inst")
(assume "ExHypL")
(by-assume "ExHypL" "s^" "sProp")
(by-assume "sProp" "u^3" "su3Prop")
(by-assume "su3Prop" "s^0" "su3s0Prop")
(by-assume  "su3s0Prop" "u^4" "Conj")
(intro 0 (pt "s^"))
(intro 0 (pt "s^0"))
(split)
(use "Conj")
(simp "ww0Prop")
(simp "ww0Prop")
(intro 0 (pt "u^3"))
(intro 0 (pt "u^4"))
(split)
(intro 0)
(use "Conj")
(split)
(use "AiCoRecL")
(use "Conj")
(use "AiCoRecL")
(use "Conj")
;; 18
(drop "f=f0Inst")
(assume "ExHypR")
(by-assume "ExHypR" "s^" "sProp")
(by-assume "sProp" "w^1" "sw1Prop")
(by-assume "sw1Prop" "s^0" "sw1s2Prop")
(by-assume  "sw1s2Prop" "w^2" "Conj")
(intro 0 (pt "s^"))
(intro 0 (pt "s^0"))
(split)
(use "Conj")
(simp "ww0Prop")
(simp "ww0Prop")
(intro 0 (pt "(CoRec gamma=>ai)w^1 f^"))
(intro 0 (pt "(CoRec gamma=>ai)w^2 f^0"))
(split)
(intro 1)
(intro 0 (pt "w^1"))
(intro 0 (pt "w^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "Conj")
(split)
(use "AiCoRecR")
(use "Conj")
(use "AiCoRecR")
(use "Conj")
;; Proof finished.
;; (cp)
(save "AiCoRecExtNcAux")

(add-var-name "uw" (py "ai ysum gamma"))
(add-var-name "suw" (py "sd yprod(ai ysum gamma)"))

;; AiCoRecExtNc
(set-goal "all w^,w^0(
     EqPNc w^ w^0 -> 
     all f^,f^0(
      all w^1,w^2(
       EqPNc w^1 w^2 -> 
       (REqPYprodNc (cterm (s^,s^0) EqPSdNc s^ s^0)
         (cterm (uw^,uw^0) 
         (REqPYsumNc (cterm (ai^,ai^0) CoEqPAiNc ai^ ai^0)
           (cterm (w^3,w^4) EqPNc w^3 w^4))
         uw^ 
         uw^0))
       (f^ w^1)
       (f^0 w^2)) -> 
      CoEqPAiNc((CoRec gamma=>ai)w^ f^)((CoRec gamma=>ai)w^0 f^0)))")
(assert "all f^,f^0(
      all w^,w^0(
       EqPNc w^ w^0 -> 
       (REqPYprodNc (cterm (s^,s^0) EqPSdNc s^ s^0)
         (cterm (uw^,uw^0) 
         (REqPYsumNc (cterm (u^,u^0) CoEqPAiNc u^ u^0)
           (cterm (w^3,w^4) EqPNc w^3 w^4))
         uw^ 
         uw^0))
       (f^ w^)
       (f^0 w^0)) -> 
     all u^,u^0(
      exnc w^,w^0(
       u^ eqd(CoRec gamma=>ai)w^ f^ andnc 
       u^0 eqd(CoRec gamma=>ai)w^0 f^0 andnc EqPNc w^ w^0) -> 
      CoEqPAiNc u^ u^0))")
(assume "f^" "f^0" "f=f0" "u^" "u^0")
(use "AiCoRecExtNcAux")
(assume "w^" "w^0" "w=w0")
(inst-with-to "f=f0" (pt "w^") (pt "w^0") "w=w0" "f=f0Inst")
(drop "f=f0")
(elim "f=f0Inst")
(drop "f=f0Inst")
(assume "s^" "s^0" "s=s0" "uw^" "uw^0" "uw=uw0")
(elim "uw=uw0")
;; 13,14
(drop "uw=uw0")
(assume "u^1" "u^2" "u1=u2")
(intro 0)
(intro 0 (pt "s^"))
(intro 0 (pt "u^1"))
(intro 0 (pt "s^0"))
(intro 0 (pt "u^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "s=s0")
(use "u1=u2")
;; 14
(drop "uw=uw0")
(assume "w^1" "w^2" "w1=w2")
(intro 1)
(intro 0 (pt "s^"))
(intro 0 (pt "w^1"))
(intro 0 (pt "s^0"))
(intro 0 (pt "w^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "s=s0")
(use "w1=w2")
;; Assertion proved.
(assume "Assertion" "w^" "w^0" "w=w0" "f^" "f^0" "f=f0")
(inst-with-to "Assertion" (pt "f^") (pt "f^0") "f=f0" "AInst")
(drop "f=f0" "Assertion")
(use "AInst")
(intro 0 (pt "w^"))
(intro 0 (pt "w^0"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "w=w0")
;; Proof finished.
;; (cp)
(save "AiCoRecExtNc")

(add-pvar-name "X" (make-arity (py "rea")))
(set! PVAR-TO-TVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "X rea")) (py "gamma"))
	     PVAR-TO-TVAR-ALIST))
(add-pvar-name "XMR" (make-arity (py "rea") (py "gamma")))
(set! PVAR-TO-MR-PVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "X rea"))
		  (predicate-form-to-predicate (pf "XMR^ rea gamma")))
	    PVAR-TO-MR-PVAR-ALIST))

;; GfpCoIMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(CoRec gamma=>ai)")
	    (aconst-to-formula
	     (imp-formulas-to-gfp-aconst (pf "X x -> CoI x"))))))
(assume "x" "w^" "XMRxw" "f^" "Step")
(use-with
 (make-proof-in-aconst-form
  (imp-formulas-to-gfp-aconst (pf "(Pvar rea ai)^ x u^ -> CoIMR x u^")))
 (make-cterm
  (pv "x1") (pv "u^")
  (pf "exnc w^1(XMR^ x1 w^1 andnc u^ eqd((CoRec gamma=>ai)w^1 f^))"))
 (pt "x") (pt "((CoRec gamma=>ai)w^ f^)") ;(pt "f^")
 "?" "?")
;; 3,4
(drop "Step")
(intro 0 (pt "w^"))
(split)
(use "XMRxw")
(use "InitEqD")
;; 4
(drop "XMRxw")
(assume "x1" "u^1" "ExHyp")
(by-assume "ExHyp" "w^1" "x1w1Prop")
(elim "x1w1Prop")
(drop "x1w1Prop")
(assume "XMRx1w1" "u1Def")
(inst-with-to "Step" (pt "x1") (pt "w^1") "XMRx1w1" "StepInst")
(drop "Step")
(assert "exnc d(ExRTMR rea
               sd yprod(ai ysum gamma)
               (cterm (x,suw^0) 
               (ExRTMR rea
                 sd yprod(ai ysum gamma)
                 (cterm (y,suw^1) 
                 (AndDMR (cterm (s^) SdMR d s^)
                   (cterm (uw^) 
                   (AndRMR (cterm () Real x)
                     (cterm (uw^0) 
                     (AndRMR (cterm () abs x<<=1)
                       (cterm (uw^1) 
                       (AndLMR (cterm (uw^2) 
                                 (OrDMR (cterm (u^) CoIMR x u^)
                                   (cterm (w^) XMR^ x w^))
                                 uw^2)
                         (cterm () y===(1#2)*(x+d) andnc x1===y))
                       uw^1))
                     uw^0))
                   uw^))
                 suw^1))
               suw^0))
             (f^ w^1)")
(elim "StepInst")
(drop "StepInst")
(assume "d" "suw^" "ExRTMRsuw")
(intro 0 (pt "d"))
(use "ExRTMRsuw")
;; Assertion proved
(drop "StepInst")
(assume "ExNcHyp")
(by-assume "ExNcHyp" "d" "dProp")
(assert "exnc x(ExRTMR rea
                 sd yprod(ai ysum gamma)
                 (cterm (y,suw^0) 
                 (AndDMR (cterm (s^) SdMR d s^)
                   (cterm (uw^) 
                   (AndRMR (cterm () Real x)
                     (cterm (uw^0) 
                     (AndRMR (cterm () abs x<<=1)
                       (cterm (uw^1) 
                       (AndLMR (cterm (uw^2) 
                                 (OrDMR (cterm (u^) CoIMR x u^)
                                   (cterm (w^) XMR^ x w^))
                                 uw^2)
                         (cterm () y===(1#2)*(x+d) andnc x1===y))
                       uw^1))
                     uw^0))
                   uw^))
                 suw^0))
                 (f^ w^1)")
(elim "dProp")
(drop "dProp")
(assume "x2" "suw^" "ExRTMR1suw")
(intro 0 (pt "x2"))
(use "ExRTMR1suw")
;; Assertion proved.
(drop "dProp")
(assume "ExNcHyp1")
(by-assume "ExNcHyp1" "x2" "x2Prop")
(assert "exnc y(AndDMR (cterm (s^) SdMR d s^)
                        (cterm (uw^) 
                        (AndRMR (cterm () Real x2)
                          (cterm (uw^0) 
                          (AndRMR (cterm () abs x2<<=1)
                            (cterm (uw^1) 
                            (AndLMR (cterm (uw^2) 
                                      (OrDMR (cterm (u^) CoIMR x2 u^)
                                        (cterm (w^) XMR^ x2 w^))
                                      uw^2)
                              (cterm () y===(1#2)*(x2+d) andnc x1===y))
                            uw^1))
                          uw^0))
                        uw^))
                       (f^ w^1)")
(elim "x2Prop")
(drop "x2Prop")
(assume "y" "suw^" "AndDMRsuw")
(intro 0 (pt "y"))
(use "AndDMRsuw")
;; Assertion proved.
(drop "x2Prop")
(assume "ExNcHyp2")
(by-assume "ExNcHyp2" "y" "yProp")
(assert "(f^ w^1)eqd clft(f^ w^1)pair crht(f^ w^1) andnc
 SdMR d(clft(f^ w^1)) andnc
 (AndRMR (cterm () Real x2)
                            (cterm (uw^0) 
                            (AndRMR (cterm () abs x2<<=1)
                              (cterm (uw^1) 
                              (AndLMR (cterm (uw^2) 
                                        (OrDMR (cterm (u^) CoIMR x2 u^)
                                          (cterm (w^) XMR^ x2 w^))
                                        uw^2)
                                (cterm () y===(1#2)*(x2+d) andnc x1===y))
                              uw^1))
                            uw^0))
                           (crht(f^ w^1))")
(elim "yProp")
(drop "yProp")
(assume "s^" "SdMRds" "uw^" "AndRMRuw")
(ng #t)
(split)
(simp "STotalToPairClftCrhtEq")
(use "InitEqD")
(intro 0)
(split)
;; Need animation of Lft here
(animate "Lft")
(ng #t)
(use "SdMRds")
(animate "Rht")
(ng #t)
(use "AndRMRuw")
;; Assertion proved.
(drop "yProp")
(assume "Conj")
(inst-with-to "Conj" 'left "fw1Pair")
(inst-with-to "Conj" 'right 'left "SdMRclftfw1")
(inst-with-to "Conj" 'right 'right "AndRMRuw")
(drop "Conj")
(assert "Real x2 andnc (AndRMR (cterm () abs x2<<=1)
               (cterm (uw^0) 
               (AndLMR (cterm (uw^1) 
                         (OrDMR (cterm (u^) CoIMR x2 u^)
                           (cterm (w^) XMR^ x2 w^))
                         uw^1)
                 (cterm () y===(1#2)*(x2+d) andnc x1===y))
               uw^0))(crht(f^ w^1))")
(elim "AndRMRuw")
(drop "AndRMRuw")
(assume "Rx2" "uw^" "AndRMR1uw")
(split)
(use "Rx2")
(use "AndRMR1uw")
;; Assertion proved.
(drop "AndRMRuw")
(assume "Conj1")
(inst-with-to "Conj1" 'left "Rx2")
(inst-with-to "Conj1" 'right "AndRMRcrhtfw1")
(drop "Conj1")
(assert "abs x2<<=1 andnc (AndLMR (cterm (uw^0) 
                           (OrDMR (cterm (u^) CoIMR x2 u^)
                             (cterm (w^) XMR^ x2 w^))
                           uw^0)
                   (cterm () y===(1#2)*(x2+d) andnc x1===y))(crht(f^ w^1))")
(elim "AndRMRcrhtfw1")
(drop "AndRMRcrhtfw1")
(assume "x2Bd" "uw^" "AndLMRuw")
(split)
(use "x2Bd")
(use "AndLMRuw")
;; Assertion proved.
(drop "AndRMRcrhtfw1")
(assume "Conj2")
(inst-with-to "Conj2" 'left "x2Bd")
(inst-with-to "Conj2" 'right "AndLMRcrhtfw1")
(drop "Conj2")
(assert "(OrDMR (cterm (u^) CoIMR x2 u^)
                           (cterm (w^) XMR^ x2 w^))(crht(f^ w^1))
 andnc
 y===(1#2)*(x2+d) andnc x1===y")
(elim "AndLMRcrhtfw1")
(drop "AndLMRcrhtfw1")
(assume "uw^" "OrDMRuw" "Conj3")
(split)
(use "OrDMRuw")
(use "Conj3")
;; Assertion proved.
(drop "AndLMRcrhtfw1")
(assume "Conj4")
(inst-with-to "Conj4" 'left "OrDMRcrhtfw1")
(inst-with-to "Conj4" 'right "Conj5")
(elim "Conj5")
(drop "Conj5")
(assume "yDef" "x1=y")
(drop "Conj4")
(assert "exnc u^(CoIMR x2 u^ andnc crht(f^ w^1)eqd(InL ai gamma)u^)ornc
         exnc w^(XMR^ x2 w^ andnc crht(f^ w^1)eqd(InR gamma ai)w^)")
(elim "OrDMRcrhtfw1")
(drop "OrDMRcrhtfw1")
(assume "u^2" "CoIMRx2u2")
(intro 0)
(intro 0 (pt "u^2"))
(split)
(use "CoIMRx2u2")
(use "InitEqD")
;; Assertion proved.
(drop "OrDMRcrhtfw1")
(assume "w^2" "XMRx2w2")
(intro 1)
(intro 0 (pt "w^2"))
(split)
(use "XMRx2w2")
(use "InitEqD")
;; 121
(drop "OrDMRcrhtfw1")
(assume "Disj")
(elim "Disj")
;; 139,140
(drop "Disj")
(assume "ExHyp1")
(by-assume "ExHyp1" "u^2" "u2Prop")
;; (pp "AiCoRecL")
;; all f^,w^,s^,u^(
;;  f^ w^ eqd(s^ pair(InL ai gamma)u^) -> (CoRec gamma=>ai)w^ f^ eqd C s^ u^)
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(intro 0 (pt "clft(f^ w^1)"))
(split)
(use "SdMRclftfw1")
(split)
(use "Rx2")
(split)
(use "x2Bd")
(intro 0 (pt "u^2"))
(split)
(intro 0)
(use "u2Prop")
(split)
(use "RealEqTrans" (pt "y"))
(use "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "u1Def")
(use "AiCoRecL")
(simp "<-" "u2Prop")
(use "fw1Pair")
;; 140
(drop "Disj")
(assume "ExHyp1")
(by-assume "ExHyp1" "w^2" "w2Prop")
;; (pp "AiCoRecR")
;; all f^,w^,s^,w^0(
;;  f^ w^ eqd(s^ pair(InR gamma ai)w^0) -> 
;;  (CoRec gamma=>ai)w^ f^ eqd C s^((CoRec gamma=>ai)w^0 f^))
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(intro 0 (pt "clft(f^ w^1)"))
(split)
(use "SdMRclftfw1")
(split)
(use "Rx2")
(split)
(use "x2Bd")
(intro 0 (pt "(CoRec gamma=>ai)w^2 f^"))
(split)
(intro 1)
(intro 0 (pt "w^2"))
(split)
(use "w2Prop")
(use "InitEqD")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "u1Def")
(use "AiCoRecR")
(simp "<-" "w2Prop")
(use "fw1Pair")
;; Proof finished.
;; (cp)
(save "GfpCoIMR")

(deanimate "Lft")
(deanimate "Rht")

;; Similarly we prove ClauseCoIMR

;; ClauseCoIMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(Destr ai)")
	    (aconst-to-formula
	     (theorem-name-to-aconst "CoIClause")))))
(assume "x" "u^" "CoIMRxu")
(inst-with-to "CoIMRClause" (pt "x") (pt "u^") "CoIMRxu" "CoIMRClauseInst")
(by-assume "CoIMRClauseInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(by-assume "dx1yProp" "s^" "dx1ysProp")
(elim "dx1ysProp")
(drop "dx1ysProp")
(assume "SdMRds" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "Rx1" "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "x1Bd" "ExHyp")
(by-assume "ExHyp" "u^1" "u1Prop")
(elim "u1Prop")
(drop "u1Prop")
(assume "CoIMRx1u1" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "yDef" "Conj4")
(elim "Conj4")
(drop "Conj4")
(assume "x=y" "uDef")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y"))
(simp "uDef")
(ng #t)
(intro 0)
(use "SdMRds")
(intro 0)
(use "Rx1")
(intro 0)
(use "x1Bd")
(intro 0)
(use "CoIMRx1u1")
(split)
(use "yDef")
(simp "x=y")
(use "RealEqRefl")
(realproof)
;; Proof finished.
;; (cp)
(save "ClauseCoIMR")

;; (add-sound "CoIClause")

;; (pp "CoIClauseSound")

;; all x,u^(
;;  CoIMR x u^ -> 
;;  (ExRTMR int
;;    sd yprod ai
;;    (cterm (d,su^) 
;;    (ExRTMR rea
;;      sd yprod ai
;;      (cterm (x0,su^0) 
;;      (ExRTMR rea
;;        sd yprod ai
;;        (cterm (y,su^1) 
;;        (AndDMR (cterm (s^) SdMR d s^)
;;          (cterm (u^0) 
;;          (AndRMR (cterm () Real x0)
;;            (cterm (u^1) 
;;            (AndRMR (cterm () abs x0<<=1)
;;              (cterm (u^2) 
;;              (AndLMR (cterm (u^3) CoIMR x0 u^3)
;;                (cterm () y===(1#2)*(x0+d) andnc x===y))
;;              u^2))
;;            u^1))
;;          u^0))
;;        su^1))
;;      su^0))
;;    su^))
;;  (DesYprod u^))

;; (pp "cCoIClause0CompRule")
;; cCoIClause eqd(Destr ai)

;; (cp (theorem-name-to-proof "CoIClauseSound"))

;; Here we do not deanimate CoIClause, since we do not want to use
;; cCoIClause as an abbreviation.

;; By the greatest-fixed-point (or coinduction) axiom CoI is a fixed
;; point.  Hence the inverse implication holds as well.

;; CoIClauseInv
(set-goal
 "allnc x(exr d,x0,y(Sd d andi Real x0 andi abs x0<<=1 andi CoI x0 andi
  y===(1#2)*(x0+d) andi x===y) -> CoI x)")
(assume "x" "ExHyp")
(coind "ExHyp")
(assume "x1" "x1Prop")
(by-assume "x1Prop" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(by-assume "dx2Prop" "y" "dx2yProp")
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "y"))
(split)
(use "dx2yProp")
(split)
(use "dx2yProp")
(split)
(use "dx2yProp")
(split)
(intro 0)
(use "dx2yProp")
(split)
(use "dx2yProp")
(use "dx2yProp")
;; Proof finished.
;; (cp)
(save "CoIClauseInv")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)

;; [su]C clft su crht su

;; (add-sound "CoIClauseInv")

;; (pp (nf (theorem-name-to-formula "CoIClauseInvSound")))

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [su]C[if su ([s,u]s)][if su ([s,u]u)]

;; (pp "cCoIClauseInv0CompRule")

;; cCoIClauseInv eqd
;; ([su]
;;   (CoRec sd yprod ai=>ai)su
;;   ([su0][if su0 ([s,u]s)]pair(InL ai (sd yprod ai))[if su0 ([s,u]u)]))

;; (cp (theorem-name-to-proof "CoIClauseInvSound"))

;; all x,su^(
;;  (ExRTMR int
;;    sd yprod ai
;;    (cterm (d,su^0) 
;;    (ExRTMR rea
;;      sd yprod ai
;;      (cterm (x0,su^1) 
;;      (ExRTMR rea
;;        sd yprod ai
;;        (cterm (y,su^2) 
;;        (AndDMR (cterm (s^) SdMR d s^)
;;          (cterm (u^) 
;;          (AndRMR (cterm () Real x0)
;;            (cterm (u^0) 
;;            (AndRMR (cterm () abs x0<<=1)
;;              (cterm (u^1) 
;;              (AndLMR (cterm (u^2) CoIMR x0 u^2)
;;                (cterm () y===(1#2)*(x0+d) andnc x===y))
;;              u^1))
;;            u^0))
;;          u^))
;;        su^2))
;;      su^1))
;;    su^0))
;;  su^ -> 
;;  CoIMR x
;;  ((CoRec sd yprod ai=>ai)su^
;;   ([su0]clft su0 pair(InL ai (sd yprod ai))crht su0)))

(deanimate "CoIClauseInv")

;; We show that CoI satisfies the clause of I

;; GenCoI 
(set-goal "allnc d,x,y(Sd d -> Real x -> abs x<<=1 -> CoI x ->
  y===(1#2)*(x+d) -> CoI y)")
(assume "d" "x" "y" "Sdd" "Rx" "xBd" "CoIx" "EqHyp")
(use "CoIClauseInv")
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(intro 0 (pt "y"))
(split)
(use "Sdd")
(split)
(use "Rx")
(split)
(use "xBd")
(split)
(use "CoIx")
(split)
(use "EqHyp")
(use "RealEqRefl")
(use "RealEqToReal0" (pt "(1#2)*(x+d)"))
(use "EqHyp")
;; Proof finished.
;; (cp)
(save "GenCoI")

(define eterm (proof-to-extracted-term))
(animate "CoIClauseInv")
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [s,u]C clft(s pair u)crht(s pair u)

;; (add-sound "GenCoI")
;; (pp (nf (theorem-name-to-formula "GenCoISound")))

;; all d,x,y,s^(
;;  SdMR d s^ -> 
;;  Real x -> 
;;  abs x<<=1 -> 
;;  all u^(
;;   CoIMR x u^ -> 
;;   y===(1#2)*(x+d) -> 
;;   CoIMR y
;;   ((CoRec sd yprod ai=>ai)(s^ pair u^)
;;    ([su0]clft su0 pair(InL ai (sd yprod ai))crht su0))))

;; (pp "cGenCoI0CompRule")

;; cGenCoI eqd
;; ([s,u]
;;   (CoRec sd yprod ai=>ai)(s pair u)
;;   ([su]clft su pair(InL ai (sd yprod ai))crht su))

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [s,u]cCoIClauseInv(s pair u)

;; (cp (theorem-name-to-proof "GenCoISound"))

(deanimate "GenCoI")

;; An immediate consequence is that the least-fixed-point is contained
;; in the greatest-fixed-point.

;; IToCoI
(set-goal "allnc x(I x -> CoI x)")
(assume "x" "Ix")
(elim "Ix")
(assume "d" "x1" "y" "Sdd" "Rx1" "x1Bd" "Ix1" "CoIx1" "EqHyp")
(use "GenCoI" (pt "d") (pt "x1"))
(use "Sdd")
(use "Rx1")
(use "x1Bd")
(use "CoIx1")
(use "EqHyp")
;; Proof finished.
;; (cp)
(save "IToCoI")

;; (add-sound "IToCoI")

;; (pp (nf (theorem-name-to-formula "IToCoISound")))
;; all x,u^(IMR x u^ -> CoIMR x((Rec ai=>ai)u^([s0,u1]cGenCoI s0)))

;; (pp "cIToCoI0CompRule")
;; cIToCoI eqd([u](Rec ai=>ai)u([s,u0]cGenCoI s))

(define eterm (proof-to-extracted-term))
(animate "GenCoI")
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [u](Rec ai=>ai)u([s,u0,u1]C clft(s pair u1)crht(s pair u1))

(deanimate "GenCoI")
(deanimate "IToCoI")

;; Specific properties of I
;; ========================

;; IToReal
(set-goal "all x(I x -> Real x)")
(assume "x" "Ix")
(inst-with-to "IClauseInv" (pt "x") "Ix" "IClauseInvInst")
(by-assume "IClauseInvInst" "d" "dProp")
(by-assume "dProp" "x0" "dx0Prop") 
(use "RealEqToReal0" (pt "(1#2)*(x0+d)"))
(use "dx0Prop")
;; Proof finished.
;; (cp)
(save "IToReal")

;; RealICompat
(set-goal "allnc x,y(x===y -> I x -> I y)")
(assume "x" "y" "x===y" "Ix")
(elim "Ix")
(assume
 "d" "x1" "y1" "Useless1" "Useless2" "Useless3" "Useless4" "Iy" "Useless5")
(use "Iy")
;; Proof finished.
;; (cp)
(save "RealICompat")

(define eterm (proof-to-extracted-term))
;; (pp (rename-variables eterm))

;; [u](Rec ai=>ai)u([s,u0,u1]u1)

;; (add-sound "RealICompat")
;; (pp (nf (theorem-name-to-formula "RealICompatSound")))

;; all x,y(x===y -> all u^(IMR x u^ -> IMR y((Rec ai=>ai)u^([s0,u1,u2]u2))))

;; (pp "cRealICompat0CompRule")

;; cRealICompat eqd([u](Rec ai=>ai)u([s,u0,u1]u1))

;; (cp (theorem-name-to-proof "RealICompatSound"))

(deanimate "RealICompat")

;; CoIToReal
(set-goal "all x(CoI x -> Real x)")
(assume "x" "CoIx")
(inst-with-to "CoIClause" (pt "x") "CoIx" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(use "RealEqToReal0" (pt "y"))
(use "dx1yProp")
;; Proof finished.
;; (cp)
(save "CoIToReal")

;; SdBoundReal
(set-goal "all d(Sd d -> RealAbs d<<=1)")
(assume "d" "Sdd")
(use "RatLeToRealLe")
(use "SdBound")
(use "Sdd")
;; Proof finished.
;; (cp)
(save "SdBoundReal")

;; CoIToBd
(set-goal "all x(CoI x -> abs x<<=1)")
(assume "x" "CoIx")
(inst-with-to "CoIClause" (pt "x") "CoIx" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(simpreal "dx1yProp")
(simpreal "dx1yProp")
(assert "Real x1")
(use "dx1yProp")
(assume "Rx1")
(use "RealLeAbs")
;; 19,20
(simpreal (pf "RealConstr([n](1#1))([p]Zero)===RealTimes(1#2)(RealPlus 1 1)"))
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlusTwo")
(use "RealLeTrans" (pt "abs x1"))
(use "RealLeIdAbs")
(use "Rx1")
(use "dx1yProp")
(use "RealLeTrans" (pt "RealAbs d"))
(use "RealLeIdAbs")
(use "RealRat")
(use "SdBoundReal")
(use "dx1yProp")
;; ?^22:1===(1#2)*RealPlus 1 1
(use "RealEqRefl")
(use "RealRat")
;; ?^20:~((1#2)*(x1+d))<<=1
(simpreal "<-" (pf "~(RealUMinus 1)===1"))
(use "RealLeUMinus")
(simpreal
 (pf "RealUMinus 1===RealTimes(1#2)(RealPlus(RealUMinus 1)(RealUMinus 1))"))
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlusTwo")
(simpreal "<-" (pf "~ ~x1===x1"))
(use "RealLeUMinus")
(use "RealLeTrans" (pt "abs x1"))
(simpreal "<-" "RealAbsUMinus")
(use "RealLeIdAbs")
(autoreal)
(use "dx1yProp")
(use "RealUMinusUMinus")
(use "Rx1")
(simpreal "<-" (pf "~(RealUMinus d)===d"))
(use "RealLeUMinus")
(use "RealLeTrans" (pt "RealAbs d"))
(simpreal "<-" "RealAbsUMinus")
(use "RealLeIdAbs")
(autoreal)
(use "SdBoundReal")
(use "dx1yProp")
(use "RealUMinusUMinus")
(use "RealRat")
(use "RealEqRefl")
(use "RealRat")
(use "RealUMinusUMinus")
(use "RealRat")
;; Proof finished.
;; (cp)
(save "CoIToBd")

;; CoIToLBd
(set-goal "all x(CoI x -> IntN 1<<=x)")
(assume "x" "CoIx")
(use "RealLeUMinusInv")
(use "RealLeTrans" (pt "abs ~x"))
(use "RealLeIdAbs")
(autoreal)
(simpreal "RealAbsUMinus")
(use-with "CoIToBd" (pt "x") "CoIx")
(autoreal)
;; Proof finished.
;; (cp)
(save "CoIToLBd")

;; CoIToUBd
(set-goal "all x(CoI x -> x<<=1)")
(assume "x" "CoIx")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeIdAbs")
(autoreal)
(use-with "CoIToBd" (pt "x") "CoIx")
;; Proof finished.
;; (cp)
(save "CoIToUBd")

;; CoICompat
(set-goal "allnc x,y(x===y -> CoI x -> CoI y)")
(assume "x" "y" "x===y" "CoIx")
(inst-with-to "CoIClause" (pt "x") "CoIx" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y1" "dx1y1Prop")
(use "CoIClauseInv")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y1"))
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(use "RealEqSym")
(use "RealEqTrans" (pt "x"))
(use "RealEqSym")
(use "dx1y1Prop")
(use "x===y")
;; Proof finished.
;; (cp)
(save "CoICompat")

(define eterm (proof-to-extracted-term))
(animate "GenCoI")
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [u]C clft(cCoIClause u)crht(cCoIClause u)

(animate "Lft")
(animate "Rht")
(define neterm (rename-variables (nt eterm)))
(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp nneterm)
;; [u]C[if (cCoIClause u) ([s,u0]s)][if (cCoIClause u) ([s,u0]u0)]

;; (add-sound "CoICompat")

;; (pp (nf (theorem-name-to-formula "CoICompatSound")))

;; all x,y(
;;  x===y -> 
;;  all u^(
;;   CoIMR x u^ -> 
;;   CoIMR y
;;   ((CoRec sd yprod ai=>ai)
;;    ([if (cCoIClause u^) ([s0,u1]s0)]pair[if (cCoIClause u^) ([s0,u1]u1)])
;;    ([su0][if su0 ([s1,u2]s1)]pair(InL ai (sd yprod ai))[if su0 ([s1,u2]u2)]))))

;; (pp "cCoICompat0CompRule")

;; cCoICompat eqd
;; ([u]
;;   (CoRec sd yprod ai=>ai)
;;   ([if (cCoIClause u) ([s,u0]s)]pair[if (cCoIClause u) ([s,u0]u0)])
;;   ([su][if su ([s,u0]s)]pair(InL ai (sd yprod ai))[if su ([s,u0]u0)]))

;; (cp (theorem-name-to-proof "CoICompatSound"))

(deanimate "CoICompat")
(deanimate "Lft")
(deanimate "Rht")
(deanimate "GenCoI")

;; We provide a simplified variant of CoIClause.

;; CoIClosure
(set-goal "allnc x(CoI x -> exr d,x1(Sd d andi CoI x1 andi x===(1#2)*(x1+d)))")
(assume "x" "CoIx")
(inst-with-to "CoIClause" (pt "x") "CoIx" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(split)
(use "dx1yProp")
(split)
(use "dx1yProp")
(use "RealEqTrans" (pt "y"))
(use "dx1yProp")
(use "dx1yProp")
;; Proof finished.
;; (cp)
(save "CoIClosure")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; (Destr ai)

;; Need animation of Lft Rht for (add-sound "CoIClosure")
(animate "Lft")
(animate "Rht")

;; (add-sound "CoIClosure")

;; (pp (nf (theorem-name-to-formula "CoIClosureSound")))

;; all x,u^(
;;  CoIMR x u^ -> 
;;  (ExRTMR int
;;    sd yprod ai
;;    (cterm (d,su^) 
;;    (ExRTMR rea
;;      sd yprod ai
;;      (cterm (x0,su^0) 
;;      (AndDMR (cterm (s^) SdMR d s^)
;;        (cterm (u^0) 
;;        (AndLMR (cterm (u^1) CoIMR x0 u^1) (cterm () x===(1#2)*(x0+d)))u^0))
;;      su^0))
;;    su^))
;;  ([if (DesYprod u^) ([s0,u1]s0)]pair[if (DesYprod u^) ([s0,u1]u1)]))

;; (pp "cCoIClosure0CompRule")

;; cCoIClosure eqd
;; ([u][if (DesYprod u) ([s,u0]s)]pair[if (DesYprod u) ([s,u0]u0)])

(deanimate "CoIClosure")
(deanimate "Lft")
(deanimate "Rht")

;; "RealDoubleClosureEq")
(set-goal "all x,d,e(Real x -> (1#2)*((1#2)*(x+e)+d)===(1#4)*(x+(e+2*d)))")
(assume "x" "d" "e" "Rx")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(simp "<-" "IntTimesAssoc")
(simp "<-" "IntTimesAssoc")
(ng #t)
(simp-with "IntTimesComm" (pt "2*d") (pt "IntPos 8"))
(ng #t)
(simp-with "IntTimesComm" (pt "IntPos 16") (pt "d"))
(use "Truth")
(autoreal)
;; Proof finished.
;; (cp)
(save "RealDoubleClosureEq")

;; CoGfpIter
(set-goal "allnc x((Pvar rea)x -> 
                   exr d,x0(Sd d andd Real x0 andr 
                            abs x0<<=1 andr (Pvar rea)x0 andl
                            x===(1#2)*(x0+d))) ->
           allnc x((Pvar rea) x -> CoI x)")
(assume "Hyp" "x" "Px")
(coind "Px")
(assume "x0" "Px0")
(inst-with-to "Hyp" (pt "x0") "Px0" "Inst")
(by-assume "Inst" "d" "dProp")
(by-assume "dProp" "y" "dyProp")
(intro 0 (pt "d"))
(intro 0 (pt "y"))
(intro 0 (pt "x0"))
(split)
(use "dyProp")
(split)
(use "dyProp")
(split)
(use "dyProp")
(split)
(intro 1)
(use "dyProp")
(split)
(use "dyProp")
(use "RealEqRefl")
(use "RealEqToReal0" (pt "(1#2)*(y+d)"))
(use "dyProp")
;; Proof finished.
;; (cp)
(save "CoIGfpIter")

;; (define eterm (proof-to-extracted-term (theorem-name-to-proof "CoIGfpIter")))
;; (animate "Lft")
;; (animate "Rht")
;; (add-var-name "al" (py "alpha3655"))
;; (add-var-name "St" (py "alpha3655=>sd yprod alpha3655"))
;; (pp (rename-variables (nt eterm)))
;; [St,al]
;;  (CoRec alpha3655=>ai)al
;;  ([al0]
;;    [if (St al0) ([s,al1]s)]pair(InR alpha3655 ai)[if (St al0) ([s,al1]al1)])

;; (pp (rename-variables (nt (undelay-delayed-corec eterm 1))))
;; [St,al]
;;  C[if (St al) ([s,al0]s)]
;;  ((CoRec alpha3655=>ai)[if (St al) ([s,al0]al0)]
;;   ([al0]
;;    [if (St al0) ([s,al1]s)]pair(InR alpha3655 ai)[if (St al0) ([s,al1]al1)]))

;; (deanimate "Lft")
;; (deanimate "Rht")

;; CoIUMinus
(set-goal "allnc x(CoI(~x) -> CoI x)")
(assume "x" "CoI-x")
(coind "CoI-x")
(assume "x1" "CoI-x1")
(assert "Real x1")
(use "RealUMinusRealInv")
(use "CoIToReal")
(use "CoI-x1")
(assume "Rx1")
(inst-with-to "CoIClosure" (pt "~x1") "CoI-x1" "CoIClosureInst")
(by-assume "CoIClosureInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
;; Since realproof cannot look into conjunctions we provide
(assert "CoI x2")
 (use "dx2Prop")
(assume "CoIx2")
(intro 0 (pt "~d"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "SdUMinus")
(use "dx2Prop")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoIToBd")
(use "CoIx2")
(autoreal)
(split)
(intro 1)
(simpreal "RealUMinusUMinus")
(use "CoIx2")
(autoreal)
(split)
;; 39,40
(simpreal "<-" "RealUMinusPlusRat")
(simpreal "RealTimesIdUMinus")
(use "RealUMinusInj")
(simpreal "RealUMinusUMinus")
(use "dx2Prop")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "CoIUMinus")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [u]
;;  (CoRec ai=>ai)u
;;  ([u0]
;;    cSdUMinus clft(cCoIClosure u0)pair InR(cCoICompat crht(cCoIClosure u0)))

;; (add-sound "CoIUMinus")

;; (pp (nf (theorem-name-to-formula "CoIUMinusSound")))

;; all x,u^(
;;  CoIMR(~x)u^ -> 
;;  CoIMR x
;;  ((CoRec ai=>ai)u^
;;   ([u0]
;;     cSdUMinus clft(cCoIClosure u0)pair
;;     (InR ai ai)(cCoICompat crht(cCoIClosure u0)))))

;; (pp "cCoIUMinus0CompRule")

;; cCoIUMinus eqd
;; ([u]
;;   (CoRec ai=>ai)u
;;   ([u0]
;;     cSdUMinus clft(cCoIClosure u0)pair
;;     (InR ai ai)(cCoICompat crht(cCoIClosure u0))))

;; (cp (theorem-name-to-proof "CoIUMinusSound"))

(deanimate "CoIUMinus")

;; CoIClosureInv
(set-goal "allnc d,x(Sd d -> CoI x -> CoI((1#2)*(x+d)))")
(assume "d" "x" "Sdd" "CoIx")
(use "CoIClauseInv")
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*(x+d)"))
(split)
(use "Sdd")
(split)
(autoreal)
(split)
(use "CoIToBd")
(use "CoIx")
(split)
(use "CoIx")
(split)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "CoIClosureInv")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [s,u](CoRec sd yprod ai=>ai)(s pair u)([su]clft su pair InL crht su)

;; (add-sound "CoIClosureInv")

;; (pp (nf (theorem-name-to-formula "CoIClosureInvSound")))

;; all d,x,s^(
;;  SdMR d s^ -> 
;;  all u^(
;;   CoIMR x u^ -> 
;;   CoIMR((1#2)*(x+d))
;;   ((CoRec sd yprod ai=>ai)(s^ pair u^)
;;    ([su0]clft su0 pair(InL ai (sd yprod ai))crht su0))))

;; (pp "cCoIClosureInv0CompRule")

;; cCoIClosureInv eqd
;; ([s,u]
;;   (CoRec sd yprod ai=>ai)(s pair u)
;;   ([su]clft su pair(InL ai (sd yprod ai))crht su))

;; (cp (theorem-name-to-proof "CoIClosureInvSound"))

(deanimate "CoIClosureInv")

;; Another specific property of I
;; ==============================

;; For use in the Haskell translation we prove a further specific
;; property of CoI.  We prove RealToCoI, based on archive/koepp/CsToStr.scm
;; in an optimized form (avoiding real multiplication)

;; TwoTimesPlusIntReal
(set-goal "all as,M,i(Real(RealConstr as M) ->
	    Real(RealConstr([n]2*(as n)+i)([p](M(PosS p)))))")
(assume "as" "M" "i" "Rx")
(inst-with-to "RealConstrToCauchy" (pt "as") (pt "M") "Rx" "CauchyInst")
(inst-with-to "RealConstrToMon" (pt "as") (pt "M") "Rx" "MonInst")
(intro 0)
(intro 0)
(assume "p" "n" "m" "Bd1" "Bd2")
(ng) 
(simprat (pf "2*as n +i + ~(2*as m)+ ~i==2*(as n + ~(as m))"))
(simp "RatAbsTimes")
(ng #t)
(simp "RatTimesComm")
(simprat (pf "(1#2**p)==(1#2**PosS p)*2"))
(use "RatLeMonTimes")
(ng #t)
(use "Truth")
(use "CauchyElim" (pt "M"))
(use "CauchyInst")
(use "Bd1")
(use "Bd2")
(simprat "<-" "RatPlusHalfExpPosS")
(simprat (pf "(1#2**PosS p)+(1#2**PosS p)==(1#2**PosS p)*1+(1#2**PosS p)*1"))
(simprat "<-" "RatTimesPlusDistr")
(ng #t)
(use "Truth")
(ng #t)
(use "Truth")
(simp "<-" "RatPlusAssoc")
(simp-with "RatPlusComm" (pt "~(2*as m)") (pt "~i#1"))
(simp "<-" "RatPlusAssoc")
(ng #t)
(simp (pf "~(2* as m)=2* ~(as m)"))
(simprat "RatTimesPlusDistr")
(ng #t)
(use "Truth")
(ng #t)
(use "Truth")
(ng #t)
(intro 0)
(assume "p" "q" "p<=q")
(ng #t)
(use "MonElim" (pt "as"))
(use "MonInst")
(ng #t)
(use "p<=q")
;; Proof finished.
;; (cp)
(save "TwoTimesPlusIntReal")

;; TwoTimesPlusEq
(set-goal "all as,M,i(Real(RealConstr as M) -> 
  RealConstr([n]2*(as n)+i)([p](M(PosS p)))===2*(RealConstr as M) +i)")
(assume "as" "M" "i" "Rx")
(use "RealEqSToEq")
(use "TwoTimesPlusIntReal")
(use "Rx")
(autoreal)
(use "RealEqSIntro")
(assume "n")
(use "Truth")
;; Proof finished.
;; (cp)
(save "TwoTimesPlusEq")

;; ApproxSplitZeroPtFive
(set-goal "all x(Real x ->  x<<=(1#2) ori 0<<=x)")
(assume "x" "Rx")
(use "ApproxSplit" (pt "1"))
(autoreal)
(ng #t)
(use "Truth")
;; Proof finished.
;; (cp)
(save "ApproxSplitZeroPtFive")

;; (animate "ApproxSplit")
;; (animate "ApproxSplitPos")
;; (define eterm (proof-to-extracted-term))
;; (define neterm (rename-variables (nt eterm)))
;; ;; (pp neterm)
;; ;; [x]cApproxSplit 0(1#2)x 1
;; (pp (nt (pt "cApproxSplitPos 0(1#2)x 1")))
;; [if x ([as0,M1]as0(M1 3)<=(1#4))]

;; (add-sound "ApproxSplitZeroPtFive")

;; (pp "ApproxSplitZeroPtFiveSound")

;; allnc x(
;;  Real x -> 
;;  (OrUMR (cterm () x<<=(1#2)) (cterm () 0<<=x))(cApproxSplit 0(1#2)x 1))

;; (pp "cApproxSplitZeroPtFive0CompRule")

;; cApproxSplitZeroPtFive eqd([x]cApproxSplit 0(1#2)x 1)

;; (cp (theorem-name-to-proof "ApproxSplitZeroPtFiveSound"))

;; (deanimate "ApproxSplitZeroPtFive")
;; ;; Leave it animated since the rhs is simple

;; ApproxSplitZeroMinusPtFive
(set-goal "all x(Real x ->  x<<=0 oru (IntN 1#2)<<=x)")
(assume "x" "Rx")
(use "ApproxSplit" (pt "1"))
(autoreal)
(ng #t)
(use "Truth")
;; Proof finished.
;; (cp)
(save "ApproxSplitZeroMinusPtFive")

(define eterm (proof-to-extracted-term))
(animate "ApproxSplit")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)
;; [x]cApproxSplitPos(IntN 1#2)0 x 1
;; Was
;; [x][case x (RealConstr as M -> as(M 3)<=(IntN 1#4))]
(deanimate "ApproxSplit")

;; (add-sound "ApproxSplitZeroMinusPtFive")

;; (pp "ApproxSplitZeroMinusPtFiveSound")

;; allnc x(
;;  Real x -> 
;;  (OrUMR (cterm () x<<=0) (cterm () (IntN 1#2)<<=x))
;;  (cApproxSplit(IntN 1#2)0 x 1))

;; (pp "cApproxSplitZeroMinusPtFive0CompRule")

;; cApproxSplitZeroMinusPtFive eqd([x]cApproxSplit(IntN 1#2)0 x 1)

;; (cp (theorem-name-to-proof "ApproxSplitZeroMinusPtFiveSound"))

(deanimate "ApproxSplitZeroMinusPtFive")

;; RealToCoIAux
(set-goal "all x(Real x -> abs x<<=1 ->
 exd s exl y(Real y andnc abs y<<=1 andnc x===(1#2)*(y+(SdToInt s))))")
(assume "x")
(cases (pt "x"))
(assume "as" "M" "xDef" "Rx" "abs x<=1")
(assert "x<<=0 oru ~(1#2)<<=x")
  (use "ApproxSplitZeroMinusPtFive")
  (simp "xDef")
  (autoreal)
(assume "Disj")
(elim "Disj")
;; 10,11
(assume "x<=0")
(intro 0 (pt "SdL"))
(intro 0 (pt "RealConstr([n](2*as n+1))([p](M(PosS p)))"))
(split)
;; 15,16
(use "TwoTimesPlusIntReal")
(use "Rx")
(split)
;; 18,19
;; ?^18:abs(RealConstr([n]2*as n+1)([p]M(PosS p)))<<=1
(use "RealLeAbs")
;; 20,21
(simpreal "TwoTimesPlusEq")
(use "RealLeTrans"
     (pt "2*(RealConstr([n]0)([p]Zero))+(RealConstr([n]1)([p]Zero))"))
;; 24,25
(use "RealLeMonPlusTwo")
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
(simp "<-" "xDef")
(use "x<=0")
(use "RatLeToRealLe")
(use "Truth")
(use "RatLeToRealLe")
(use "Truth")
(use "Rx")
;; 21
(simpreal "TwoTimesPlusEq")
;; 34,35
(simpreal "RealUMinusPlus")
(use "RealLeTrans"
     (pt "(RealConstr([n]2)([p]Zero))+ ~(RealConstr([n]1)([p]Zero))"))
;; 39,40
(use "RealLeMonPlus")
(use "RealRat")
(simpreal "RealTimesComm")
(simpreal "<-" "RealTimesUMinusId")
(simpreal-with "<-" "RealOneTimes" (pt "RealConstr([n]2)([p]Zero)") "?")
(simpreal "RealTimesAssoc")
(use "RealLeMonTimes")
(use "RatLeToRealLe")
(use "Truth")
(simpreal "RealTimesOne")
(use "RealLeTrans" (pt "abs x"))
(simpreal "<-" "RealAbsUMinus")
(simp "<-" "xDef")
(use "RealLeIdAbs")
(realproof)
(simp "xDef")
(use "Rx")
(simp "xDef")
(use "abs x<=1")
(autoreal)
;; 40
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; ?^19:
;; RealConstr as M===(1#2)*(RealConstr([n]2*as n+1)([p]M(PosS p))+SdToInt SdL)
(simpreal "TwoTimesPlusEq")
;; 69,70
(simp "<-" "xDef")
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
(assume "(~1#2)<<=x")
(assert "x<<=(1#2) oru 0<<=x")
 (use "ApproxSplitZeroPtFive")
 (simp "xDef")
 (autoreal)
(assume "Disj2")
(elim "Disj2")
;; 94,95
(assume "x<<=0.5")
(intro 0 (pt "SdM"))
(intro 0 (pt "RealConstr([n]2*as n+0)([p]M(PosS p))"))
(split)
(use "TwoTimesPlusIntReal")
(realproof)
(split)
;; 102,103
;; ?^102:abs(RealConstr([n]2*as n+0)([p]M(PosS p)))<<=1
(simpreal "TwoTimesPlusEq")
(simpreal "RealPlusZero")
(simpreal "RealAbsTimes")
(simp "<-" "xDef")
(ng #t)
(simpreal (pf "RealConstr([n]1)([p]Zero)===2*RealConstr([n](1#2))([p]Zero)"))
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeAbs")
(use "x<<=0.5")
(simpreal
 (pf "RealConstr([n](1#2))([p]Zero)=== ~ ~(RealConstr([n](1#2))([p]Zero))"))
(use "RealLeUMinus")
(use "(~1#2)<<=x")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "RatEqvToRealEq")
(use "Truth")
(autoreal)
;; ?^103:RealConstr as M===
;; (1#2)*(RealConstr([n]2*as n+0)([p]M(PosS p))+SdToInt SdM)
(simpreal "TwoTimesPlusEq")
;; 126,127
(simp "<-" "xDef")
(ng #t)
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; 95
(assume "0<=x")
(intro 0 (pt "SdR"))
(intro 0 (pt "RealConstr([n](2*as n)+ ~1)([p]M(PosS p))"))
(split)
;; 145,146
(use "TwoTimesPlusIntReal")
(realproof)
;; 146
(split)
;; 148,149
;; ?^148:abs(RealConstr([n]2*as n+ ~1)([p]M(PosS p)))<<=1
(simpreal "TwoTimesPlusEq")
(use "RealLeAbs")
;; 152,153
(simpreal (pf "RealConstr([n]1)([p]Zero)===
               (RealConstr([n]2)([p]Zero))*1+ ~(RealConstr([n]1)([p]Zero))"))
(use "RealLeMonPlusTwo")
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeTrans" (pt "abs x"))
(simp "xDef")
(use "RealLeIdAbs")
(use "Rx")
(simp "xDef")
(use "abs x<=1")
(use "RatLeToRealLe")
(use "Truth")
(use "RatEqvToRealEq")
(use "Truth")
;; 153
(simp "<-" "xDef")
(simpreal "RealUMinusPlus")
(ng #t)
(simpreal (pf "RealConstr([n]1)([p]Zero)===
               (RealConstr([n]0)([p]Zero))*2+ (RealConstr([n]1)([p]Zero))"))
(use "RealLeMonPlusTwo")
(simpreal "RealTimesComm")
(simpreal "<-" "RealTimesUMinusId")
(use "RealLeMonTimes")
(use "RatLeToRealLe")
(use "Truth")
(simpreal (pf "RealConstr([n]0)([p]Zero)=== ~ ~(RealConstr([n]0)([p]Zero))"))
(use "RealLeUMinus")
(ng #t)
(use "0<=x")
(use "RatEqvToRealEq")
(use "Truth")
(autoreal)
(use "RatLeToRealLe")
(use "Truth")
(use "RatEqvToRealEq")
(use "Truth")
(autoreal)
;; ?^149:RealConstr as M===
;;       (1#2)*(RealConstr([n]2*as n+ ~1)([p]M(PosS p))+SdToInt SdR)
(simpreal "TwoTimesPlusEq")
(simp "<-" "xDef")
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simp "xDef")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "RealToCoIAux")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; [x]
;;  [if x
;;    ([as,M]
;;     [if (cApproxSplitZeroMinusPtFive x)
;;       (SdL pair RealConstr([n]2*as n+1)([p]M(PosS p)))
;;       [if (cApproxSplitZeroPtFive x)
;;        (SdM pair RealConstr([n]2*as n)([p]M(PosS p)))
;;        (SdR pair RealConstr([n]2*as n+IntN 1)([p]M(PosS p)))]])]

;; (add-sound "RealToCoIAux")

;; (pp (nf (theorem-name-to-formula "RealToCoIAuxSound")))

;; all x(
;;  Real x -> 
;;  abs x<<=1 -> 
;;  (ExDTMR (cterm (s,x^0) 
;;            (ExLTMR (cterm (y) 
;;                      Real y andnc abs y<<=1 andnc x===(1#2)*(y+SdToInt s)))
;;            x^0))
;;  [if x
;;    ([as0,M1]
;;     [if (cApproxSplitZeroMinusPtFive x)
;;       (SdL pair RealConstr([n2]2*as0 n2+1)([p2]M1(PosS p2)))
;;       [if (cApproxSplitZeroPtFive x)
;;        (SdM pair RealConstr([n2]2*as0 n2)([p2]M1(PosS p2)))
;;        (SdR pair RealConstr([n2]2*as0 n2+IntN 1)([p2]M1(PosS p2)))]])])

;; (pp "cRealToCoIAux0CompRule")

;; cRealToCoIAux eqd
;; ([x]
;;   [if x
;;     ([as,M]
;;      [if (cApproxSplitZeroMinusPtFive x)
;;        (SdL pair RealConstr([n]2*as n+1)([p]M(PosS p)))
;;        [if (cApproxSplitZeroPtFive x)
;;         (SdM pair RealConstr([n]2*as n)([p]M(PosS p)))
;;         (SdR pair RealConstr([n]2*as n+IntN 1)([p]M(PosS p)))]])])

;; (cp (theorem-name-to-proof "RealToCoIAuxSound"))

(deanimate "RealToCoIAux")

;; SdInjSdToInt
(set-goal "all s(SdInj(SdToInt s)s)")
(ind)
(ng #t)
(use "InitSdSdRInj")
(ng #t)
(use "InitSdSdMInj")
(ng #t)
(use "InitSdSdLInj")
;; Proof finished.
;; (cp)
(save "SdInjSdToInt")

;; RealToCoI
(set-goal "all x(Real x -> abs x<<=1 -> CoI x)")
(assume "x" "Rx" "xBd")
(assert "exd sd exl y(Real y andnc abs y<<=1 andnc x===(1#2)*(y+SdToInt sd))")
 (use "RealToCoIAux" (pt "x"))
 (use "Rx")
 (use "xBd")
(assume "Hyp")
(coind "Hyp")
;; (pp (formula-to-et-type (proof-to-formula (current-goal))))
;; sd yprod rea=>sd yprod(ai ysum sd yprod rea)
(assume "y" "ExHyp")
(by-assume "ExHyp" "s" "sProp")
(by-assume "sProp" "y0" "sy0Prop")
(assert "exd sd exl y(Real y andnc abs y<<=1 andnc y0===(1#2)*(y+SdToInt sd))")
 (use "RealToCoIAux")
 (use "sy0Prop")
 (use "sy0Prop")
(assume "y0ExHyp")
(by-assume "y0ExHyp" "s1" "s1Prop")
(by-assume "s1Prop" "y1" "s1y1Prop")
(intro 0 (pt "SdToInt s"))
(intro 0 (pt "y0"))
(intro 0 (pt "y"))
(split)
(use "SdInjElim" (pt "s"))
(use "SdInjSdToInt")
(split)
(use "sy0Prop")
(split)
(use "sy0Prop")
(split)
(intro 1)
(intro 0 (pt "s1"))
(intro 0 (pt "y1"))
(split)
(use "s1y1Prop")
(split)
(use "s1y1Prop")
(use "s1y1Prop")
(split)
(use "sy0Prop")
(simpreal "sy0Prop")
(use "RealEqRefl")
(assert "Real y0")
 (use "sy0Prop")
(assume "Ry0")
(realproof)
;; Proof finished.
;; (cp)
(save "RealToCoI")

(define RealToCoI-eterm (proof-to-extracted-term))
(add-var-name "sx" (py "sd yprod rea"))
(define RealToCoI-neterm (rename-variables (nt RealToCoI-eterm)))
;; (ppc RealToCoI-neterm)

;; [x]
;;  (CoRec sd yprod rea=>ai)(cRealToCoIAux x)
;;  ([sx]
;;    [case sx
;;      (s pair x0 -> 
;;      [case (cRealToCoIAux x0)
;;        (s0 pair x1 -> cSdInjElim s pair InR(s0 pair x1))])])

;; (add-sound "RealToCoI")

;; (pp (nf (theorem-name-to-formula "RealToCoISound")))

;; all x(
;;  Real x -> 
;;  abs x<<=1 -> 
;;  CoIMR x
;;  ((CoRec sd yprod rea=>ai)(cRealToCoIAux x)
;;   ([sx0]
;;     [if sx0
;;       ([s1,x2]
;;        [if (cRealToCoIAux x2)
;;          ([s3,x4]s1 pair(InR (sd yprod rea) ai)(s3 pair x4))])])))

;; (pp "cRealToCoI0CompRule")

;; cRealToCoI eqd
;; ([x]
;;   (CoRec sd yprod rea=>ai)(cRealToCoIAux x)
;;   ([sx]
;;     [if sx
;;       ([s,x0]
;;        [if (cRealToCoIAux x0)
;;          ([s0,x1]cSdInjElim s pair(InR (sd yprod rea) ai)(s0 pair x1))])]))

;; (cp (theorem-name-to-proof "RealToCoISound"))

(deanimate "RealToCoI")

;; RatToReal
(set-goal "all a(abs a<=1 -> exl x(Real x andi abs x<<=1 andi x===a))")
(assume "a" "aBd")
(intro 0 (pt "RealConstr([n]a)([p]Zero)"))
(split)
(use "RealRat")
(split)
(use "RatLeToRealLe")
(use "aBd")
(use "RealEqRefl")
(use "RealRat")
;; Proof finished.
;; (cp)
(save "RatToReal")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; [a]a
;; ppn means pretty print with names.
;; (ppn neterm)
;; (lambda a ((lambda n a) RealConstr (lambda p Zero)))

;; (add-sound "RatToReal")

;; (pp "RatToRealSound")

;; allnc a(abs a<=1 ->
;; 	    (ExLTMR (cterm (x) Real x andnc abs x<<=1 andnc x===a))a)

;; (pp "cRatToReal0CompRule")
;; cRatToReal eqd([a]a)

;; (cp (theorem-name-to-proof "RatToRealSound"))

;; (deanimate "RatToReal")
;; Leave it animated because it gives an identity.

;; RatToCoI
(set-goal "all a(abs a<=1 -> CoI a)")
(assume "a" "aBd")
(use "RealToCoI")
(use "RealRat")
(use "RatLeToRealLe")
(use "aBd")
;; Proof finished.
;; (cp)
(save "RatToCoI")

(define RatToCoI-eterm (proof-to-extracted-term))
(define RatToCoI-neterm (rename-variables (nt RatToCoI-eterm)))
;; (pp RatToCoI-neterm)
;; [a]cRealToCoI a

;; (add-sound "RatToCoI")

;; (pp "RatToCoISound")
;; allnc a(abs a<=1 -> CoIMR a(cRealToCoI a))

;; (pp "cRatToCoI0CompRule")
;; cRatToCoI eqd([a]cRealToCoI a)

;; (cp "RatToCoISound")

;; (deanimate "RatToCoI")

;; (display-animation)
;; '()

;; Haskell translation
;; ===================

;; terms-to-haskell-program (written by Fredrik Nordvall-Forsberg)
;; generates a Haskell file (here sdtest.hs).  To run it, in a
;; terminal type ghci sdtest.hs.  Then in *Main> one can evaluate
;; the Haskell functions in sdtest.hs.  To quit type *Main> :q.

;; To prepare for the Haskell translation we define program constants,
;; which will be translated into Haskell programs.

(add-program-constant "SdMs" (py "ai"))
(add-computation-rules "SdMs" "C SdM SdMs")

(add-program-constant "PtFive" (py "ai"))
(add-computation-rules "PtFive" "C SdR SdMs")

(add-program-constant "MPtFive" (py "ai"))
(add-computation-rules "MPtFive" "C SdL SdMs")

;; OneSdR n defines 1#2**Succ n

(add-program-constant "OneSdR" (py "nat=>ai"))
(add-computation-rules
 "OneSdR Zero" "C SdR SdMs"
 "OneSdR(Succ n)" "C SdM(OneSdR n)")

;; OneSdL n defines IntN 1#2**(Succ n)

(add-program-constant "OneSdL" (py "nat=>ai"))
(add-computation-rules
 "OneSdL Zero" "C SdL SdMs"
 "OneSdL(Succ n)" "C SdM(OneSdL n)")

(add-program-constant "HeronAux" (py "rat=>rat"))
(add-computation-rules "HeronAux a" "a+(2/a)")

(add-program-constant "Heron" (py "nat=>rat"))
(add-computation-rules
 "Heron Zero" "1#1"
 "Heron(Succ n)" "(1#2)*HeronAux(Heron n)")

(add-program-constant "SqrtTwoOverTwo" (py "rea"))
(add-computation-rules
 "SqrtTwoOverTwo" "RealConstr([n](Heron n/2))([p]PosS p)")

(add-program-constant "AiAppd" (py "list sd=>ai=>ai"))
(add-computation-rules
 "AiAppd(Nil sd)u" "u"
 "AiAppd(s::(list sd))u" "C s(AiAppd(list sd)u)")

(add-program-constant "Zeros" (py "nat=>list sd"))
(add-computation-rules
 "Zeros Zero" "(Nil sd)"
 "Zeros(Succ n)" "SdM::Zeros n")

;; (pp (nt (pt "Zeros 3")))
;; SdM::SdM::SdM:

(add-program-constant "OneZeros" (py "nat=>list sd"))
(add-computation-rules
 "OneZeros n" "SdR::Zeros(Succ n)")

;; (pp (nt (pt "OneZeros 3")))
;; SdR::SdM::SdM::SdM::SdM:

(add-program-constant "IrrStr" (py "(nat=>nat)=>nat=>ai"))
(add-computation-rules
 "IrrStr(nat=>nat)n" "AiAppd(OneZeros n)(IrrStr(nat=>nat)(Succ n))")

(add-program-constant "AiProj" (py "nat=>ai=>sd"))
(add-computation-rules
 "AiProj Zero(C s ai)" "s"
 "AiProj(Succ n)(C s ai)" "AiProj n ai")

(add-program-constant "AiToCs" (py "ai=>nat=>rat"))
(add-computation-rules
 "AiToCs ai Zero" "0#1"
 "AiToCs ai(Succ n)" "(AiToCs ai n)+(1#2**n*2)*SdToInt(AiProj n ai)")

(add-program-constant "AiToReal" (py "ai=>rea"))
(add-computation-rules
 "AiToReal ai" "RealConstr(AiToCs ai)([p]p)")

(add-program-constant "AiHead" (py "ai=>sd"))
(add-computation-rules "AiHead(C s u)" "s")

(add-program-constant "AiTail" (py "ai=>ai"))
(add-computation-rules "AiTail(C s u)" "u")

(add-program-constant "TakeStr" (py "nat=>ai=>list sd"))
(add-computation-rules
 "TakeStr Zero u" "(Nil sd)"
 "TakeStr(Succ n) u" "AiHead u :: (TakeStr n(AiTail u))")

(add-program-constant "ListSdToRat" (py "list sd=>rat"))
(add-computation-rules
 "ListSdToRat(Nil sd)" "0#1"
 "ListSdToRat(s::list sd)" "(1#2)*(ListSdToRat(list sd)+SdToInt s)")

;; We aim at translating the term extracted from a proof of the
;; computational theorem RatToCoI into a haskell program.

;; terms-to-haskell-program requires that all auxiliary program
;; constants cThm in the dependence tree of RatToCoI have computation
;; rules.  This means that all c.r. theorems must be animated.
;; We do this in an order determined by the dependence tree: if cThm1
;; depends on cThm2, then cThm2 must be animated before cThm1.

;; (dep-tree "RatToCoI")

;; ("RatToCoI"
;;   ("RealToCoI"
;;     ("SdInjElim")
;;     ("RealToCoIAux"
;;       ("ApproxSplitZeroPtFive" ("ApproxSplit" ("ApproxSplitPos")))
;;       ("ApproxSplitZeroMinusPtFive"
;;         ("ApproxSplit" ("ApproxSplitPos"))))))

;; This dependence tree for RatToCoI contains the information which
;; computational theorems the proof of RatToCoI hereditarily refers to,
;; and in which order they should be animated..

;; (animate "SdInjElim") ;already animated
(animate "ApproxSplitPos")
(animate "ApproxSplit")
(animate "ApproxSplitZeroPtFive")
(animate "ApproxSplitZeroMinusPtFive")
(animate "RealToCoIAux")
(animate "RealToCoI")
(animate "RatToCoI")

;; (display-animation)

'("cRatToCoI" "cRealToCoI" "cRealToCoIAux" "cApproxSplitZeroMinusPtFive"
  "cApproxSplitZeroPtFive" "cApproxSplit" "cApproxSplitPos"
  "cSdInjElim")

'(terms-to-haskell-program
 "~/temp/sdtest.hs"
 (list (list RatToCoI-eterm "rattocoi")
       (list (pt "SdMs") "sdms")
       (list (pt "PtFive") "ptfive")
       (list (pt "MPtFive") "mptfive")
       (list (pt "OneSdR") "onesdr")
       (list (pt "OneSdL") "onesdl")
       (list (pt "SqrtTwoOverTwo") "stot")
       (list (pt "IrrStr") "irrstr")
       (list (pt "AiToReal") "aitoreal")
       (list (pt "TakeStr") "takestr")
       (list (pt "ListSdToRat") "listsdtorat")))

;; ok, output written to file ~/temp/sdtest.hs

;; (deanimate "SdInjElim") ;left animated because its eterm is the identity
(deanimate "ApproxSplitPos")
(deanimate "ApproxSplit")
(deanimate "ApproxSplitZeroPtFive")
(deanimate "ApproxSplitZeroMinusPtFive")
(deanimate "RealToCoIAux")
(deanimate "RealToCoI")
(deanimate "RatToCoI")

;; ghci sdtest.hs

;; takestr 18 (rattocoi (4 % 7)) 
;; [SdR,SdM,SdR,SdL,SdM,SdR,SdL,SdM,SdR,SdL,SdM,SdR,SdL,SdM,SdR,SdL,SdM,SdR]

;; (exact->inexact 149797/262144)
;; 0.5714302062988281

;; (/ 4 7.0)
;; 0.5714285714285714

;; takestr 18 (onesdr 16)
;; [SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdM,SdR,SdM]

;; takestr 10 (realtocoi stot)
;; [SdR,SdR,SdM,SdL,SdR,SdL,SdR,SdL,SdM,SdM]

;; listsdtorat (takestr 10 (realtocoi stot))
;; 181 % 256

;; (exact->inexact 181/256)
;; 0.70703125

;; (* (sqrt 2) 0.5)
;; 0.7071067811865476

;; takestr 40 (irrstr (\ n -> (n + 1)) 0)

;; SdR,SdM,
;; SdR,SdM,SdM,
;; SdR,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM...

;; takestr 40 (irrstr (\ n -> (n + 1)) 1)

;; SdR,SdM,SdM,
;; SdR,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,SdM,SdM,
;; SdR,SdM,SdM,SdM,SdM,SdM,SdM...

