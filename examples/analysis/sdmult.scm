;; 2025-10-22.  examples/analysis/sdmult.scm

#|
(load "~/git/minlog/init.scm")
(set! COMMENT-FLAG #f)
(libload "nat.scm")
(libload "list.scm")
(libload "pos.scm")
(libload "int.scm")
(libload "rat.scm")
(libload "rea.scm")
(load "~/git/minlog/examples/analysis/digits.scm")
(load "~/git/minlog/examples/analysis/sdcode.scm")
(load "~/git/minlog/examples/analysis/JK.scm")
(load "~/git/minlog/examples/analysis/sdavaux.scm")
;; (set! COMMENT-FLAG #t)
|#

(display "loading sdmult.scm ...") (newline)

;; Multiplication
;; ==============

(add-pvar-name "P" (make-arity (py "rea")))

(add-ids
 (list (list "J" (make-arity (py "rea")) "algJ"))
 '("allnc x(P x  -> J x)" "Init")
 '("allnc d,x,y(Sd d -> J x -> y===(1#2)*(x+d) -> J y)" "Write")
 '("allnc i,x,y,z(Sdtwo i -> J x ->  CoI y -> z===(1#4)*(x+y+i) -> J z)" "Avc"))

;; (display-alg "algJ")
;; algJ
;; 	CInit:	alpha1=>algJ alpha1
;; 	CWrite:	sd=>algJ alpha1=>algJ alpha1
;; 	CAvc:	sdtwo=>algJ alpha1=>ai=>algJ alpha1

;; Square Px := exr d,y(Sd d andi CoI y andl x===(1#2)*(y*y+d))
;; Multip Px := exr d,y,z(Sd d andi CoI y andi CoI z andi x===(1#2)*(y*z+d)

;; JToReal
(set-goal "all x(P x -> Real x) -> all x((J (cterm(x^)P x^))x -> Real x)")
(assume "PReal" "x" "Jx")
(elim "Jx")
(use "PReal")
(strip)
(autoreal)
(strip)
(autoreal)
;; Proof finished.
;; (cp)
(save "JToReal")

;; JToBound
(set-goal "all x(P x -> Real x) ->
 all x(P x -> abs x<<=1) ->all x((J (cterm(x^)P x^))x -> abs(x)<<=1)")
(assume "PReal" "PBound" "x" "Jx")
(elim "Jx")
(use "PBound")
(assume "d" "x0" "y" "Sdd" "Jx0" "x0Bd" "yDef")
(simpreal "yDef")
(use "RealClBound")
(use "JToReal")
(use "PReal")
(use "Jx0")
(use "Sdd")
(use "x0Bd")
(assume "i" "x0" "y" "z" "Sdtwoi" "Jx0" "x0Bd" "CoIy" "zDef")
(simpreal "zDef")
(use "RealCarryBound")
(use "JToReal")
(use "PReal")
(use "Jx0")
(use-with "CoIToReal" (pt "y") "CoIy")
(use "x0Bd")
(use-with "CoIToBd" (pt "y") "CoIy")
(use "Sdtwoi")
;; Proof finished.
;; (cp)
(save "JToBd")

;; JToCoI
(set-goal "all x(P x -> Real x) -> all x(P x -> abs x<<=1) -> allnc x(P x ->
 exr d,y(Sd d andi (J (cterm(x^)P x^))y andi x===(1#2)*(y+d))) ->
 allnc x((J (cterm(x^)P x^))x -> CoI x)")
(assume "PReal" "PBound" "PClosure")
(use "CoIGfpIter")
(assume "x0" "Jx0")
(elim "Jx0")
(assume "x" "Px")
(inst-with-to "PClosure" (pt "x") "Px" "xInst")
(by-assume "xInst" "d" "dProp")
(by-assume "dProp" "y" "dyProp")
(intro 0 (pt "d"))
(intro 0 (pt "y"))
(split)
(use "dyProp")
(split)
(use "JToReal")
(use "PReal")
(use "dyProp")
(split)
(use "JToBd")
(use "PReal")
(use "PBound")
(use "dyProp")
(split)
(use "dyProp")
(use "dyProp")
(assume "d" "x" "y" "Sdd" "Jx" "ExHyp" "yDef")
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(split)
(use "Sdd")
(split)
(use "JToReal")
(use "PReal")
(use "Jx")
(split)
(use "JToBd")
(use "PReal")
(use "PBound")
(use "Jx")
(split)
(use "Jx")
(use "yDef")
(assume "i" "x" "y" "z" "Sdtwoi" "Jx" "ExHyp" "CoIy" "zDef")
(by-assume "ExHyp" "d1" "d1Prop")
(by-assume "d1Prop" "x1" "d1x1Prop")
(inst-with-to "CoIClosure" (pt "y") "CoIy" "yInst")
(by-assume "yInst" "e1" "e1Prop")
(by-assume "e1Prop" "y1" "e1y1Prop")
(assert "CoI y1")
(use "e1y1Prop")
(assume "CoIy1")
;; (pp "RealCarryAvCl")
(assert "Sd d1")
(use "d1x1Prop")
(assume "Sdd1")
(assert "Sd e1")
(use "e1y1Prop")
(assume "Sde1")
(assert "Real x1")
(use "JToReal")
(use "PReal")
(use "d1x1Prop")
(assume "Rx1")
(assert "Real y1")
(use-with "CoIToReal" (pt "y1") "CoIy1")
(assume "Ry1")
(inst-with-to
 "RealCarryAvCl" (pt "i") (pt "x1") (pt "y1") (pt "d1") (pt "e1")
 "Sdtwoi" "Sdd1" "Sde1" "Rx1" "Ry1" "AvClInst")
(by-assume "AvClInst" "j" "jProp")
(by-assume "jProp" "k" "jkProp")
(intro 0 (pt "k"))
(intro 0 (pt "(1#4)*(x1+y1+j)"))
(split)
(use "jkProp")
(split)
(autoreal)
(split)
(use "RealCarryBound")
(autoreal)
(use "JToBd")
(use "PReal")
(use "PBound")
(use "d1x1Prop")
(use-with "CoIToBd" (pt "y1") "CoIy1")
(use "jkProp")
(split)
(intro 2 (pt "j") (pt "x1") (pt "y1"))
(use "jkProp")
(use "d1x1Prop")
(use "CoIy1")
(use "RealEqRefl")
(autoreal)
(simpreal "zDef")
(simpreal "d1x1Prop")
(simpreal "e1y1Prop")
(use "jkProp")
;; Proof finished.
;; (cp)
(save "JToCoI")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))

;; [(alpha6776=>sd yprod algJ alpha6776)_0]
;;  (cCoIGfpIter algJ alpha6776)
;;  ([(algJ alpha6776)_2]
;;    (Rec algJ alpha6776=>sd yprod algJ alpha6776)(algJ alpha6776)_2
;;    (alpha6776=>sd yprod algJ alpha6776)_0
;;    ([s3,(algJ alpha6776)_4,(sd yprod algJ alpha6776)_5]
;;      s3 pair(algJ alpha6776)_4)
;;    ([t3,(algJ alpha6776)_4,(sd yprod algJ alpha6776)_5,u6]
;;      crht(cRealCarryAvClAux clft(sd yprod algJ alpha6776)_5 
;;           clft(cCoIClosure u6)
;;           t3)pair
;;      (CAvc alpha6776)
;;      clft(cRealCarryAvClAux clft(sd yprod algJ alpha6776)_5 
;;           clft(cCoIClosure u6)
;;           t3)
;;      crht(sd yprod algJ alpha6776)_5 
;;      crht(cCoIClosure u6)))

(add-mr-ids "J")
(add-co "JMR")

(animate "RealCarryAvCl")
(animate "PsdToTwoTimesSdtwo")

(add-sound "JToCoI")
(deanimate "JToCoI")

;; RealBinom
(set-goal "allnc x,y(Real x -> Real y -> (x+y)*(x+y)===x*x+2*x*y+y*y)")
(assume "x" "y" "Rx" "Ry")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusAssoc")
(use "RealPlusCompat")
(simpreal (pf "2===RealPlus 1 1"))
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealOneTimes")
(simpreal "RealTimesPlusDistrLeft")
(use "RealPlusCompat")
(use "RealTimesComm")
(autoreal)
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "RealBinom")

;; CoIClosureSquare
(set-goal "allnc x(CoI x ->
                 exr y(CoI y andi
                       (exr d(Sd d andi x===(1#2)*((1#2)*(y+d)+0)) ori
                        exr d(Psd d andi x===(1#2)*((1#2)*(y+0)+d)) ori
                        exr d(Psd d andi x===(1#2)*((1#2)*(y+d)+d)))))")
(assume "x" "CoIx")
(inst-with-to "CoIClosure" (pt "x") "CoIx" "xInst")
(by-assume "xInst" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(assert "CoI x1")
(use "dx1Prop")
(assume "CoIx1")
(assert "Sd d")
(use "dx1Prop")
(assume "Sdd")
(inst-with-to "CoIClosure" (pt "x1") "CoIx1" "x1Inst")
(by-assume "x1Inst" "e" "eProp")
(by-assume "eProp" "x2" "ex2Prop")
(assert "CoI x2")
(use "ex2Prop")
(assume "CoIx2")
(intro 0 (pt "x2"))
(split)
(use "CoIx2")
(inst-with-to "SdToZeroOrPsd" (pt "d") "Sdd" "dDisj")
(elim "dDisj")
(drop "dDisj")
(assume "d=0")
(intro 0)
(intro 0 (pt "e"))
(split)
(use "ex2Prop")
(simpreal "dx1Prop")
(simpreal "ex2Prop")
(simp "d=0")
(use "RealEqRefl")
(autoreal)
(drop "dDisj")
(assume "Psdd")
(assert "Sd e")
(use "ex2Prop")
(assume "Sde")
(inst-with-to "SdToZeroOrPsd" (pt "e") "Sde" "eDisj")
(elim "eDisj")
(drop "eDisj")
(assume "e=0")
(intro 1)
(intro 0)
(intro 0 (pt "d"))
(split)
(use "Psdd")
(simpreal "dx1Prop")
(simpreal "ex2Prop")
(simp "e=0")
(use "RealEqRefl")
(autoreal)
(drop "eDisj")
(assume "Psde")
(inst-with-to "PsdPsdTpEqDisj"  (pt "e") (pt "d") "Psde" "Psdd" "Disj")
(elim "Disj")
(drop "Disj")
(assume "e=d")
(intro 1)
(intro 1)
(intro 0 (pt "d"))
(split)
(use "Psdd")
(simpreal "dx1Prop")
(simpreal "ex2Prop")
(simp "e=d")
(use "RealEqRefl")
(autoreal)
(drop "Disj")
(assume "e=-d")
(intro 0)
(intro 0 (pt "d"))
(split)
(use "PsdToSd")
(use "Psdd")
(simpreal "dx1Prop")
(simpreal "ex2Prop")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusZero")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(simp "e=-d")
(simp "<-" "IntTimesAssoc")
(simp (pf "~d*2=d*(IntN 2)"))
(simp "<-" "IntTimesPlusDistr")
(ng #t)
(use "Truth")
(simp "IntTimesIntNR")
(ng #t)
(use "Truth")
(autoreal)
;; Proof finished.
;; (cp)
(save "CoIClosureSquare")

;; (define eterm (proof-to-extracted-term))
;; (ppc (nt eterm))

;; [u0]
;;  crht(cCoIClosure crht(cCoIClosure u0))pair
;;  [case (cSdToZeroOrPsd clft(cCoIClosure u0))
;;    (DummyL -> InL clft(cCoIClosure crht(cCoIClosure u0)))
;;    (Inr b1 -> 
;;    [case (cSdToZeroOrPsd clft(cCoIClosure crht(cCoIClosure u0)))
;;      (DummyL -> InR(InL b1))
;;      (Inr b2 -> 
;;      [case (cPsdPsdTpEqDisj b2 b1)
;;        (True -> InR(InR b1))
;;        (False -> InL(cPsdToSd b1))])])]

(add-sound "CoIClosureSquare")
(deanimate "CoIClosureSquare")

;; CoIClosureSquareInv
(set-goal "allnc x,y((CoI y andi
                       (exr d(Sd d andi x===(1#2)*((1#2)*(y+d)+0)) ori
                        exr d(Psd d andi x===(1#2)*((1#2)*(y+0)+d)) ori
                        exr d(Psd d andi x===(1#2)*((1#2)*(y+d)+d)))) -> CoI x)")
(assume "x" "y" "Conj")
(elim "Conj")
(assume "CoIy" "Disj")
(elim "Disj")
(elim)
(assume "k" "kProp")
(use "GenCoI" (pt "0") (pt "(1#2)*(y+k)"))
(intro 1)
(autoreal)
(use "RealClBound")
(autoreal)
(use "kProp")
(use "CoIToBd")
(use "CoIy")
(use "CoIClosureInv")
(use "kProp")
(use "CoIy")
(use "kProp")
(elim)
(elim)
(assume "k" "kProp")
(use "GenCoI" (pt "k") (pt "(1#2)*(y+0)"))
(use "PsdToSd")
(use "kProp")
(autoreal)
(use "RealClBound")
(autoreal)
(intro 1)
(use "CoIToBd")
(use "CoIy")
(use "CoIClosureInv")
(intro 1)
(use "CoIy")
(use "kProp")
(elim)
(assume "k" "kProp")
(use "GenCoI" (pt "k") (pt "(1#2)*(y+k)"))
(use "PsdToSd")
(use "kProp")
(autoreal)
(use "RealClBound")
(autoreal)
(use "PsdToSd")
(use "kProp")
(use "CoIToBd")
(use "CoIy")
(use "CoIClosureInv")
(use "PsdToSd")
(use "kProp")
(use "CoIy")
(use "kProp")
;; Proof finished.
;; (cp)
(save "CoIClosureSquareInv")

;; (define eterm (proof-to-extracted-term))
;; (ppc (nt eterm))

;; [(ai yprod(sd ysum boole ysum boole))_0]
;;  [case (ai yprod(sd ysum boole ysum boole))_0
;;    (u1 pair(sd ysum boole ysum boole)_2 -> 
;;    [case (sd ysum boole ysum boole)_2
;;      (InL s3 -> cGenCoI SdM(cCoIClosureInv s3 u1))
;;      (InR(boole ysum boole)_3 -> 
;;      [case (boole ysum boole)_3
;;        (InL b4 -> cGenCoI(cPsdToSd b4)(cCoIClosureInv SdM u1))
;;        (InR b4 -> cGenCoI(cPsdToSd b4)(cCoIClosureInv(cPsdToSd b4)u1))])])]

(add-sound "CoIClosureSquareInv")
(deanimate "CoIClosureSquareInv")

;; SquareAux
(set-goal "allnc y,d0,d1(Real y -> 
     ((1#2)*((1#2)*(y+d1)+d0))*((1#2)*((1#2)*(y+d1)+d0)) ===
      (1#2)*((1#2)*((1#2)*((1#2)*(y*y+d1*d1)+d0*d1)+d0*d0)+
             (1#2)*((1#2)*(d1*y+d0*d1)+d0*y)))")
(assume "x1" "d0" "d1" "Rx1")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(use "RealEqTrans" (pt "(1#2)*((1#2)*(x1+d1)+d0)*((1#2)*(x1+d1)+d0)"))
(use "RealEqSym")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesComm")
(simpreal "<-" "RealTimesAssoc")
(use "RealEqRefl")
(autoreal)
(use "RealEqSym")
(simpreal "<-" "RealTimesPlusDistr")
(use "RealEqSym")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealBinom")
(simpreal "RealTimesAssoc")
(simpreal-with
 "RealTimesComm"
 (pt "(1#2)*(x1+d1)") (pt "RealConstr([n](1#2))([p]Zero)") "?" "?")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqSym")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealEqSym")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealBinom")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal-with "RealPlusComm" (pt "2*x1*d1") (pt "RealTimes d1 d1") "?" "?")
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(ng #t)
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealEqSym")
(simpreal "RealTimesPlusDistr")
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal-with
 "RealPlusComm" (pt "RealPlus(d0*d1#2)(d0*d0)") (pt "(1#2)*(d1*x1)") "?" "?")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(use "RealTimesComm")
(autoreal)
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal-with
 "RealPlusComm"
 (pt "RealPlus(d0*d1#2)(d0*d0)") (pt "RealTimes(1#2)(d0*d1)") "?" "?")
(simpreal "RealPlusAssoc")
(use "RealEqSym")
(simpreal "RealPlusComm")
(simpreal (pf "RealTimes(1#2)(d0*d1)+(d0*d1#2)===d0*d1"))
(simpreal "<-" "RealPlusAssoc")
(use "RealEqSym")
(simpreal "RealPlusComm")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal-with
 "RealTimesComm" (pt "x1+d1") (pt "RealConstr([n](d0#1))([p]Zero)") "?" "?")
(simpreal "RealTimesPlusDistr")
(ng #t)
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RatEqvToRealEq")
(ng #t)
(simp "<-" "IntTimesPlusDistrLeft")
(simp (pf "d0*d1+d0*d1=d0*d1*2"))
(simp "<-" "IntTimesAssoc")
(ng #t)
(use "Truth")
(simp (pf "d0*d1=d0*d1*1"))
(simp "<-" "IntTimesPlusDistr")
(ng #t)
(use "Truth")
(use "Truth")
(autoreal)
;; Proof finished.
;; (cp)
(save "SquareAux")

;; JSquareToReal
(set-goal "allnc x((J (cterm(x^)
 exr z,d(Sd d andi CoI z andl x^ ===(1#2)*(z*z+d))))x -> Real x)")
(use-with "JToReal"
	  (make-cterm (pv "x^0")
		      (pf "exr z,d(Sd d andd CoI z andl x^0===(1#2)*(z*z+d))"))
	  "?")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "d" "dzProp")
(use "RealEqToReal0" (pt "(1#2)*(z*z+d)"))
(use "dzProp")
;; proof finished.
;; (cp)
(save "JSquareToReal")

;; JSquareToBound
(set-goal "allnc x((J (cterm(x^)
 exr z,d(Sd d andi CoI z andl x^ ===(1#2)*(z*z+d))))x -> abs x<<=1)")
(use-with "JToBd"
	  (make-cterm (pv "x^0")
		      (pf "exr z,d(Sd d andd CoI z andl x^0===(1#2)*(z*z+d))"))
	  "?" "?")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "d" "dzProp")
(use "RealEqToReal0" (pt "(1#2)*(z*z+d)"))
(use "dzProp")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "d" "dzProp")
(assert "CoI z")
(use "dzProp")
(assume "CoIz")
(simpreal "dzProp")
(use "RealClBound")
(autoreal)
(use "dzProp")
(use "RealLeTrans" (pt "RealTimes 1 1"))
(simpreal "RealAbsTimes")
(use "RealLeMonTimesTwo")
(use "RealLeZeroAbs")
(autoreal)
(use "RealLeZeroAbs")
(autoreal)
(use "CoIToBd")
(use "CoIz")
(use "CoIToBd")
(use "CoIz")
(autoreal)
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
;; (cp)
(save "JSquareToBd")

;; CoIToJSquare
(set-goal "allnc x(CoI x ->
 (J (cterm(x^)exr z,d(Sd d andi CoI z andl x^ ===(1#2)*(z*z+d))))(x*x))")
(assume "x" "CoIx")
(cut "exr y(
        CoI y andd 
        (exr d(Sd d andl x===(1#2)*((1#2)*(y+d)+0)) ord 
         exr d(Psd d andl x===(1#2)*((1#2)*(y+0)+d)) ord 
         exr d(Psd d andl x===(1#2)*((1#2)*(y+d)+d))))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "Inst")
(by-assume "Inst" "y" "yConj")
(elim "yConj")
(drop "yConj")
(assume "CoIy" "DisjI")
(elim "DisjI")
(drop "DisjI")
;; case first digit zero
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(intro 1 (pt "0") (pt "(1#2)*((1#2)*(y+d)*((1#2)*(y+d))+0)"))
(intro 1)
(intro 0)
(intro 0 (pt "(1#2)*(y+d)"))
(intro 0 (pt "0"))
(split)
(intro 1)
(split)
(use "CoIClosureInv")
(use "dProp")
(use "CoIy")
(use "RealEqRefl")
(autoreal)
(simpreal "dProp")
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesAssoc")
(simpreal "RealTimesComm")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(use "RealTimesComm")
(autoreal)
(drop "DisjI")
(assume "DisjII")
(elim "DisjII")
(drop "DisjII")
;; case first ditit psd, second digit zero
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(assert "Real y")
(use-with "CoIToReal" (pt "y") "CoIy")
(assume "Ry")
(inst-with-to "SquareAux" (pt "y") (pt "d") (pt "0") "Ry" "SqInst")
(assert "(1#2)*((1#2)*(y+0)+d)*((1#2)*((1#2)*(y+0)+d))===
               (1#4)*((1#2)*((1#2)*(y*y+0)+0)+d*y+1)")
(simpreal "SqInst")
(simpreal "RealZeroTimes")
(ng #t)
(simp "IntSquarePsdEqOne")
(simpreal "RealZeroPlus")
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal (pf "(1#4)===RealTimes(1#2)(1#2)"))
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "<-" "RealTimesPlusDistr")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealPlusComm")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "dProp")
(autoreal)
(assume "Eq")
(intro 2 (pt "IntPos 1") (pt "(1#2)*((1#2)*(y*y+0)+0)") (pt "d*y"))
(intro 0)
(intro 1 (pt "0") (pt "(1#2)*(y*y+0)"))
(intro 1)
(intro 0)
(intro 0 (pt "y"))
(intro 0 (pt "0"))
(split)
(intro 1)
(split)
(use "CoIy")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "CoISdTimes")
(use "PsdToSd")
(use "dProp")
(use "CoIy")
(simpreal "dProp")
(use "Eq")
;; case first two digits are the same Psd
(drop "DisjII")
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(assert "Real y")
(use "CoIToReal")
(use "CoIy")
(assume "Ry")
(inst-with-to "SquareAux" (pt "y") (pt "d") (pt "d") "Ry" "SqInst")
(assert "x*x===
         (1#2)*((1#2)*((1#2)*((1#2)*(y*y+1)+1)+1)+(1#2)*((1#2)*(d*y+1)+d*y))")
(simpreal "dProp")
(simpreal "SqInst")
(simp "IntSquarePsdEqOne")
(use "RealEqRefl")
(autoreal)
(use "dProp")
(assume "xsqDef")
(cut "exr d0,x(Sd d0 andd CoI x andl (1#2)*((1#2)*(d*y+1)+d*y)===(1#2)*(x+d0))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "RhtInst")
(by-assume "RhtInst" "e0" "e0Prop")
(by-assume "e0Prop" "z0" "e0z0Prop")
(assert "CoI z0")
(use "e0z0Prop")
(assume "CoIz0")
(cut "exr i(Sdtwo i andl (1#2)*((1#2)*((1#2)*((1#2)*(y*y+1)+1)+1)+(1#2)*(z0+e0))
 ===(1#4)*((1#2)*((1#2)*(y*y+1)+1)+z0+i))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(elim)
(assume "i" "Conj")
(intro 2 (pt "i") (pt "(1#2)*((1#2)*(y*y+1)+1)") (pt "z0"))
(use "Conj")
(intro 1 (pt "IntP 1") (pt "(1#2)*(y*y+1)"))
(intro 0)
(intro 0)
(intro 0 (pt "y"))
(intro 0 (pt "IntPos 1"))
(split)
(intro 0)
(split)
(use "CoIy")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "CoIz0")
(simpreal "xsqDef")
(simpreal "e0z0Prop")
(use "Conj")
(use "RealAvClToCarryEx")
(autoreal)
(intro 0)
(use "e0z0Prop")
(use-with "CoIClosure" (pt "(1#2)*((1#2)*(d*y+1)+d*y)") "?")
(use "CoIAverage")
(use "CoIClosureInv")
(intro 0)
(use "CoISdTimes")
(use "PsdToSd")
(use "dProp")
(use "CoIy")
(use "CoISdTimes")
(use "PsdToSd")
(use "dProp")
(use "CoIy")
(use-with "CoIClosureSquare" (pt "x") "CoIx")
;; Proof finished.
;; (cp)
(save "CoIToJSquare")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))
;; [u0]
;;  [let (ai yprod(sd ysum boole ysum boole))_1
;;    (cCoIClosureSquare u0)
;;    [if (ai yprod(sd ysum boole ysum boole))_1
;;     ([u2,(sd ysum boole ysum boole)_3]
;;      [if (sd ysum boole ysum boole)_3
;;        ([s4]
;;         (CWrite sd yprod ai)SdM
;;         ((CInit sd yprod ai)(SdM pair cCoIClosureInv s4 u2)))
;;        ([(boole ysum boole)_4]
;;         [if (boole ysum boole)_4
;;           ([b5]
;;            (CAvc sd yprod ai)RT
;;            ((CWrite sd yprod ai)SdM((CInit sd yprod ai)(SdM pair u2)))
;;            (cCoISdTimes(cPsdToSd b5)u2))
;;           ([b5]
;;            [let su6
;;              (cCoIClosure
;;              (cCoIAverage(cCoIClosureInv SdR(cCoISdTimes(cPsdToSd b5)u2))
;;               (cCoISdTimes(cPsdToSd b5)u2)))
;;              [let t7
;;               (cIntPlusSdToSdtwo SdR clft su6)
;;               ((CAvc sd yprod ai)t7
;;               ((CWrite sd yprod ai)SdR((CInit sd yprod ai)(SdR pair u2)))
;;               crht su6)]])])])]]

(add-sound "CoIToJSquare")
(deanimate "CoIToJSquare")

;; JSquareToCoI
(set-goal "allnc x((J (cterm(x^)
 exr z,d(Sd d andi CoI z andl x^ ===(1#2)*(z*z+d))))x -> CoI x)")
(use "CoIGfpIter")
(assume "x3" "Jx3")
(elim "Jx3")
(drop "Jx3")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "d" "dzProp")
(assert "CoI z")
(use "dzProp")
(assume "CoIz")
(intro 0 (pt "d"))
(intro 0 (pt "z*z"))
(split)
(use "dzProp")
(split)
(autoreal)
(split)
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "RealTimes 1 1"))
(use "RealLeMonTimesTwo")
(use "RealLeZeroAbs")
(autoreal)
(use "RealLeZeroAbs")
(autoreal)
(use-with "CoIToBd" (pt "z") "CoIz")
(use-with "CoIToBd" (pt "z") "CoIz")
(use "RealLeRefl")
(autoreal)
(split)
(use "CoIToJSquare")
(use "CoIz")
(use "dzProp")
(drop "Jx3")
(assume "d" "x" "y" "Sdd" "Jx" "IH" "yDef")
(drop "IH")
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(split)
(use "Sdd")
(split)
(use "JSquareToReal")
(use "Jx")
(split)
(use "JSquareToBd")
(use "Jx")
(split)
(use "Jx")
(use "yDef")
(assume "i" "x" "y" "z" "Sdtwoi" "Jx" "IHx" "CoIy" "zDef")
(by-assume "IHx" "e" "eProp")
(by-assume "eProp" "x1" "ex1Prop")
(cut "exr d,x(Sd d andd CoI x andl y===(1#2)*(x+d))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "yInst")
(by-assume "yInst" "d1" "d1Prop")
(by-assume "d1Prop" "y2" "d1y2Prop")
(assert "CoI y2")
(use "d1y2Prop")
(assume "CoIy2")
(assert "Real x1")
(use "ex1Prop")
(assume "Rx1")
(cut "exr j,d0(
  Sdtwo j andd 
  Sd d0 andl (1#4)*((1#2)*(x1+e)+(1#2)*(y2+d1)+i)===(1#2)*((1#4)*(x1+y2+j)+d0))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "ExHyp")
(by-assume "ExHyp" "j" "jProp")
(by-assume "jProp" "e1" "je1Prop")
(intro 0 (pt "e1"))
(intro 0 (pt "(1#4)*(x1+y2+j)"))
(split)
(use "je1Prop")
(split)
(autoreal)
(split)
(use "RealCarryBound")
(use "Rx1")
(autoreal)
(use "ex1Prop")
(use-with "CoIToBd" (pt "y2") "CoIy2")
(use "je1Prop")
(split)
(intro 2 (pt "j") (pt "x1") (pt "y2"))
(use "je1Prop")
(use "ex1Prop")
(use "CoIy2")
(use "RealEqRefl")
(autoreal)
(simpreal "zDef")
(simpreal "ex1Prop")
(simpreal "d1y2Prop")
(use "je1Prop")
(use "RealCarryAvCl")
(use "Sdtwoi")
(use "ex1Prop")
(use "d1y2Prop")
(use "ex1Prop")
(use-with "CoIToReal" (pt "y2") "CoIy2")
(use-with "CoIClosure" (pt "y") "CoIy")
;; Proof finished.
;; (cp)
(save "JSquareToCoI")

;; (define eterm (proof-to-extracted-term))
;; (ppc (nt eterm))
;; cCoIGfpIter
;; ([(algJ(sd yprod ai))_1]
;;   (Rec algJ(sd yprod ai)=>sd yprod algJ(sd yprod ai))(algJ(sd yprod ai))_1
;;   ([su2]clft su2 pair cCoIToJSquare crht su2)
;;   ([s2,(algJ(sd yprod ai))_3,(sd yprod algJ(sd yprod ai))_4]
;;     s2 pair(algJ(sd yprod ai))_3)
;;   ([t2,(algJ(sd yprod ai))_3,(sd yprod algJ(sd yprod ai))_4,u5]
;;     [let su6
;;       (cCoIClosure u5)
;;       [let (sdtwo yprod sd)_7
;;        (cRealCarryAvCl t2 clft(sd yprod algJ(sd yprod ai))_4 clft su6)
;;        (crht(sdtwo yprod sd)_7 pair 
;;        CAvc clft(sdtwo yprod sd)_7 crht(sd yprod algJ(sd yprod ai))_4 
;;        crht su6)]]))

(add-sound "JSquareToCoI")
(deanimate "JSquareToCoI")

;; CoISquare
(set-goal "allnc x(CoI x -> CoI (x*x))")
(assume "x" "CoIx")
(use "JSquareToCoI")
(use "CoIToJSquare")
(use "CoIx")
;; Proof finished.
;; (cp)
(save "CoISquare")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))
;; [u0]cJSquareToCoI(cCoIToJSquare u0)

(add-sound "CoISquare")
(deanimate "CoISquare")

;; MultAux
(set-goal "allnc x,y,d0,d1,e0,e1(
 Real x -> Real y -> 
 (1#2)*((1#2)*(x+d1)+d0)*((1#2)*((1#2)*(y+e1)+e0))===
     (1#2)*
     ((1#2)*((1#2)*((1#2)*(x*y+d1*e1)+d0*e1)+d0*e0)+
      (1#2)*((1#2)*((1#2)*(e1*x+d1*e0)+e0*x)+(1#2)*((1#2)*(d1*y+d1*e0)+d0*y))))")
(assume "x" "y" "d0" "d1" "e0" "e1" "Rx" "Ry")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "<-" "RealTimesPlusDistr")
(simpreal (pf "d0*e0===RealTimes(1#2)(RealTimes(1#2)(IntTimes 4 (d0*e0)))"))
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal (pf "e0===RealTimes(1#2)(IntTimes 2 e0)"))
(simpreal (pf "d0===RealTimes(1#2)(IntTimes 2 d0)"))
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal (pf "d0*e1===RealTimes(1#2)(IntTimes 2 (d0*e1))"))
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "RealTimesAssoc")
(simpreal-with
 "RealTimesComm"
 (pt "(1#2)*(y+e1+2*e0)") (pt "RealConstr([n](1#2))([p]Zero)") "?" "?")
(simpreal "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesPlusDistr")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(ng #t)
(simpreal "RealTimesComm")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(simpreal-with
 "RealPlusComm" (pt "x") (pt "RealConstr([n]d1#1)([p]Zero)") "?" "?")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(simpreal-with
 "RealPlusComm" (pt "y") (pt "RealConstr([n]e1#1)([p]Zero)") "?" "?")
(simpreal "RealTimesPlusDistr")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(simpreal-with "RealPlusComm" (pt "x") (pt "RealPlus d1(2*d0)") "?" "?")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesPlusDistrLeft")
(simpreal-with
 "RealPlusComm" (pt "RealTimes d1(2*e0)") (pt "RealTimes(2*d0)(2*e0)") "?" "?")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RatEqvToRealEq")
(simp-with "IntTimesComm" (pt "2*d0") (pt "IntPos 2"))
(ng #t)
(use "Truth")
(ng #t)
(simpreal "RealPlusComm")
(use "RealEqSym")
(simpreal-with "RealPlusComm" (pt "e1*x+d1*e0") (pt "2*e0*x") "?" "?")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqSym")
(simpreal "RealTimesComm")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal-with "RealPlusComm" (pt "e1*x+d1*e0") (pt "d1*y") "?" "?")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealPlusCompat")
(use "RealTimesComm")
(autoreal)
(simpreal "RealPlusAssoc")
(use "RealEqSym")
(simpreal "RealPlusComm")
(use "RealPlusCompat")
(use "RatEqvToRealEq")
(simp-with "IntTimesComm" (pt "d1") (pt "IntPos 2"))
(simp (pf "IntPos 2=IntPlus 1 1"))
(simp "<-" "IntTimesAssoc")
(simp "IntTimesPlusDistrLeft")
(ng #t)
(use "Truth")
(use "Truth")
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RatEqvToRealEq")
(ng #t)
(simp "IntTimesComm")
(use "Truth")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(use "IntTimesComm")
(use "RatEqvToRealEq")
(ng #t)
(use "IntTimesComm")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(simp "IntTimesComm")
(use "Truth")
(autoreal)
;; Proof finished.
;; (cp)
(save "MultAux")

;; JMultToReal
(set-goal "allnc x((J (cterm(x^)
 exr z,y(CoI z andi CoI y andl x^ ===z*y)))x -> Real x)")
(use-with "JToReal"
	  (make-cterm (pv "x^")
		      (pf "exr z,y(CoI z andi CoI y andl x^ ===z*y)"))
	  "?")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "y" "zyProp")
(use "RealEqToReal0" (pt "z*y"))
(use "zyProp")
;; Proof finished.
;; (cp)
(save "JMultToReal")

;; JMultToBound
(set-goal "allnc x((J (cterm(x^)
 exr z,y(CoI z andi CoI y andl x^ ===z*y)))x -> abs x<<=1)")
(use-with "JToBd"
	  (make-cterm (pv "x^")
		      (pf "exr z,y(CoI z andi CoI y andl x^ ===z*y)"))
	  "?" "?")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "y" "zyProp")
(use "RealEqToReal0" (pt "z*y"))
(use "zyProp")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "y" "zyProp")
(assert "CoI z")
(use "zyProp")
(assume "CoIz")
(assert "CoI y")
(use "zyProp")
(assume "CoIy")
(simpreal "zyProp")
(use "RealLeTrans" (pt "RealTimes 1 1"))
(simpreal "RealAbsTimes")
(use "RealLeMonTimesTwo")
(use "RealLeZeroAbs")
(autoreal)
(use "RealLeZeroAbs")
(autoreal)
(use "CoIToBd")
(use "CoIz")
(use "CoIToBd")
(use "CoIy")
(autoreal)
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
;; (cp)
(save "JMultToBd")

;; CoIMultToJClosure
;; (set! COMMENT-FLAG #f)
(set-goal "allnc x,y(CoI x -> CoI y ->
 exr d,z(Sd d andi (J (cterm (x^1) exr z,y(CoI z andd CoI y andl x^1===z*y)))z
 andl x*y===(1#2)*(z+d)))")
(assume "x" "y" "CoIx" "CoIy")
(inst-with-to "CoIClosureSquare" (pt "x") "CoIx" "xInst")
(by-assume "xInst" "x0" "x0Prop")
(elim "x0Prop")
(drop "x0Prop")
(assume "CoIx0" "x0Disj")
(elim "x0Disj")
(drop "x0Disj")
(assume "dExHyp")
(by-assume "dExHyp" "d0" "d0Prop")
(intro 0 (pt "0"))
(intro 0 (pt "(1#2)*(x0+d0)*y"))
(split)
(intro 1)
(split)
(intro 0)
(intro 0 (pt "(1#2)*(x0+d0)"))
(intro 0 (pt "y"))
(split)
(use "CoIClosureInv")
(use "d0Prop")
(use "CoIx0")
(split)
(use "CoIy")
(use "RealEqRefl")
(autoreal)
(simpreal "d0Prop")
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(autoreal)
(assume "dDisj")
(drop "x0Disj")
(inst-with-to "CoIClosureSquare" (pt "y") "CoIy" "yInst")
(by-assume "yInst" "y0" "y0Prop")
(elim "y0Prop")
(drop "y0Prop")
(assume "CoIy0" "y0Disj")
(elim "y0Disj")
(drop "y0Disj")
(assume "dExHyp")
(by-assume "dExHyp" "d0" "d0Prop")
(intro 0 (pt "0"))
(intro 0 (pt "x*((1#2)*(y0+d0))"))
(split)
(intro 1)
(split)
(intro 0)
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*(y0+d0)"))
(split)
(use "CoIx")
(split)
(use "CoIClosureInv")
(use "d0Prop")
(use "CoIy0")
(use "RealEqRefl")
(autoreal)
(simpreal "d0Prop")
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(simpreal-with
 "RealTimesComm" (pt "x") (pt "RealConstr([n]1#2)([p]Zero)") "?" "?")
(simpreal "<-" "RealTimesAssoc")
(use "RealEqRefl")
(autoreal)
(assume "eDisj")
(drop "y0Disj")
(cut "exr d0,d1(Psd d0 andi (d1=0 ori d0=d1) andi x===(1#2)*((1#2)*(x0+d1)+d0))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "xExDef")
(cut "exr e0,e1(Psd e0 andi (e1=0 ori e0=e1) andi y===(1#2)*((1#2)*(y0+e1)+e0))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "yExDef")
(by-assume "xExDef" "d0" "d0Prop")
(by-assume "d0Prop" "d1" "d0d1Prop")
(elim "d0d1Prop")
(drop "d0d1Prop")
(assume "Psdd0" "Rest")
(elim "Rest")
(drop "Rest")
(assume "d1Disj" "xDef")
(assert "Sd d1")
(elim "d1Disj")
(assume "d1=0")
(simp "d1=0")
(intro 1)
(assume "d0=d1")
(simp "<-" "d0=d1")
(use "PsdToSd")
(use "Psdd0")
(assume "Sdd1")
(by-assume "yExDef" "e0" "e0Prop")
(by-assume "e0Prop" "e1" "e0e1Prop")
(elim "e0e1Prop")
(drop "e0e1Prop")
(assume "Psde0" "eRest")
(elim "eRest")
(drop "eRest")
(assume "e1Disj" "yDef")
(assert "Sd e1")
(elim "e1Disj")
(assume "e1=0")
(simp "e1=0")
(intro 1)
(assume "e0=e1")
(simp "<-" "e0=e1")
(use "PsdToSd")
(use "Psde0")
(assume "Sde1")
(assert "Real x0")
(autoreal)
(assume "Rx0")
(assert "Real y0")
(autoreal)
(assume "Ry0")
(inst-with-to
 "MultAux" (pt "x0") (pt "y0") (pt "d0") (pt "d1") (pt "e0") (pt "e1")
 "Rx0" "Ry0" "MultAuxInst")
(assert "CoI((1#2)*((1#2)*(e1*x0+d1*e0)+e0*x0))")
(use "CoIAverage")
(use "CoIClosureInv")
(use "IntTimesSdToSd")
(use "Sdd1")
(use "PsdToSd")
(use "Psde0")
(use "CoISdTimes")
(use "Sde1")
(use "CoIx0")
(use "CoISdTimes")
(use "PsdToSd")
(use "Psde0")
(use "CoIx0")
(assume "xCoIRht")
(assert "CoI((1#2)*((1#2)*(d1*y0+d1*e0)+d0*y0))")
(use "CoIAverage")
(use "CoIClosureInv")
(use "IntTimesSdToSd")
(use "Sdd1")
(use "PsdToSd")
(use "Psde0")
(use "CoISdTimes")
(use "Sdd1")
(use "CoIy0")
(use "CoISdTimes")
(use "PsdToSd")
(use "Psdd0")
(use "CoIy0")
(assume "yCoIRht")
(assert "CoI((1#2)*
               ((1#2)*((1#2)*(e1*x0+d1*e0)+e0*x0)+
                (1#2)*((1#2)*(d1*y0+d1*e0)+d0*y0)))")
(use "CoIAverage")
(use "xCoIRht")
(use "yCoIRht")
(assume "CoIRht")
(drop "xCoIRht")
(drop "yCoIRht")
(inst-with-to "CoIClosure" (pt "(1#2)*
          ((1#2)*((1#2)*(e1*x0+d1*e0)+e0*x0)+
           (1#2)*((1#2)*(d1*y0+d1*e0)+d0*y0))") "CoIRht" "RhtInst")
(by-assume "RhtInst" "k" "kProp")
(by-assume "kProp" "z" "kzProp")
(elim "kzProp")
(drop "kzProp")
(assume "Sdk" "kConj")
(elim "kConj")
(drop "kConj")
(assume "CoIz" "RhtDef")
(inst-with-to "CoIClosure" (pt "z") "CoIz" "zInst")
(by-assume "zInst" "k0" "k0Prop")
(by-assume "k0Prop" "z0" "k0z0Prop")
(elim "k0z0Prop")
(drop "k0z0Prop")
(assume "Sdk0" "k0Conj")
(elim "k0Conj")
(drop "k0Conj")
(assume "CoIz0" "zDef")
(assert
 "(1#2)*((1#2)*((1#2)*((1#2)*(x0*y0+d1*e1)+d0*e1)+d0*e0)+
        (1#2)*((1#2)*(z0+k0)+k))===
        (1#4)*((1#2)*((1#2)*(x0*y0+d1*e1)+d0*e1)+(1#2)*(z0+k0)+(d0*e0+k))")
(use "RealAvClToCarry")
(autoreal)
(use "PsdToSd")
(use "IntTimesPsdToPsd")
(use "Psdd0")
(use "Psde0")
(use "Sdk")
(assume "ToCarryEq")
;; (inst-with "RealCarryAvCl" (pt "d0*e0+k") (pt "(1#2)*(x0*y0+d1*e1)") (pt "z0") (pt "d0*e1") (pt "k0"))
(assert "exr j,d(
      Sdtwo j andd 
      Sd d andl 
      (1#4)*((1#2)*((1#2)*(x0*y0+d1*e1)+d0*e1)+(1#2)*(z0+k0)+(d0*e0+k))===
      (1#2)*((1#4)*((1#2)*(x0*y0+d1*e1)+z0+j)+d))")
(use "RealCarryAvCl")
(use "IntPlusSdToSdtwo")
(use "PsdToSd")
(use "IntTimesPsdToPsd")
(use "Psdd0")
(use "Psde0")
(use "Sdk")
(use "PsdTimesSdToSd")
(use "Psdd0")
(use "Sde1")
(use "Sdk0")
(autoreal)
(assume "CarryAvClExHyp")
(by-assume "CarryAvClExHyp" "j" "jProp")
(by-assume "jProp" "d" "jdProp")
(intro 0 (pt "d"))
(intro 0 (pt "(1#4)*((1#2)*(x0*y0+d1*e1)+z0+j)"))
(split)
(use "jdProp")
(split)
(intro 2 (pt "j") (pt "(1#2)*(x0*y0+d1*e1)") (pt "z0"))
(use "jdProp")
(intro 1 (pt "d1*e1") (pt "x0*y0"))
(use "IntTimesSdToSd")
(use "Sdd1")
(use "Sde1")
(intro 0)
(intro 0 (pt "x0"))
(intro 0 (pt "y0"))
(split)
(use "CoIx0")
(split)
(use "CoIy0")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "CoIz0")
(use "RealEqRefl")
(autoreal)
(simpreal "xDef")
(simpreal "yDef")
(simpreal "MultAuxInst")
(simpreal "RhtDef")
(simpreal "zDef")
(simpreal "ToCarryEq")
(simpreal "jdProp")
(use "RealEqRefl")
(autoreal)
(elim "eDisj")
(elim)
(assume "k" "kProp")
(intro 0 (pt "k"))
(intro 0 (pt "0"))
(split)
(use "kProp")
(split)
(intro 0)
(use "Truth")
(use "kProp")
(elim)
(assume "k" "kProp")
(intro 0 (pt "k"))
(intro 0 (pt "k"))
(split)
(use "kProp")
(split)
(intro 1)
(use "Truth")
(use "kProp")
(elim "dDisj")
(elim)
(assume "k" "kProp")
(intro 0 (pt "k"))
(intro 0 (pt "0"))
(split)
(use "kProp")
(split)
(intro 0)
(use "Truth")
(use "kProp")
(elim)
(assume "k" "kProp")
(intro 0 (pt "k"))
(intro 0 (pt "k"))
(split)
(use "kProp")
(split)
(intro 1)
(use "Truth")
(use "kProp")
;; (set! COMMENT-FLAG #t)
;; Proof finished.
;; (cp)
(save "CoIMultToJClosure")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))
;; [u0,u1]
;;  [if (cCoIClosureSquare u0)
;;    ([u2,(sd ysum boole ysum boole)_3]
;;     [if (sd ysum boole ysum boole)_3
;;       ([s4]SdM pair(CInit ai yprod ai)(cCoIClosureInv s4 u2 pair u1))
;;       ([(boole ysum boole)_4]
;;        [if (cCoIClosureSquare u1)
;;          ([u5,(sd ysum boole ysum boole)_6]
;;           [if (sd ysum boole ysum boole)_6
;;             ([s7]SdM pair(CInit ai yprod ai)(u0 pair cCoIClosureInv s7 u5))
;;             ([(boole ysum boole)_7]
;;              [let (boole yprod boole)_8
;;                [if (boole ysum boole)_4 ([b8]b8 pair True) ([b8]b8 pair False)]
;;                [let (boole yprod boole)_9
;;                 [if (boole ysum boole)_7
;;                  ([b9]b9 pair True)
;;                  ([b9]b9 pair False)]
;;                 [if (boole yprod boole)_8
;;                  ([b10,b11]
;;                   [if (boole yprod boole)_9
;;                     ([b12,b13]
;;                      [if (cCoIClosure
;;                            (cCoIAverage
;;                             (cCoIAverage
;;                              (cCoIClosureInv
;;                               (cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)]
;;                                (cPsdToSd b12))
;;                               (cCoISdTimes[if b13 SdM (cPsdToSd b12)]u2))
;;                              (cCoISdTimes(cPsdToSd b12)u2))
;;                             (cCoIAverage
;;                              (cCoIClosureInv
;;                               (cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)]
;;                                (cPsdToSd b12))
;;                               (cCoISdTimes[if b11 SdM (cPsdToSd b10)]u5))
;;                              (cCoISdTimes(cPsdToSd b10)u5))))
;;                        ([s14,u15]
;;                         [if (cCoIClosure u15)
;;                           ([s16,u17]
;;                            crht(cRealCarryAvCl
;;                                 (cIntPlusSdToSdtwo
;;                                  (cPsdToSd(cIntTimesPsdToPsd b10 b12))
;;                                  s14)
;;                                 (cPsdTimesSdToSd b10
;;                                  [if b13 SdM (cPsdToSd b12)])
;;                                 s16)pair
;;                            (CAvc ai yprod ai)
;;                            clft(cRealCarryAvCl
;;                                 (cIntPlusSdToSdtwo
;;                                  (cPsdToSd(cIntTimesPsdToPsd b10 b12))
;;                                  s14)
;;                                 (cPsdTimesSdToSd b10
;;                                  [if b13 SdM (cPsdToSd b12)])
;;                                 s16)
;;                            ((CWrite ai yprod ai)
;;                             (cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)]
;;                              [if b13 SdM (cPsdToSd b12)])
;;                             ((CInit ai yprod ai)(u2 pair u5)))
;;                            u17)])])])]]])])])])]

(add-sound "CoIMultToJClosure")
(deanimate "CoIMultToJClosure")

;; JMultToCoI
(set-goal "allnc x((J (cterm(x^)
 exr z,y(CoI z andi CoI y andl x^ ===z*y)))x -> CoI x)")
;; (set! COMMENT-FLAG #f)
(use "CoIGfpIter")
(assume "x3" "Jx3")
(elim "Jx3")
(drop "Jx3")
(assume "x" "ExHyp")
(by-assume "ExHyp" "z" "zProp")
(by-assume "zProp" "y" "zyProp")
(assert "CoI z")
(use "zyProp")
(assume "CoIz")
(assert "CoI y")
(use "zyProp")
(assume "CoIy")
(cut "exr d,z0(
          Sd d andd 
          (J (cterm (x^) exr z1,y0(CoI z1 andd CoI y0 andl x^ ===z1*y0)))z0 andl 
          z*y===(1#2)*(z0+d))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "zyInst")
(by-assume "zyInst" "d" "dProp")
(by-assume "dProp" "x0" "dx0Prop")
(intro 0 (pt "d"))
(intro 0 (pt "x0"))
(split)
(use "dx0Prop")
(split)
(use "JMultToReal")
(use "dx0Prop")
(split)
(use "JMultToBd")
(use "dx0Prop")
(split)
(use "dx0Prop")
(use "RealEqTrans" (pt "z*y"))
(use "zyProp")
(use "dx0Prop")
(use-with "CoIMultToJClosure" (pt "z") (pt "y") "CoIz" "CoIy")
(assume "d" "x" "y" "Sdd" "Jx" "IH" "yDef")
(drop "IH")
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(split)
(use "Sdd")
(split)
(use "JMultToReal")
(use "Jx")
(split)
(use "JMultToBd")
(use "Jx")
(split)
(use "Jx")
(use "yDef")
(assume "i" "x" "y" "z" "Sdtwoi" "Jx" "IHx" "CoIy" "zDef")
(by-assume "IHx" "e" "eProp")
(by-assume "eProp" "x1" "ex1Prop")
(cut "exr d,x(Sd d andd CoI x andl y===(1#2)*(x+d))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "yInst")
(by-assume "yInst" "d1" "d1Prop")
(by-assume "d1Prop" "y2" "d1y2Prop")
(assert "CoI y2")
(use "d1y2Prop")
(assume "CoIy2")
(assert "Real x1")
(use "ex1Prop")
(assume "Rx1")
(cut "exr j,d0(
  Sdtwo j andd 
  Sd d0 andl (1#4)*((1#2)*(x1+e)+(1#2)*(y2+d1)+i)===(1#2)*((1#4)*(x1+y2+j)+d0))")
(use-with "Id" (make-cterm (goal-to-formula (current-goal))) "?")
(assume "ExHyp")
(by-assume "ExHyp" "j" "jProp")
(by-assume "jProp" "e1" "je1Prop")
(intro 0 (pt "e1"))
(intro 0 (pt "(1#4)*(x1+y2+j)"))
(split)
(use "je1Prop")
(split)
(autoreal)
(split)
(use "RealCarryBound")
(use "Rx1")
(autoreal)
(use "ex1Prop")
(use-with "CoIToBd" (pt "y2") "CoIy2")
(use "je1Prop")
(split)
(intro 2 (pt "j") (pt "x1") (pt "y2"))
(use "je1Prop")
(use "ex1Prop")
(use "CoIy2")
(use "RealEqRefl")
(autoreal)
(simpreal "zDef")
(simpreal "ex1Prop")
(simpreal "d1y2Prop")
(use "je1Prop")
(use "RealCarryAvCl")
(use "Sdtwoi")
(use "ex1Prop")
(use "d1y2Prop")
(use "ex1Prop")
(use-with "CoIToReal" (pt "y2") "CoIy2")
(use-with "CoIClosure" (pt "y") "CoIy")
;; Proof finished.
;; (cp)
;; (set! COMMENT-FLAG #t)
(save "JMultToCoI")

;; (define eterm (proof-to-extracted-term))
;; (ppc (nt eterm))
;; ([(algJ(ai yprod ai))_1]
;;   (Rec algJ(ai yprod ai)=>sd yprod algJ(ai yprod ai))(algJ(ai yprod ai))_1
;;   ([(ai yprod ai)_2]
;;     [let (sd yprod algJ(ai yprod ai))_3
;;       (cCoIMultToJClosure clft(ai yprod ai)_2 crht(ai yprod ai)_2)
;;       (sd yprod algJ(ai yprod ai))_3])
;;   ([s2,(algJ(ai yprod ai))_3,(sd yprod algJ(ai yprod ai))_4]
;;     s2 pair(algJ(ai yprod ai))_3)
;;   ([t2,(algJ(ai yprod ai))_3,(sd yprod algJ(ai yprod ai))_4,u5]
;;     [let su6
;;       (cCoIClosure u5)
;;       [let (sdtwo yprod sd)_7
;;        (cRealCarryAvCl t2 clft(sd yprod algJ(ai yprod ai))_4 clft su6)
;;        (crht(sdtwo yprod sd)_7 pair 
;;        CAvc clft(sdtwo yprod sd)_7 crht(sd yprod algJ(ai yprod ai))_4 
;;        crht su6)]]))

(add-sound "JMultToCoI")
(deanimate "JMultToCoI")

;; CoIMult
(set-goal "allnc x,y(CoI x -> CoI y -> CoI(x*y))")
(assume "x" "y" "CoIx" "CoIy")
(use "JMultToCoI")
(intro 0)
(intro 0 (pt "x"))
(intro 0 (pt "y"))
(split)
(use "CoIx")
(split)
(use "CoIy")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cp)
(save "CoIMult")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))
;; [u0,u1]cJMultToCoI((CInit ai yprod ai)(u0 pair u1))

(add-sound "CoIMult")
(deanimate "CoIMult")

;; Monom
(set-goal "allnc x(CoI x -> all p(CoI(x**p)))")
(assume "x" "CoIx")
(ind)
(ng #t)
(simpreal "RealOneTimes")
(use "CoIx")
(autoreal)
(assume "p" "IH")
(ng #t)
(simp "<-" "NatDoublePlusEq")
(simpreal "RealExpPlus")
(use "CoISquare")
(use "IH")
(autoreal)
(assume "p" "IH")
(ng #t)
(use "CoIMult")
(simp "<-" "NatDoublePlusEq")
(simpreal "RealExpPlus")
(use "CoISquare")
(use "IH")
(autoreal)
(use "CoIx")
;; Proof finished.
;; (cp)
(save "CoIMonom")

;; (define eterm (proof-to-extracted-term))
;; (pp (nt eterm))
;; [u0,p1]
;;  (Rec pos=>ai)p1(cCoICompat u0)([p2,u3]cCoICompat(cCoISquare u3))
;;  ([p2,u3]cCoIMult(cCoICompat(cCoISquare u3))u0)

(add-sound "CoIMonom")
(deanimate "CoIMonom")

#;'(
;; Haskell Translation

(define sq-term (proof-to-extracted-term (theorem-name-to-proof "CoISquare")))
(define mul-term (proof-to-extracted-term (theorem-name-to-proof "CoIMult")))
(define mon-term (proof-to-extracted-term (theorem-name-to-proof "CoIMonom")))
(set! COMMENT-FLAG #t)

(map
 animate
; deanimate
 (reverse
  (list
   "CoISquare"
   "CoIMult"
   "IntHalfDsdToSd"
   "JMultToCoI"
   "CoIMultToJClosure"
   "JSquareToCoI" 
   "CoIToJSquare"
   "CoIAverage"
   "IntPlusPsdToSdHalf"  
   "PsdUMinus"
   "CoIGfpIter"
   "SdUMinus"
   "CoIClosure" 
   "Lft"
   "Rht"
   "CoICompat"
   "RealCarryAvCl"
   "IntPlusSdToSdtwo"
   "CoISdTimes"
   "TQTimesCoIToCoI"
   "TTOQCoIToCoI"
   "CoIClosureSquare"
   "SdToZeroOrPsd"
   "CoIClosureInv"
   "GenCoI"
   "PsdToSd"
   "SdToSdtwo"
   "IntTimesSdToSd"
   "IntTimesPsdToPsd"
   "PsdTimesSdToSd"
   "SdTimesPsdToSd"
   "IntPlusPsdToDsd"
   "PsdPsdTpEqDisj"
   "CoISd"
"CoIUMinus")))

;; ok, computation rule cCoISquare -> [u0]cJSquareToCoI(cCoIToJSquare u0) added
;; ok, computation rule cIntHalfDsdToSd -> [s0]s0 added
;; ok, computation rule cCoIMult -> [u0,u1]cJMultToCoI((CInit ai yprod ai)(u0 pair u1)) added
;; ok, computation rule cCoIMultToJClosure -> [u0,u1][if (cCoIClosureSquare u0) ([u2,(sd ysum boole ysum boole)_3][if (sd ysum boole ysum boole)_3 ([s4]SdM pair(CInit ai yprod ai)(cCoIClosureInv s4 u2 pair u1)) ([(boole ysum boole)_4][if (cCoIClosureSquare u1) ([u5,(sd ysum boole ysum boole)_6][if (sd ysum boole ysum boole)_6 ([s7]SdM pair(CInit ai yprod ai)(u0 pair cCoIClosureInv s7 u5)) ([(boole ysum boole)_7][let (boole yprod boole)_8 [if (boole ysum boole)_4 ([b8]b8 pair True) ([b8]b8 pair False)] [let (boole yprod boole)_9 [if (boole ysum boole)_7 ([b9]b9 pair True) ([b9]b9 pair False)] [if (boole yprod boole)_8 ([b10,b11][if (boole yprod boole)_9 ([b12,b13][if (cCoIClosure(cCoIAverage(cCoIAverage(cCoIClosureInv(cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)](cPsdToSd b12))(cCoISdTimes[if b13 SdM (cPsdToSd b12)]u2))(cCoISdTimes(cPsdToSd b12)u2))(cCoIAverage(cCoIClosureInv(cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)](cPsdToSd b12))(cCoISdTimes[if b11 SdM (cPsdToSd b10)]u5))(cCoISdTimes(cPsdToSd b10)u5)))) ([s14,u15][if (cCoIClosure u15) ([s16,u17]crht[let t18 (cIntPlusSdToSdtwo(cPsdTimesSdToSd b10[if b13 SdM (cPsdToSd b12)])s16) [if (cSdtwoToDsdDisjPsd(cIntPlusSdToSdtwo(cPsdToSd(cIntTimesPsdToPsd b10 b12))s14)) ((PairConstr sdtwo sd)t18) ([b19][if (cSdtwoToDsdDisjPsd t18) ([s20][if (cDsdToZeroDisjPsdIntHalf s20) ([if b19 RR LL]pair SdM) ([b21]MT pair cIntPlusPsdToDsd b21 b19)]) ([b20]cPsdToSdtwo(cPsdUMinus b20)pair cIntPlusPsdToDsd b20 b19)])]]pair(CAvc ai yprod ai)clft[let t18 (cIntPlusSdToSdtwo(cPsdTimesSdToSd b10[if b13 SdM (cPsdToSd b12)])s16) [if (cSdtwoToDsdDisjPsd(cIntPlusSdToSdtwo(cPsdToSd(cIntTimesPsdToPsd b10 b12))s14)) ((PairConstr sdtwo sd)t18) ([b19][if (cSdtwoToDsdDisjPsd t18) ([s20][if (cDsdToZeroDisjPsdIntHalf s20) ([if b19 RR LL]pair SdM) ([b21]MT pair cIntPlusPsdToDsd b21 b19)]) ([b20]cPsdToSdtwo(cPsdUMinus b20)pair cIntPlusPsdToDsd b20 b19)])]]((CWrite ai yprod ai)(cIntTimesSdToSd[if b11 SdM (cPsdToSd b10)][if b13 SdM (cPsdToSd b12)])((CInit ai yprod ai)(u2 pair u5)))u17)])])])]]])])])])] added
;; ok, computation rule cJMultToCoI -> (cCoIGfpIter algJ(ai yprod ai))([(algJ(ai yprod ai))_1](Rec algJ(ai yprod ai)=>sd yprod algJ(ai yprod ai))(algJ(ai yprod ai))_1([(ai yprod ai)_2][let (sd yprod algJ(ai yprod ai))_3 [if (cCoIClosureSquare clft(ai yprod ai)_2) ([u3,(sd ysum boole ysum boole)_4][if (sd ysum boole ysum boole)_4 ([s5]SdM pair(CInit ai yprod ai)(cCoIClosureInv s5 u3 pair crht(ai yprod ai)_2)) ([(boole ysum boole)_5][if (cCoIClosureSquare crht(ai yprod ai)_2) ([u6,(sd ysum boole ysum boole)_7][if (sd ysum boole ysum boole)_7 ([s8]SdM pair(CInit ai yprod ai)(clft(ai yprod ai)_2 pair cCoIClosureInv s8 u6)) ([(boole ysum boole)_8][let (boole yprod boole)_9 [if (boole ysum boole)_5 ([b9]b9 pair True) ([b9]b9 pair False)] [let (boole yprod boole)_10 [if (boole ysum boole)_8 ([b10]b10 pair True) ([b10]b10 pair False)] [if (boole yprod boole)_9 ([b11,b12][if (boole yprod boole)_10 ([b13,b14][if (cCoIClosure(cCoIAverage(cCoIAverage(cCoIClosureInv(cIntTimesSdToSd[if b12 SdM (cPsdToSd b11)](cPsdToSd b13))(cCoISdTimes[if b14 SdM (cPsdToSd b13)]u3))(cCoISdTimes(cPsdToSd b13)u3))(cCoIAverage(cCoIClosureInv(cIntTimesSdToSd[if b12 SdM (cPsdToSd b11)](cPsdToSd b13))(cCoISdTimes[if b12 SdM (cPsdToSd b11)]u6))(cCoISdTimes(cPsdToSd b11)u6)))) ([s15,u16][if (cCoIClosure u16) ([s17,u18]crht[let t19 (cIntPlusSdToSdtwo(cPsdTimesSdToSd b11[if b14 SdM (cPsdToSd b13)])s17) [if (cSdtwoToDsdDisjPsd(cIntPlusSdToSdtwo(cPsdToSd(cIntTimesPsdToPsd b11 b13))s15)) ((PairConstr sdtwo sd)t19) ([b20][if (cSdtwoToDsdDisjPsd t19) ([s21][if (cDsdToZeroDisjPsdIntHalf s21) ([if b20 RR LL]pair SdM) ([b22]MT pair cIntPlusPsdToDsd b22 b20)]) ([b21]cPsdToSdtwo(cPsdUMinus b21)pair cIntPlusPsdToDsd b21 b20)])]]pair(CAvc ai yprod ai)clft[let t19 (cIntPlusSdToSdtwo(cPsdTimesSdToSd b11[if b14 SdM (cPsdToSd b13)])s17) [if (cSdtwoToDsdDisjPsd(cIntPlusSdToSdtwo(cPsdToSd(cIntTimesPsdToPsd b11 b13))s15)) ((PairConstr sdtwo sd)t19) ([b20][if (cSdtwoToDsdDisjPsd t19) ([s21][if (cDsdToZeroDisjPsdIntHalf s21) ([if b20 RR LL]pair SdM) ([b22]MT pair cIntPlusPsdToDsd b22 b20)]) ([b21]cPsdToSdtwo(cPsdUMinus b21)pair cIntPlusPsdToDsd b21 b20)])]]((CWrite ai yprod ai)(cIntTimesSdToSd[if b12 SdM (cPsdToSd b11)][if b14 SdM (cPsdToSd b13)])((CInit ai yprod ai)(u3 pair u6)))u18)])])])]]])])])])] (sd yprod algJ(ai yprod ai))_3])([s2,(algJ(ai yprod ai))_3,(sd yprod algJ(ai yprod ai))_4]s2 pair(algJ(ai yprod ai))_3)([t2,(algJ(ai yprod ai))_3,(sd yprod algJ(ai yprod ai))_4,u5][let su6 (cCoIClosure u5) [let (sdtwo yprod sd)_7 [let t7 (cIntPlusSdToSdtwo clft(sd yprod algJ(ai yprod ai))_4 clft su6) [if (cSdtwoToDsdDisjPsd t2) ((PairConstr sdtwo sd)t7) ([b8][if (cSdtwoToDsdDisjPsd t7) ([s9][if (cDsdToZeroDisjPsdIntHalf s9) ([if b8 RR LL]pair SdM) ([b10]MT pair cIntPlusPsdToDsd b10 b8)]) ([b9]cPsdToSdtwo(cPsdUMinus b9)pair cIntPlusPsdToDsd b9 b8)])]] (crht(sdtwo yprod sd)_7 pair(CAvc ai yprod ai)clft(sdtwo yprod sd)_7 crht(sd yprod algJ(ai yprod ai))_4 crht su6)]])) added
;; ok, computation rule cCoIToJSquare -> [u0][let (ai yprod(sd ysum boole ysum boole))_1 (cCoIClosureSquare u0) [if (ai yprod(sd ysum boole ysum boole))_1 ([u2,(sd ysum boole ysum boole)_3][if (sd ysum boole ysum boole)_3 ([s4](CWrite sd yprod ai)SdM((CInit sd yprod ai)(SdM pair cCoIClosureInv s4 u2))) ([(boole ysum boole)_4][if (boole ysum boole)_4 ([b5](CAvc sd yprod ai)RT((CWrite sd yprod ai)SdM((CInit sd yprod ai)(SdM pair u2)))(cCoISdTimes(cPsdToSd b5)u2)) ([b5][let su6 (cCoIClosure(cCoIAverage(cCoIClosureInv SdR(cCoISdTimes(cPsdToSd b5)u2))(cCoISdTimes(cPsdToSd b5)u2))) [let t7 (cIntPlusSdToSdtwo SdR clft su6) ((CAvc sd yprod ai)t7((CWrite sd yprod ai)SdR((CInit sd yprod ai)(SdR pair u2)))crht su6)]])])])]] added
;; ok, computation rule cJSquareToCoI -> (cCoIGfpIter algJ(sd yprod ai))([(algJ(sd yprod ai))_1](Rec algJ(sd yprod ai)=>sd yprod algJ(sd yprod ai))(algJ(sd yprod ai))_1([su2]clft su2 pair[let (ai yprod(sd ysum boole ysum boole))_3 (cCoIClosureSquare crht su2) [if (ai yprod(sd ysum boole ysum boole))_3 ([u4,(sd ysum boole ysum boole)_5][if (sd ysum boole ysum boole)_5 ([s6](CWrite sd yprod ai)SdM((CInit sd yprod ai)(SdM pair cCoIClosureInv s6 u4))) ([(boole ysum boole)_6][if (boole ysum boole)_6 ([b7](CAvc sd yprod ai)RT((CWrite sd yprod ai)SdM((CInit sd yprod ai)(SdM pair u4)))(cCoISdTimes(cPsdToSd b7)u4)) ([b7][let su8 (cCoIClosure(cCoIAverage(cCoIClosureInv SdR(cCoISdTimes(cPsdToSd b7)u4))(cCoISdTimes(cPsdToSd b7)u4))) [let t9 (cIntPlusSdToSdtwo SdR clft su8) ((CAvc sd yprod ai)t9((CWrite sd yprod ai)SdR((CInit sd yprod ai)(SdR pair u4)))crht su8)]])])])]])([s2,(algJ(sd yprod ai))_3,(sd yprod algJ(sd yprod ai))_4]s2 pair(algJ(sd yprod ai))_3)([t2,(algJ(sd yprod ai))_3,(sd yprod algJ(sd yprod ai))_4,u5][let su6 (cCoIClosure u5) [let (sdtwo yprod sd)_7 [let t7 (cIntPlusSdToSdtwo clft(sd yprod algJ(sd yprod ai))_4 clft su6) [if (cSdtwoToDsdDisjPsd t2) ((PairConstr sdtwo sd)t7) ([b8][if (cSdtwoToDsdDisjPsd t7) ([s9][if (cDsdToZeroDisjPsdIntHalf s9) ([if b8 RR LL]pair SdM) ([b10]MT pair cIntPlusPsdToDsd b10 b8)]) ([b9]cPsdToSdtwo(cPsdUMinus b9)pair cIntPlusPsdToDsd b9 b8)])]] (crht(sdtwo yprod sd)_7 pair(CAvc sd yprod ai)clft(sdtwo yprod sd)_7 crht(sd yprod algJ(sd yprod ai))_4 crht su6)]])) added
;; ok, computation rule cIntPlusPsdToSdHalf -> cIntPlusPsdToDsd added
;; ok, computation rule cCoIAverage -> [u0,u1][let su2 (cCoIClosure u0) [let su3 (cCoIClosure u1) [let t4 (cIntPlusSdToSdtwo clft su2 clft su3) ((cCoIGfpIter ai yprod ai yprod sdtwo)([(ai yprod ai yprod sdtwo)_5][if (ai yprod ai yprod sdtwo)_5 ([u6,(ai yprod sdtwo)_7][if (ai yprod sdtwo)_7 ([u8,t9][let su10 (cCoIClosure u8) [let su11 (cCoIClosure u6) [let (sdtwo yprod sd)_12 [let t12 (cIntPlusSdToSdtwo clft su10 clft su11) [if (cSdtwoToDsdDisjPsd t9) ((PairConstr sdtwo sd)t12) ([b13][if (cSdtwoToDsdDisjPsd t12) ([s14][if (cDsdToZeroDisjPsdIntHalf s14) ([if b13 RR LL]pair SdM) ([b15]MT pair cIntPlusPsdToDsd b15 b13)]) ([b14]cPsdToSdtwo(cPsdUMinus b14)pair cIntPlusPsdToDsd b14 b13)])]] (crht(sdtwo yprod sd)_12 pair crht su11 pair crht su10 pair clft(sdtwo yprod sd)_12)]]])])])(crht su3 pair crht su2 pair t4))]]] added
;; ok, computation rule (cCoIGfpIter alpha6946) -> [(alpha6946=>sd yprod alpha6946)_0,alpha6946_1](CoRec alpha6946=>ai)alpha6946_1([alpha6946_2]clft((alpha6946=>sd yprod alpha6946)_0 alpha6946_2)pair(InR alpha6946 ai)crht((alpha6946=>sd yprod alpha6946)_0 alpha6946_2)) added
;; ok, computation rule cPsdUMinus -> [b0][if b0 False True] added
;; ok, computation rule cCoIClosure -> (Destr ai) added
;; ok, computation rule cSdUMinus -> [s0][if s0 SdL SdM SdR] added
;; ok, computation rule (cRht beta1 beta2) -> [(beta1 yprod beta2)_0][if (beta1 yprod beta2)_0 ([beta1_1,beta2_2]beta2_2)] added
;; ok, computation rule (cLft beta1 beta2) -> [(beta1 yprod beta2)_0][if (beta1 yprod beta2)_0 ([beta1_1,beta2_2]beta1_1)] added

;; add-computation-rule
;; cRealCarryAvCl
;; ->
;; [t0,s1,s2][let t3 (cIntPlusSdToSdtwo s1 s2) [if (cSdtwoToDsdDisjPsd t0) ((PairConstr sdtwo sd)t3) ([b4][if (cSdtwoToDsdDisjPsd t3) ([s5][if (cDsdToZeroDisjPsdIntHalf s5) ([if b4 RR LL]pair SdM) ([b6]MT pair cIntPlusPsdToDsd b6 b4)]) ([b5]cPsdToSdtwo[if b5 False True]pair cIntPlusPsdToDsd b5 b4)])]]
;; is in conflict with already existing computation rule
;; cRealCarryAvCl
;; ->
;; [t0,s1,s2][let t3 (cIntPlusSdToSdtwo s1 s2) [if (cSdtwoToDsdDisjPsd t0) ((PairConstr sdtwo sd)t3) ([b4][if (cSdtwoToDsdDisjPsd t3) ([s5][if (cDsdToZeroDisjPsdIntHalf s5) (cPsdToTwoTimesSdtwo b4 pair SdM) ([b6]MT pair cIntPlusPsdToDsd b6 b4)]) ([b5]cPsdToSdtwo(cPsdUMinus b5)pair cIntPlusPsdToDsd b5 b4)])]]
;; Exception in Minlog: sorry


;; (display-animation)

;; ("cLft" "cRht" "cSdUMinus" "cCoIClosure" "cPsdUMinus"
;;  "cCoIGfpIter" "cCoIAverage" "cIntPlusPsdToSdHalf"
;;  "cJSquareToCoI" "cCoIToJSquare" "cJMultToCoI"
;;  "cCoIMultToJClosure" "cCoIMult" "cIntHalfDsdToSd"
;;  "cCoISquare" "cPsdToTwoTimesSdtwo" "cRealCarryAvCl"
;;  "cRealAvClToCarryEx" "cRatToCoI" "cRatToReal"
;;  "cCoIClauseInv" "cCoIClause" "cCoTotalAiClause"
;;  "cCoEqPSdtwoClause" "cCoTotalSdtwoClause" "cCoEqPSdClause"
;;  "cCoTotalSdClause" "cCoEqPIntClause" "cCoTotalIntClause"
;;  "cCoEqPPosClause" "cCoTotalPosClause" "cCoSEqPListClause"
;;  "cCoANEqPListClause" "cCoEqPListClause" "cCoNEqPListClause"
;;  "cCoREqPListClause" "cCoSTotalListClause"
;;  "cCoANTotalListClause" "cCoTotalListClause"
;;  "cCoNTotalListClause" "cCoRTotalListClause"
;;  "cNatLtSuccCases" "cNatRecTotal" "cBooleIfEqP"
;;  "cEqPBooleToTotalRight" "cEqPBooleRefl" "cNatLeLin"
;;  "cNatLeLtCases" "cNatLeCases" "cCoEqPNatClause"
;;  "cCoTotalNatClause" "cCoTotalBooleClause")

(terms-to-haskell-program
 "~/temp/sdmult.hs"
;; "~/scheme/reals/sdcode/sdcode2024_test.hs"
 (list
  (list sq-term "coisq")
  (list mul-term "coimult")
(list mon-term "coimon")))

;; Exception in car: #<void> is not a pair

