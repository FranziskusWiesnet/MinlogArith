;; 2025-04-04.  gcd_nat.scm.  Based on Franziskus Wiesnet's
;; div_nat.scm and gcd_nat.scm

;; (load "~/git/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (set! COMMENT-FLAG #t)

;; NatDiv
;; ======

(add-program-constant "NatDiv" (py "nat=>nat=>boole"))
(add-computation-rules
 "NatDiv n m" "ExBNat(Succ m)([l]l*n=m)")

(set-totality-goal "NatDiv")
(fold-alltotal)
(assume "n")
(fold-alltotal)
(assume "m")
(use "TotalVar")
;; (cp)
(save-totality)

;; NatProdToDiv
(set-goal "all m,n,l(l*m=n -> NatDiv m n)")
(cases)
(strip)
(simp "NatDiv0CompRule")
(use "ExBNatIntro" (pt "Zero"))
(use "Truth")
(use 1)
(assume "m" "n" "l" 1)
(simp "NatDiv0CompRule")
(use "ExBNatIntro" (pt "l"))
(use "NatLeToLtSucc")
(simp (pf "l=l*1"))
(simp "<-" 1)
(use "NatLeMonTimes")
(use "Truth")
(use "Truth")
(use "Truth")
(use 1)
;; (cp)
(save "NatProdToDiv")

;; Good example for the computational content: "NatLeast n ([l]l*m=n)"
;; instead of "l" itself

;; NatDivToProd
(set-goal "all m,n(NatDiv m n -> exl l l*m=n)")
(assume "m" "n" 1)
(use "ExBNatElim" (pt "[l]l*m=n") (pt "Succ n"))
(use 1)
(assume "l" 2 3)
(intro 0 (pt "NatLeast n ([l]l*m=n)"))
(use-with "PropNatLeast" (pt "n") (pt "l") (pt "[l]l*m=n") "?" "?")
(use "NatLtSuccToLe")
(use 2)
(use 3)
;; (cp)
(save "NatDivToProd")

;; NatDivToProdNc
(set-goal "all m,n(NatDiv m n -> exnc l l*m=n)")
(assume "m" "n" 1)
(use "ExBNatElim" (pt "[l]l*m=n") (pt "Succ n"))
(use 1)
(assume "l" 2 3)
(intro 0 (pt "l"))
(use 3)
;; (cp)
(save "NatDivToProdNc")

;; NatDiv properties
;; =================

;; NatDivRefl
(set-goal "all n NatDiv n n")
(cases)
(use "Truth")
(assume "n")
(simp "NatDiv0CompRule")
(use "ExBNatIntro" (pt "1"))
(use "Truth")
(use "Truth")
;; (cp)
(save "NatDivRefl")

;; NatDivTrans
(set-goal "all l,m,n(NatDiv l  m -> NatDiv m  n -> NatDiv l n)")
(assume "l" "m" "n" 1 2)
(inst-with "NatDivToProdNc" (pt "l") (pt "m") 1)
(by-assume 3 "l0" 4)
(inst-with "NatDivToProdNc" (pt "m") (pt "n") 2)
(by-assume 5 "l1" 6)
(use "NatProdToDiv" (pt "l1*l0"))
(simp "<-" "NatTimesAssoc")
(simp 4)
(use 6)
;; (cp)
(save "NatDivTrans")

;; NatZeroDivToZero
(set-goal "all n(NatDiv Zero n -> n=Zero)")
(assume "n" 1)
(inst-with "NatDivToProdNc" (pt "Zero") (pt "n") 1)
(by-assume 2 "l" 3)
(simp "<-" 3)
(use "Truth")
;; (cp)
(save "NatZeroDivToZero")

;; NatDivZero
(set-goal "all n NatDiv n Zero")
(assume "n")
(use "Truth")
;; (cp)
(save "NatDivZero")

;; NatDivToLe
(set-goal "all n,m(Zero<m -> NatDiv n m -> n<=m)")
(assume "n" "m" 1 2)
(inst-with "NatDivToProdNc" (pt "n") (pt "m") 2)
(by-assume 3 "l" 4)
(simp (pf "n=1*n"))
(simp "<-" 4)
(use "NatLeMonTimes")
(cases (pt "l"))
(assume 5)
(use "EfAtom")
(simphyp 4 5)
(simphyp 1 6)
(use 7)
(assume "n0" 5)
(use "Truth")
(use "Truth")
(use "Truth")
;; (cp)
(save "NatDivToLe")

;; NatDivAntiSym
(set-goal "all m,n(NatDiv m n -> NatDiv n m -> n=m)")
(cases)
(assume "n" 1 2)
(simphyp 1 "NatDiv0CompRule")
(use "ExBNatElim" (pt "[l]l*Zero=n") (pt "Succ n"))
(use 3)
(assume "m" 1 2)
(use "NatEqSym")
(use 5)
(assume "n")
(cases)
(assume 1 2)
(simphyp 2 "NatDiv0CompRule")
(use "ExBNatElim" (pt "[l]l*Zero=Succ n") (pt "Succ (Succ n)"))
(use 3)
(search)
(assume "m" 1 2)
(use "NatLeAntiSym")
(use "NatDivToLe")
(use "Truth")
(use 2)
(use "NatDivToLe")
(use "Truth")
(use 1)
;; (cp)
(save "NatDivAntiSym")

;; NatDivPlus
(set-goal "all l,m,n(NatDiv l m -> NatDiv l n -> NatDiv l(m+n))")
(assume "l" "m" "n" 1 2)
(inst-with "NatDivToProdNc" (pt "l") (pt "m") 1)
(inst-with "NatDivToProdNc" (pt "l") (pt "n") 2)
(by-assume 3 "l0" 5)
(by-assume 4 "l1" 6)
(use "NatProdToDiv" (pt "l0 + l1"))
(ng #t)
(simp 5)
(simp 6)
(use "Truth")
;; (cp)
(save "NatDivPlus")

;; NatDivTimes
(set-goal "all l,m,n(NatDiv l m -> NatDiv l(n*m))")
(strip)
(inst-with "NatDivToProdNc" (pt "l") (pt "m") 1)
(by-assume 2 "l0" 3)
(use "NatProdToDiv" (pt "n*l0"))
(simp "<-" "NatTimesAssoc")
(simp 3)
(use "Truth")
;; (cp)
(save "NatDivTimes")

;; NatDivPlusRev
(set-goal "all l,m,n(NatDiv l m  -> NatDiv l(m+n) -> NatDiv l n)")
(assume "l" "m" "n" 1 2)
(inst-with "NatDivToProdNc" (pt "l") (pt "m") 1)
(inst-with "NatDivToProdNc" (pt "l") (pt "m+n") 2)
(by-assume 3 "l0" 5)
(by-assume 4 "l1" 6)
(use "NatProdToDiv" (pt "l1--l0"))
(ng)
(simp 5)
(simp 6)
(use "Truth")
;; (cp)
(save "NatDivPlusRev")

;; NatEvenToTwoDiv
(set-goal "all n(NatEven n -> NatDiv 2 n)")
(assert "all n((NatEven n -> NatDiv 2 n) andi
 (NatEven (Succ n) -> NatDiv 2(Succ n)))")
(ind)
(split)
(search)
(assume 1)
(use "EfAtom")
(use 1)
(assume "n" 1)
(split)
(use 1)
(simp "NatEven2CompRule")
(assume 2)
(inst-with "NatDivToProd" (pt "2") (pt "n") "?")
(by-assume 3 "l" 4)
(use "NatProdToDiv" (pt "l+1"))
(ng #t)
(simp "<-" 4)
(use "Truth")
(use 1)
(use 2)
(strip)
(use 1)
(use 2)
;; (cp)
(save "NatEvenToTwoDiv")

;; NatGcd
;; ======

(add-program-constant "NatGcd" (py "nat=>nat=>nat"))
(add-computation-rules
 "NatGcd 0 n" "n"
 "NatGcd n 0" "n"
 "NatGcd(Succ n)(Succ m)"
 "[if (n<m) (NatGcd(Succ n)(m--n)) (NatGcd(n--m)(Succ m))]")

(set-totality-goal "NatGcd")
(fold-alltotal)
(assume "n")
(fold-alltotal)
(assume "n0")
(assert "all m(all n(n<m -> all n0(n0<m -> TotalNat(NatGcd n n0))))")
(ind)
(strip)
(use "EfTotalNat")
(use 1)
(assume "m" 1)
(cases)
(strip)
(use "TotalVar")
(assume "n1" 2)
(cases)
(assume 3)
(use "TotalVar")
(assume "n2" 3)
(ng #t)
(cases (pt "n1<n2"))
(assume 1)
(ng #t)
(use 1)
(use "NatLeLtTrans" (pt "n2"))
(use "NatLtToSuccLe")
(use 4)
(use 3)
(use "NatLeLtTrans" (pt "n2"))
(use "Truth")
(use 3)
(assume 4)
(inst-with "NatNotLtToLe" (pt "n1") (pt "n2") 4)
(cases (pt "n2=n1"))
(assume 6)
(simp 6)
(use "TotalVar")
(assume 6)
(ng #t)
(use 1)
(use "NatLeLtTrans" (pt "n1"))
(use "Truth")
(use 2)
(use "NatLtLeTrans" (pt "Succ n1"))
(use "NatLeNotEqToLt")
(use 5)
(use 6)
(use "NatLtToSuccLe")
(use 2)
(assume 1)
(use 1 (pt "Succ (n max n0)"))
(use "NatLeToLtSucc")
(use "NatMaxUB1")
(use "NatLeToLtSucc")
(use "NatMaxUB2")
;; (cp)
(save-totality)

;; NatGcd
;; ======

;; NatGcdSelf
(set-goal "all n NatGcd n n=n")
(cases)
(use "Truth")
(assume "n")
(use "Truth")
;; (cp)
(save "NatGcdSelf")

;; NatGcdOne
(set-goal "all n NatGcd 1 n=1")
(ind)
(use "Truth")
(assume "n" 1)
(ng)
(cases (pt "Zero<n"))
(search)
(assume 2)
(ng)
(cases (pt "n"))
(search)
(strip)
(use "EfAtom")
(use 2)
(simp 3)
(use "Truth")
;; (cp)
(save "NatGcdOne")

;; NatGcdComm
(set-goal "all n,m NatGcd n m=NatGcd m n")
(assert "all l,n,m(n+m<l -> NatGcd n m=NatGcd m n)")
(ind)
(assume "n" "m" 1)
(use "EfAtom")
(use 1)
(assume "l" 1)
(cases)
(search)
(assume "n")
(cases)
(search)
(assume "m" 2)
(ng #t)
(cases (pt "n<m"))
(assume 3)
(cases (pt "m<n"))
(assume 4)
(assert "n<n")
(use "NatLtTrans" (pt "m"))
(use 3)
(use 4)
(assume 5)
(use "EfAtom")
(use 5)
(assume 4)
(use 1)
(use "NatLeLtTrans" (pt "Succ n + m"))
(use "NatLeMonPlus")
(use "Truth")
(use "Truth")
(use 2)
(assume 3)
(cases (pt "m<n"))
(assume 4)
(use 1)
(use "NatLeLtTrans" (pt "n + Succ m"))
(use "NatLeMonPlus")
(use "Truth")
(use "Truth")
(use 2)
(assume 4)
(assert "n=m")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(use 4)
(use "NatNotLtToLe")
(use 3)
(assume 5)
(simp 5)
(use "Truth")
(assume 1 "n" "m")
(use-with 1 (pt "Succ (n+m)") (pt "n") (pt "m") "Truth")
;; (cp)
(save "NatGcdComm")

;; NatGcdDiv0
(set-goal "all n,m NatDiv(NatGcd n m)n")
(assert "all l,n,m(n+m<l -> NatDiv(NatGcd n m)n)")
(ind)
(assume "n" "m" 1)
(use "EfAtom")
(use 1)
(assume "l" 1)
(cases)
(strip)
(use "NatDivZero" (pt "m"))
(assume "n")
(cases)
(assume 2)
(simp "NatGcd1CompRule")
(use "NatDivRefl")
(assume "m" 1)
(simp "NatGcd2CompRule")
(cases (pt "n<m"))
(assume 1)
(use-with 1 (pt "Succ n") (pt "m--n") "?")
(use "NatLeLtTrans" (pt "Succ n + m"))
(use "NatLeMonPlus")
(use "Truth")
(use "Truth")
(use 2)
(assume 3)
(use-with
 "NatDivTrans"
 (pt "NatGcd(n--m)(Succ m)") (pt "n--m+Succ m") (pt "Succ n") "?" "?")
(use "NatDivPlus")
(use 1)
(use "NatLeLtTrans" (pt "n+Succ m"))
(use "NatLeMonPlus")
(use "Truth")
(use "Truth")
(use 2)
(simp "NatGcdComm")
(use 1)
(use "NatLeLtTrans" (pt "Succ m+n"))
(use "NatLeMonPlus")
(use "Truth")
(use "Truth")
(simp "NatPlusComm")
(use 2)
(simp (pf "n--m+Succ m=Succ n"))
(use "NatDivRefl")
(use "NatMinusPlusEq")
(use "NatNotLtToLe")
(use 3)
(assume 1 "n" "m")
(use 1 (pt "Succ(n+m)"))
(use "Truth")
;; (cp)
(save "NatGcdDiv0")
 
;; NatGcdDiv1
(set-goal "all n,m NatDiv(NatGcd n m)m")
(assume "n" "m")
(simp "NatGcdComm")
(use "NatGcdDiv0")
;; (cp)
(save "NatGcdDiv1")

;; NatDivGcd
(set-goal "all n,m,l(NatDiv l n -> NatDiv l m -> NatDiv l(NatGcd n m))")
(assert "all m0,n,m,l(
 n+m<m0 -> NatDiv l n -> NatDiv l m -> NatDiv l(NatGcd n m))")
(ind)
(assume "n" "m" "l" 1 2 3)
(use "EfAtom")
(use 1)
(assume "m0" 1)
(cases)
(strip)
(use 4)
(assume "n")
(cases)
(strip)
(use 3)
(assume "m" "l" 2 3 4)
(simp "NatGcd2CompRule")
(cases (pt "n<m"))
(assume 5)
(use 1)
(use "NatLeLtTrans" (pt "Succ n +m"))
(use "Truth")
(use 2)
(use 3)
(simp (pf "m--n=Succ m--Succ n"))
(use "NatDivPlusRev" (pt "Succ n"))
(use 3)
(simp "NatPlusComm")
(simp "NatMinusPlusEq")
(use 4)
(use "NatLtToLe")
(use 5)
(use "Truth")
(assume 5)
(use 1)
(use "NatLeLtTrans" (pt "n+Succ m"))
(use "Truth")
(use 2)
(use "NatDivPlusRev" (pt "Succ m"))
(use 4)
(simp (pf "n--m=Succ n--Succ m"))
(simp "NatPlusComm")
(simp "NatMinusPlusEq")
(use 3)
(use "NatNotLtToLe")
(use 5)
(use "Truth")
(use 4)
(assume 1)
(assume "n" "m" "l")
(use 1 (pt "Succ(n+m)"))
(use "Truth")
;; (cp)
(save "NatDivGcd")

;; NatGcdToLinComb (Bezout's identity) 
(set-goal "all n,m exd l0,l1(
 NatGcd n m+l0*n=l1*m oru NatGcd n m+l0*m=l1*n)")
;;Introducing a new variable for induction and special case n<m
(assert "all l,n,m(n<m -> m<l -> exd l0,l1(
 NatGcd n m+l0*n=l1*m oru NatGcd n m+l0*m=l1*n))")
(ind)
;; Case l=0
 (assume "n")
 (strip)
 (intro 0 (pt "0"))
 (intro 0 (pt "0"))
 (intro 0)
 (use "EfAtom")
 (use 2)
;; Induction step: l=Succ l'
 (assume "l" 1)
 (cases)
 ;; Case n=0
  (strip)
  (intro 0 (pt "0"))
  (intro 0 (pt "1"))
  (intro 0)
  (use "Truth")
 ;; Case n=Succ n'
  (assume "n")
  (cases)
  ;; Case m=0
   (strip)
   (intro 0 (pt "0"))
   (intro 0 (pt "1"))
   (intro 1)
   (use "Truth")
  ;; Case m=Succ m' (and n=Succ n')
   (assume "m" 2 3) 
   (cases (pt "m--n < Succ n"))
   ;;Case 0
    (assume 4)
    (simp 2)
    (inst-with 1 (pt "m--n") (pt "Succ n") 4 "?")
    (by-assume 5 "l0" 6)
    (by-assume 6 "l1" 7)
    (elim 7)
    ;; Case 0.0
     (assume 8)
     (intro 0 (pt "l0"))
     (intro 0 (pt "l1+l0"))
     (intro 1)
     ;;Equality proof
     (simp "<-" "NatPlusAssoc")
     (simp (pf "l0*m+l0=l0*(Succ m -- Succ n)+l0*(Succ n)"))
     (simp "NatGcdComm")
     (simp "NatPlusAssoc")
     (simp (pf "Succ m--Succ n=m -- n"))
     (ng #t)
     (simp 8)
     (simp "NatPlusCancelEqR")
     (simp "<-" "NatPlusAssoc")
     (simp "<-" "NatPlusAssoc")
     (simp "NatPlusCancelEqL")
     (use "NatPlusComm")
     (use "Truth")
     (ng #t)
     (simp "NatMinusPlusEq")
     (use "Truth")
     (use "NatLeMonTimes")
     (use "Truth")
     (use "NatLtToLe")
     (use 2)
    ;; Case 0.1
     (assume 8)
     (intro 0 (pt "l0+l1"))
     (intro 0 (pt "l1"))
     (intro 0)
     ;;Equality proof
     (ng #t)
     (ng 8)
     (simp "NatGcdComm")
     (simp "<-" "NatPlusAssoc")
     (simp "<-" "NatPlusAssoc")
     (simp (pf "l1*n+(l0+l1)=l0+l1*n+l1"))
     (simp "NatPlusAssoc")
     (simp "NatPlusAssoc")
     (simp 8)
     (simp "NatPlusCancelEqR")
     (use "NatMinusPlusEq")
     (use "NatLeMonTimes")
     (use "Truth")
     (use "NatLtToLe")
     (use 2)
     (ng)
     (simp "NatPlusCancelEqR")
     (use "NatPlusComm")
     (use "NatLeLtTrans" (pt "m"))
     (use "NatLtToSuccLe")
     (use 2)
     (use 3)
   ;; Case 1
    (assume 4)
    (cases (pt "m--n= Succ n"))
    (assume 5)
    ;; Case 1.0
     (ng)
     (simp 5)
     (simp 2)
     (ng)
     (intro 0 (pt "m"))
     (intro 0 (pt "n+1"))
     (intro 0)
     ;; Equality proof
     (ng)
     (simp (pf "n+m*n=m*n+n"))
     (simp "<-" "NatPlusAssoc")
     (simp (pf "n+m=m+n"))
     (simp "NatTimesComm")
     (use "NatPlusAssoc")
     (use "NatPlusComm")
     (use "NatPlusComm")
    ;; Case 1.1
     (assume 5)
     (assert "Succ n < m--n")
     (use "NatLeNotEqToLt")
     (use "NatNotLtToLe")
     (use 4)
     (assume 6)
     (use 5)
     (use "NatEqSym")
     (use 6)
     (assume 6)
     (inst-with 1 (pt "Succ n") (pt "m--n") 6 "?")
     (by-assume 7 "l0" 8)
     (by-assume 8 "l1" 9)
     (simp 2)
     (ng #t)
     (elim 9)
     (assume 10)
     ;; Case 1.1.0
      (intro 0 (pt "l0+l1"))
      (intro 0 (pt "l1"))
      (intro 0)
      ;; Equality proof
      (simp "<-" "NatPlusAssoc")
      (simp (pf "(l0+l1)*n+(l0+l1)=l0*Succ n+l1*Succ n"))
      (simp "NatPlusAssoc")
      (simp 10)
      (simp "<-" "NatTimesPlusDistr")
      (simp (pf "m--n+Succ n=Succ m"))
      (use "Truth")
      (use "NatMinusPlusEq")
      (use "NatLtToLe")
      (use 2)
      (simp "<-" "NatTimesPlusDistrLeft")
      (use "Truth")
     ;; Case 1.1.1
      (assume 10)
      (intro 0 (pt "l0"))
      (intro 0 (pt "l1 +l0"))
      (intro 1)
      ;;Equality Proof
      (simp "<-" "NatPlusAssoc")
      (simp (pf "l0*m+l0=l0*(m--n)+l0*(Succ n)"))
      (simp "NatPlusAssoc")
      (simp 10)
      (simp "<-" "NatTimesPlusDistrLeft")
      (use "Truth")
      (simp (pf "l0*m=l0*(m--n+n)"))
      (use "Truth")
      (simp "NatMinusPlusEq")
      (use "Truth")
      (use "NatLtToLe")
      (use 2)
      (use "NatLeLtTrans" (pt "m"))
      (use "Truth")
      (use 3)
;; Id-Lemma to shorten the computational content.
(use "Id")
(assume 1)
;; The general case
 (assume "n" "m")
 (cases (pt "n<m"))
  (assume 2)
  (use 1 (pt "Succ m"))
  (use 2)
  (use "Truth")
 ;; Case n<m->F
  (assume 2)
   (cases (pt "n=m"))
    (assume 3)
    (simp 3)
    (intro 0 (pt "Zero"))
    (intro 0 (pt "Succ Zero"))
    (intro 0)
    (simp "NatGcdSelf")
    (use "Truth")
   ;; Case n=m->F
    (assume 3)
    (inst-with 1 (pt "Succ n") (pt "m") (pt "n") "?" "Truth")
    (by-assume 4 "l0" 5)
    (by-assume 5 "l1" 6)
    (intro 0 (pt "l0"))
    (intro 0 (pt "l1"))
    (elim 6)
    (assume 7)
    (intro 1)
    (simp "NatGcdComm")
    (use 7)
    (assume 7)
    (intro 0)
    (simp "NatGcdComm")
    (use 7)
    (use "NatLeNotEqToLt")
    (use "NatNotLtToLe")
    (use 2)
    (assume 4)
    (use 3)
    (use "NatEqSym")
    (use 4)
;; (cp)
(save "NatGcdToLinComb")
