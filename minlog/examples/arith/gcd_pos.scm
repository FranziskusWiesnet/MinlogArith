;; 2025-04-04.  gcd_pos.scm.  Based on Franziskus Wiesnet's
;; div_pos.scm and gcd_pos.scm

;; (load "~/git/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (exload "arith/gcd_nat.scm")
;; (exload "arith/prime_nat.scm")
;; (libload "pos.scm")
;; (set! COMMENT-FLAG #t)

;; NatGcdDouble
(set-goal "all n,m NatGcd(NatDouble n)(NatDouble m)=NatDouble(NatGcd n m)")
(assert "all l,n,m(
 n<m -> m<l -> NatGcd(NatDouble n)(NatDouble m)=NatDouble(NatGcd n m))")
(ind)
(strip)
(use "EfAtom")
(use 2)
(assume "l")
(assume 1)
(cases)
(strip)
(use "Truth")
(assume "n")
(cases)
(strip)
(use "Truth")
(assume "m" 1 2)
(ng #t)
(simp "NatDoubleLt")
(simp 2)
(simp "IfTrue")
(simp "IfTrue")
(simp "<-" "NatDoubleMinus")
(cases (pt "m--n<Succ n"))
(assume 4)
(assert "NatGcd(Succ n)(m--n)=NatGcd(m--n)(Succ n)")
(use "NatGcdComm")
(assume 5)
(simp 5)
(simp "<-" 1)
(use "NatGcdComm")
(use "NatLtLeTrans" (pt "Succ m"))
(use 2)
(use "NatLtSuccToLe")
(use 3)
(use 4)
(assume 4)
(cases (pt "m--n=Succ n"))
(assume 5)
(simp 5)
(use "Truth")
(assume 5)
(simp "<-" 1)
(use "Truth")
(use "NatLeLtTrans" (pt "m"))
(use "Truth")
(use 3)
(use "NatLtSuccNotEqToLt")
(use "NatLeToLtSucc")
(use "NatNotLtToLe")
(use 4)
(assume 6)
(use 5)
(use "NatEqSym")
(use 6)
(strip)
(cases (pt "n<m"))
(assume 2)
(use 1 (pt "Succ m"))
(use 2)
(use "Truth")
(assume 2)
(cases (pt "n=m"))
(assume 3)
(simp 3)
(simp "NatGcdSelf")
(simp "NatGcdSelf")
(use "Truth")
(assume 3)
(simp "NatGcdComm")
(simp (pf "NatGcd n m=NatGcd m n"))
(use 1 (pt "Succ n"))
(use "NatLtSuccNotEqToLt")
(use "NatLeToLtSucc")
(use "NatNotLtToLe")
(use 2)
(assume 4)
(use 3)
(use "NatEqSym")
(use 4)
(use "Truth")
(use "NatGcdComm")
;; (cp)
(save "NatGcdDouble")

;; NatGcdDoubleSuccDouble
(set-goal "all n,m
 NatGcd(NatDouble n)(Succ(NatDouble m))=NatGcd n(Succ(NatDouble m))")
(assume "n" "m")
(simp "NatDoubleToTwoTimes")
(simp "NatDoubleToTwoTimes")
(use "NatDivAntiSym")
(use "NatDivGcd")
(use "NatDivTrans" (pt "n"))
(use "NatGcdDiv0")
(use "NatProdToDiv" (pt "Succ(Succ Zero)"))
(use "Truth")
(use "NatGcdDiv1")
(use "NatDivGcd")
(inst-with "NatGcdDiv1" (pt "2*n") (pt "Succ(2*m)"))
(inst-with "NatGcdDiv0" (pt "2*n") (pt "Succ(2*m)"))
(inst-with
 "NatPrimeToIrredRev"
 (pt "Succ(Succ Zero)") (pt "NatGcd(2*n)(Succ(2*m))") (pt "n") "Truth" 2)
(elim 3)
(assume 4)
(inst-with "NatGcdDiv1" (pt "2*n") (pt "Succ(2*m)"))
(assert "NatDiv 2 (Succ(2*m))")
(use "NatDivTrans" (pt "NatGcd(2*n)(Succ(2*m))"))
(use 4)
(use 5)
(assume 6)
(inst-with "NatDivToProd" (pt "Succ(Succ Zero)") (pt "Succ(2*m)") 6)
(by-assume 7 "n0" 8)
(use "EfAtom")
(use "EvenNotEqOdd" (pt "n0") (pt "m"))
(use "NatEqTrans" (pt "n0*(Succ(Succ Zero))"))
(use "NatTimesComm")
(use 8)
(assume 4)
(use 4)
(use "NatGcdDiv1")
;; (cp)
(save "NatGcdDoubleSuccDouble")

;; (remove-program-constant "PosGcd")
(add-program-constant "PosGcd" (py "pos=>pos=>pos"))
(add-computation-rules
 "PosGcd 1 p" "1"
 "PosGcd(SZero p)1" "1"
 "PosGcd(SZero p)(SZero q)" "SZero(PosGcd p q)"
 "PosGcd(SZero p)(SOne q)" "PosGcd p(SOne q)"
 "PosGcd(SOne p)1" "1"
 "PosGcd(SOne p)(SZero q)" "PosGcd(SOne p)q"
 "PosGcd(SOne p)(SOne q)"
 "[if (p=q) (SOne p)
      [if (p<q) (PosGcd(SOne p)(q--p))
                      (PosGcd(p--q) (SOne q))]]")

(set-totality-goal "PosGcd")
(assert "all n,p,q(p+q<n -> TotalPos(PosGcd p q))")
(ind)
;; 4-5
(assume "p" "q")
(ng)
(use "EfTotalPos")
;; 5
(assume "n" "IH")
(cases)
;; 9-11
(strip)
(ng)
(use "TotalVar")
;; 10
(assume "p")
(cases)
;; 15-17
(strip)
(ng)
(use "TotalVar")
;; 16
(assume "q" "LtHyp")
(ng #t)
(use "TotalPosSZero")
(use "IH")
(use "NatLtTrans" (pt "PosToNat(SZero p+q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLtMonPlus1")
(simp "PosToNatLt")
(use "Truth")
(use "Truth")
(use "NatLtLeTrans" (pt "PosToNat(SZero p+SZero q)"))
;; 31,32
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(ng #t)
(use "NatLtDouble")
(use "NatLtZeroPosToNat")
(use "NatLtSuccToLe")
(use "LtHyp")
;; 17
(assume "q" "LtHyp")
(ng #t)
(use "IH")
(use "NatLtLeTrans" (pt "PosToNat(SZero p+SOne q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLtMonPlus1")
(simp "PosToNatLt")
(use "Truth")
(use "Truth")
(use "NatLtSuccToLe")
(use "LtHyp")
;; 11
(assume "p")
(cases)
;; 50-52
(strip)
(ng)
(use "TotalVar")
;; 51
(assume "q" "LtHyp")
(ng #t)
(use "IH")
(use "NatLtLeTrans" (pt "PosToNat(SOne p+SZero q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLtMonPlus2")
(use "Truth")
(simp "PosToNatLt")
(use "Truth")
(use "NatLtSuccToLe")
(use "LtHyp")
;; 52
(assume "q" "LtHyp")
(ng #t) ;BooleIfTotal does not suffice.  Need PosToNatMinus and hence cases
(cases (pt "p=q"))
;; Case p=q
(assume "p=q")
(ng #t)
(use "TotalVar")
;; Case p=q -> F
(assume "p=q -> F")
(ng #t)
(cases (pt "p<q"))
;; Case p<q
;; 74
(assume "p<q")
(ng #t)
(use "IH")
(use "NatLeLtTrans" (pt "PosToNat(SOne p+q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(ng #t)
(simp "PosToNatLe")
(use "Truth")
(use "NatLtLeTrans" (pt "PosToNat(SOne p+SOne q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLtMonPlus2")
(use "Truth")
(simp "PosToNatLt")
(use "PosLtTrans" (pt "SZero q"))
(use "Truth")
(use "Truth")
(use "NatLtSuccToLe")
(use "LtHyp")
;; 75
;; Case p<q -> F
(assume "p<q -> F")
(ng #t)
(assert "q<p")
 (use "PosNotLeToLt")
 (assume "p<=q")
 (use "PosLeCases" (pt "p") (pt "q"))
 (use "p<=q")
 (use "p<q -> F")
 (use "p=q -> F")
(assume "q<p")
(use "IH")
(use "NatLeLtTrans" (pt "PosToNat(p+SOne q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLeMonPlus")
(simp "PosToNatMinus")
(use "Truth")
(use "q<p")
(use "Truth")
(use "NatLtLeTrans" (pt "PosToNat(SOne p+SOne q)"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(use "NatLtMonPlus1")
(simp "PosToNatLt")
(use "PosLtTrans" (pt "SZero p"))
(use "Truth")
(use "Truth")
(use "Truth")
(use "NatLtSuccToLe")
(use "LtHyp")
;; Assertion proved
(assume "Assertion")
(fold-alltotal)
(assume "p")
(fold-alltotal)
(assume "q")
(use "Assertion" (pt "Succ(PosToNat(p+q))"))
(use "Truth")
;; (cp)
(save-totality)

;; PosGcdToGcdNat
(set-goal "all p,q PosToNat(PosGcd p q)=NatGcd(PosToNat p)(PosToNat q)")
(assert "all n,p,q(
 p+q<n -> PosToNat(PosGcd p q)=NatGcd(PosToNat p)(PosToNat q))")
(ind)
(strip)
(use "EfAtom")
(use 1)
(assume "n" 1)
(cases)
(cases)
(search)
(assume "p" 2)
(use "NatEqSym")
(use "NatGcdOne")
(assume "p" 2)
(simp "PosToNat2CompRule")
(simp (pf "PosToNat 1=Succ Zero"))
(simp "NatGcd2CompRule")
(simp "NatLtZeroPosToNat")
(simp "IfTrue")
(simp "PosGcd0CompRule")
(use "NatEqSym")
(use "NatGcdOne")
(use "Truth")
(assume "p")
(cases)
(ng)
(assume 2)
(simp "NatGcdComm")
(use "NatEqSym")
(use "NatGcdOne")
(assume "q" 2)
(simp "PosGcd2CompRule")
(ng)
(simp 1)
(simp "NatGcdDouble")
(use "Truth")
(use "NatLtLeTrans" (pt "NatDouble(PosToNat p+q)"))
(simp "NatDoubleToTwoTimes")
(simp "NatTimesComm")
(simp (pf "p+q=NatPlus(PosToNat p)(PosToNat q)"))
(use "NatLtPosToLtTimes")
(use "Truth")
(simp (pf "Zero=Zero+Zero"))
(use "NatLtMonPlus1")
(use "NatLtZeroPos")
(use "NatLtToLe")
(use "NatLtZeroPos")
(use "Truth")
(use "PosToNatPlus")
(simp "<-" "PosToNatPlus")
(use "NatLtSuccToLe")
(use 2)
(assume "q" 1)
(ng)
(simp "NatGcdDoubleSuccDouble")
(simp 1)
(use "Truth")
(use "NatLeLtTrans" (pt "NatDouble(PosToNat(p+q))"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(simp "NatDoublePlus")
(simp (pf "NatDouble(PosToNat p)=PosToNat p +PosToNat p"))
(simp "<-" "NatPlusAssoc")
(use "NatLeMonPlus")
(use "Truth")
(use "NatLeTrans" (pt "1+NatDouble(PosToNat q)"))
(use "Truth")
(use "NatLeMonPlus")
(use "NatLtToSuccLe")
(use "NatLtZeroPos")
(use "Truth")
(use "NatEqSym")
(use "NatDoublePlusEq")
(use 2)
(assume "p")
(cases)
(assume 1)
(simp "NatGcdComm")
(use "NatEqSym")
(simp (pf "Zero<NatDouble(PosToNat p)"))
(use "NatGcdOne")
(simp "NatDoubleToTwoTimes")
(use "NatLtTimesPos")
(use "Truth")
(use "NatLtZeroPosToNat")
(assume "q" 1)
(ng)
(simp "NatGcdComm")
(simp "NatGcdDoubleSuccDouble")
(simp "NatGcdComm")
(use-with 1 (pt "SOne p") (pt "q") "?")
(use "NatLeLtTrans" (pt "NatDouble(PosToNat(p+q))"))
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(simp "NatDoublePlus")
(simp (pf "NatDouble(PosToNat q)=PosToNat q+PosToNat q"))
(simp "NatPlusAssoc")
(use "NatLeMonPlus")
(use "NatLeTrans" (pt "NatDouble(PosToNat p)+1"))
(use "Truth")
(use "NatLeMonPlus")
(use "Truth")
(ng)
(use "NatLtToSuccLe")
(use "NatLtZeroPos")
(use "Truth")
(use "NatEqSym")
(use "NatDoublePlusEq")
(use 2)
(assume "q" 1)
(cases (pt "p=q"))
(assume 3)
(simp 3)
(use "Truth")
(assume 3)
(ng)
(simp 3)
(cases (pt "p<q"))
(assume 4)
(simp (pf "NatDouble(PosToNat p)<NatDouble(PosToNat q)"))
(ng)
(simp "<-" "NatDoubleMinus")
(simp "NatGcdComm")
(simp "NatGcdDoubleSuccDouble")
(simp "NatGcdComm")
(simp (pf "Succ(NatDouble(PosToNat p))=SOne p"))
(simp "<-" "PosToNatMinus")
(use-with 1 (pt "SOne p") (pt "q--p") "?")
(use "NatLtLeTrans" (pt "NatDouble(PosToNat(PosS(p+q)))"))
(simp "PosToNatPlus")
(simp "PosSSucc")
(ng)
(simp "PosToNatPlus")
(simp "NatDoublePlus")
(use "NatLeToLtSucc")
(simp (pf "NatDouble(PosToNat q)= NatPlus (PosToNat q) (PosToNat q)"))
(simp "NatPlusAssoc")
(use "NatLeMonPlus")
(use "Truth")
(simp "PosToNatMinus")
(use "Truth")
(use 4)
(use "NatEqSym")
(use "NatDoublePlusEq")
(use "NatLtSuccToLe")
(use 2)
(use 4)
(use "Truth")
(simp "NatDoubleLt")
(simp "PosToNatLt")
(use 4)
(assume 4)
(simp (pf "(NatDouble(PosToNat p)<NatDouble(PosToNat q)) -> F"))
(ng)
(simp "<-" "NatDoubleMinus")
(simp "NatGcdDoubleSuccDouble")
(simp "<-" "PosToNatMinus")
(use-with 1 (pt "p--q") (pt "SOne q") "?")
(use "NatLtLeTrans" (pt "NatDouble(PosToNat(PosS(p+q)))"))
(simp "PosSSucc")
(ng)
(simp "PosToNatPlus")
(simp "PosToNatPlus")
(simp "NatDoublePlus")
(use "NatLeToLtSucc")
(use "NatLeTrans" (pt "NatDouble(PosToNat p)+Succ(NatDouble(PosToNat q))"))
(use "NatLeMonPlus")
(simp "PosToNatMinus")
(use "NatLeTrans" (pt "PosToNat p"))
(use "Truth")
(simp "<-" "NatDoublePlusEq")
(use "Truth")
(simp "<-" "PosToNatLt")
(use "NatLeNotEqToLt")
(use "NatNotLtToLe")
(assume 5)
(use 4)
(simp "<-" "PosToNatLt")
(use 5)
(assume 5)
(use 3)
(use "PosToNatInj")
(use "NatEqSym")
(use 5)
(use "Truth")
(use "Truth")
(use "NatLtSuccToLe")
(use 2)
(simp "<-" "PosToNatLt")
(use "NatLeNotEqToLt")
(use "NatNotLtToLe")
(simp "PosToNatLt")
(use 4)
(assume 5)
(use 3)
(use "PosToNatInj")
(use "NatEqSym")
(use 5)
(simp "NatDoubleLt")
(simp "PosToNatLt")
(use 4)
(strip)
(use 1 (pt "Succ(p+q)"))
(use "Truth")
;; (cp)
(save "PosGcdToNatGcd") 

;; NatGcdToPosGcd
(set-goal "all n,m(
  Zero<n -> Zero<m -> NatGcd n m=PosToNat(PosGcd(NatToPos n)(NatToPos m)))")
(assume "n" "m" 1 2)
(simp "PosGcdToNatGcd")
(simp "PosToNatToPosId")
(simp "PosToNatToPosId")
(use "Truth")
(use 2)
(use 1)
;; (cp)
(save "NatGcdToPosGcd")

;; PosGcdComm
(set-goal "all p,q PosGcd p q=PosGcd q p")
(assume "p" "q")
(use "PosToNatInj")
(simp "PosGcdToNatGcd")
(simp "PosGcdToNatGcd")
(simp "NatGcdComm")
(use "Truth")
;; (cp)
(save "PosGcdComm")

;; PosGcdTimesId0
(set-goal "all p,q PosGcd p(q*p)=p")
(assume "p" "q")
(use "PosToNatInj")
(simp "PosGcdToNatGcd")
(use "NatDivAntiSym")
(use "NatDivGcd")
(use "NatDivRefl")
(simp "PosToNatTimes")
(use "NatDivTimes")
(use "NatDivRefl")
(use "NatGcdDiv0")
;; (cp)
(save "PosGcdTimesId0")

;; PosGcdTimesId1
(set-goal "all p,q PosGcd(q*p)p=p")
(assume "p" "q")
(simp "PosGcdComm")
(use "PosGcdTimesId0")
;; (cp)
(save "PosGcdTimesId1")

;; PosGcdLe0
(set-goal "all p,q PosGcd p q<=p")
(assume "p" "q")
(simp "<-" "PosToNatLe")
(simp "PosGcdToNatGcd")
(use "NatDivToLe")
(use "NatLtZeroPos")
(use "NatGcdDiv0")
;; (cp)
(save "PosGcdLe0")

;; PosGcdLe1
(set-goal "all p,q PosGcd p q<=q")
(assume "p" "q")
(simp "<-" "PosToNatLe")
(simp "PosGcdToNatGcd")
(use "NatDivToLe")
(use "NatLtZeroPos")
(use "NatGcdDiv1")
;; (cp)
(save "PosGcdLe1")

;; PosGcdToLinComb
(set-goal "all p0,p1(
     exl q q*p0=p1 ord 
     exl q q*p1=p0 ord 
     exd q0 exl q1 PosGcd p0 p1+q0*p0=q1*p1 ord 
     exd q0 exl q1 PosGcd p0 p1+q1*p1=q0*p0)")
(assert "all l,p0,p1(
     p0+p1<l ->
     exl q q*p0=p1 ord 
     exl q q*p1=p0 ord 
     exd q0 exl q1 PosGcd p0 p1+q0*p0=q1*p1 ord 
     exd q0 exl q1 PosGcd p0 p1+q1*p1=q0*p0)")
(ind)
(strip)
(intro 0)
(intro 0 (pt "1"))
(use "EfAtom")
(use 1)
(assume "n" 1)
(cases)
;; Case p0=1
 (assume  "p" 2)
 (intro 0)
 (intro 0 (pt "p"))
 (use "Truth")
;; Case p0=S_0...
 (assume "p0")
 (cases)
 ;; Case p1=1
  (assume 2)
  (intro 1)
  (intro 0)
  (intro 0 (pt "SZero p0"))
  (use "Truth")
 ;; Case p1=S_0...
  (ng)
  (assume "p1" 1)
  (use 1)
  (use "NatLtLeTrans" (pt "NatDouble(PosToNat(p0+p1))"))
  (simp "<-" "NatDoublePlusEq")
  (use "NatLtLeTrans" (pt "PosToNat(p0+p1)+1"))
  (use "Truth")
  (use "NatLeMonPlus")
  (use "Truth")
  (ng #t)
  (use "NatLtToSuccLe")
  (use "NatLtZeroPosToNat")
  (use "NatLtSuccToLe")
  (use 2)
 ;; Case p1=S_1
  (assume "p1" 2)
  (inst-with 1 (pt "p0") (pt "SOne p1") "?")
  ;; Inductionhypothesis Case 1
   (elim 3)
   (elim)
   (assume "p" 5)
   (ng)
   (simp "<-" 5)
   (simp "PosGcdTimesId0")
   (intro 1)
   (intro 1)
   (intro 0)
   (intro 0 (pt "p1"))
   (intro 0 (pt "p0"))
   (simp "PosTimesComm")
   (use "PosPlusComm")
  ;; Inductionhypothesis Case 2
   (elim)
   (drop 3 4)
   (elim)
   (assume "p" 6)
   (intro 1)
   (intro 0)
   (intro 0 (pt "SZero p"))
   (use 6)
  ;; Inductionhypothesis Case 3
   (elim)
   (elim)
   (assume "p2")
   (elim)
   (assume "p3" 8)
   (drop 3 4 5 6 7)
   (intro 1)
   (intro 1)
   (intro 0)
   (intro 0 (pt "(p1+1)*p2"))
   (intro 0 (pt "p3+p2*p0"))
   (simp (pf "(p3+p2*p0)*SOne p1=p3*SOne p1+p2*p0*SOne p1"))
   (simp "<-" 8)
   (simp "PosTimesPlusDistrLeft")
   (simp "PosTimesPlusDistrLeft")
   (simp "<-" "PosPlusAssoc")
   (simp (pf "p2*p0+p2*p0*SOne p1=p2*p0*SOne p1+p2*p0"))
   (simp (pf "p2*p0*SOne p1+p2*p0=SZero(p2*p0*p1)+SZero(p2*p0)"))
   (ng)
   (simp (pf "p1*p2*p0+p2*p0=p2*p0*p1+p2*p0"))
   (use "Truth")
   (simp (pf "p1*p2*p0=p2*p0*p1"))
   (use "Truth")
   (simp (pf "p1*p2=p2*p1"))
   (simp "<-" "PosTimesAssoc")
   (simp (pf "p1*p0=p0*p1"))
   (use "Truth")
   (use "PosTimesComm")
   (use "PosTimesComm")
   (use "PosEqTrans" (pt "SZero(p2*p0*p1)+(p2*p0+p2*p0)"))
   (simp "<-" "SZeroPosPlus")
   (simp "PosPlus2CompRule")
   (ng)
   (simp "<-" "PosPlusAssoc")
   (simp "<-" "SZeroPosPlus")
   (simp "PosPlus2CompRule")
   (use "Truth")
   (simp "<-" "SZeroPosPlus")
   (use "Truth")
   (use "PosPlusComm")
   (use "PosTimesPlusDistrLeft")
  ;; Inductionhypothesis Case 4
   (elim)
   (assume "p2")
   (elim)
   (assume "p3" 8)
   (intro 1)
   (intro 1)
   (intro 1)
   (intro 0 (pt "p1*p2+p2"))
   (intro 0 (pt "p3+p2*p0"))
   (drop 3 4 5 6 7)
   (ng)
   (simp "<-" "PosPlus2CompRule")
   (simp (pf "PosGcd p0(SOne p1)+(SZero(p3*p1)+SZero(p2*p0*p1))+p3=
	      PosGcd p0(SOne p1)+SZero(p3*p1)+p3+SZero(p2*p0*p1)"))
   (simp 8)
   (simp "PosPlusComm")
   (ng)
   (simp "<-" "SZeroPosPlus")
   (ng)
   (simp "PosPlusComm")
   (simp "PosTimesComm")
   (use "Truth")
   (ng)
   (use "PosEqTrans" (pt "PosGcd p0(SOne p1)+SZero(p3*p1)+(p3+SZero(p2*p0*p1))"))
   (simp (pf "p3+SZero(p2*p0*p1)=SZero(p2*p0*p1)+p3"))
   (use "PosEqTrans" (pt "PosGcd p0(SOne p1)+(SZero(p3*p1)+SZero(p2*p0*p1))+p3"))
   (use "Truth")
   (simp "PosPlusAssoc")
   (simp "PosPlusAssoc")
   (use "Truth")
   (use "PosPlusComm")
   (use "Truth")
   (use "NatLtLeTrans" (pt "PosToNat(SZero p0+SOne p1)"))
   (simp "PosToNatPlus")
   (simp "PosToNatPlus")
   (use "NatLtMonPlus1")
   (ng)
   (simp "<-" "NatDoublePlusEq")
   (simp (pf "p0=Zero+p0"))
   (use "NatLtMonPlus1")
   (use "NatLtZeroPos")
   (use "Truth")
   (use "Truth")
   (use "Truth")
   (use "NatLtSuccToLe")
   (use 2)
;; Case p0=S_1...
 (assume "p0")
 (cases)
 ;; Case p1=1
  (assume 1)
  (intro 1)
  (intro 0)
  (intro 0 (pt "SOne p0"))
  (use "Truth")
 ;; Case p1=S_0
  (assume "p1" 2)
  (inst-with 1 (pt "SOne p0") (pt "p1") "?")
  ;; Inductionhypothesis Case 1
   (elim 3)
   (assume 1)
   (by-assume 4 "q" 5)
   (intro 0)
   (simp "<-" 5)
   (intro 0 (pt "SZero q"))
   (use "Truth")
  ;; Inductionhypothesis Case 2
   (elim)
   (elim)
   (assume "q" 6)
   (ng)
   (simp "PosGcdComm")
   (simp "<-" 6)
   (intro 1)
   (intro 1)
   (intro 1)
   (intro 0 (pt "p1"))
   (intro 0 (pt "p0"))
   (simp "PosGcdTimesId0")
   (simp "PosTimesComm")
   (use "PosPlusComm")
  ;; Inductionhypothesis Case 3
   (elim)
   (elim)
   (assume "p3")
   (elim)
   (assume "p4" 8)
   (drop 3 4 5 6 7)
   (intro 1)
   (intro 1)
   (intro 0)
   (intro 0 (pt "p3+p4*p1"))
   (intro 0 (pt "p4*p0+p4"))
   (simp "PosTimesPlusDistrLeft")
   (simp "PosPlusAssoc")
   (ng)
   (simp 8)
   (simp "PosPlusComm")
   (simp "PosPlusAssoc")
   (simp "<-" "SZeroPosPlus")
   (simp "PosPlus2CompRule")
   (ng)
   (simp "<-" "PosTimesAssoc")
   (simp (pf "p1*p0=p0*p1"))
   (use "PosPlusComm")
   (use "PosTimesComm")
  ;; Inductionhypothesis Case 4
   (elim)
   (assume "p2")
   (elim)
   (assume "p3" 8)
   (drop 3 4 5 6 7)
   (intro 1)
   (intro 1)
   (intro 1)
   (intro 0 (pt "p2+p3*p1"))
   (intro 0 (pt "p3*p0+p3"))
   (ng)
   (simp "<-" "PosPlus2CompRule")
   (simp (pf "SZero(p3*p0*p1)+SZero(p3*p1)=SZero(p3*p1)+SZero(p3*p0*p1)"))
   (simp "SZeroPosPlus")
   (simp "PosPlusAssoc")
   (simp "PosPlusAssoc")
   (simp 8)
   (simp (pf "SZero(p2*p0)+p2+p3*p1+SZero(p3*p0*p1)=SZero(p2*p0)+SZero(p3*p0*p1)+p2+p3*p1"))
   (simp "PosPlus2CompRule")
   (simp "<-" "PosTimesAssoc")
   (simp (pf "p0*p1=p1*p0"))
   (use "Truth")
   (use "PosTimesComm")
   (use "PosEqTrans" (pt "SZero(p2*p0)+((p2+p3*p1)+SZero(p3*p0*p1))"))
   (use "Truth")
   (simp (pf "p2+p3*p1+SZero(p3*p0*p1)=SZero(p3*p0*p1) +(p2+p3*p1)"))
   (use "Truth")
   (use "PosPlusComm")
   (use "PosPlusComm")
   (use "NatLtLeTrans" (pt "PosToNat(SOne p0+SZero p1)"))
   (simp "PosToNatPlus")
   (simp "PosToNatPlus")
   (use "NatLtMonPlus2")
   (use "Truth")
   (ng)
   (use "NatLeLtTrans" (pt "p1+Zero"))
   (use "Truth")
   (simp "<-" "NatDoublePlusEq")
   (use "NatLtMonPlus2")
   (use "Truth")
   (use "NatLtZeroPos")
   (use "NatLtSuccToLe")
   (use 2)
 ;; Case p1=S_1...
  (assume "p1" 2)
  (simp "PosGcd6CompRule")
  (cases (pt "p0=p1"))
  ;; Case p0=p1
   (assume 3)
   (intro 0)
   (simp 3)
   (intro 0 (pt "1"))
   (use "Truth")
   (assume 3)
  (cases (pt "p0<p1"))
  ;; Case p0 < p1
  (simp "IfFalse")
   (simp "IfTrue")
   (assume 4)
   (inst-with 1 (pt "SOne p0") (pt "SZero p1--SZero p0") "?")
   ;; Inductionhypothesis Case 1
    (elim 5)
    (elim)
    (assume "q" 7)
    (intro 0)
    (intro 0 (pt "q+1"))
    (simp "PosTimesPlusDistrLeft")
    (simp 7)
    (ng)
    (use "PosMinusPlusEq")
    (use 4)
   ;; Inductionhypothesis Case 2
    (elim)
    (elim)
    (assume "q" 8)
    (intro 0)
    (intro 0 (pt "1"))
    (use "EfAtom")
    (use 8)
   ;; Inductionhypothesis Case 3
    (elim)
    (elim)
    (assume "p2")
    (elim)
    (assume "p3" 10)
    (simphyp 10 (pf "SZero p1--SZero p0=SOne p1--SOne p0"))
    (drop 5 6 7 8 9 10)
    (intro 1)
    (intro 1)
    (intro 0)
    (intro 0 (pt "p2+p3"))
    (intro 0 (pt "p3"))
    (simp "PosTimesPlusDistrLeft")
    (simp "PosPlusAssoc")
    (simphyp 11
      (pf "PosGcd(SOne p0)(SOne p1--SOne p0)=PosGcd(SOne p0)(p1--p0)"))
    (simp 12)
    (ng)
    (simp "<-" "PosTimesPlusDistr")
    (simp "PosMinusPlusEq")
    (use "Truth")
    (use 4)
    (use "Truth")
    (use "Truth")
   ;; Inductionhypothesis Case 4
    (elim)
    (assume "p2")
    (elim)
    (assume "p3" 10)
    (simphyp 10
      (pf "PosGcd(SOne p0)(SZero p1--SZero p0)=PosGcd(SOne p0)(p1--p0)"))
    (drop 5 6 7 8 9 10)
    (intro 1)
    (intro 1)
    (intro 1)
    (intro 0 (pt "p2+p3"))
    (intro 0 (pt "p3"))
    (simp (pf "SOne p1=SOne p1--SOne p0+SOne p0"))
    (simp "PosTimesPlusDistr")
    (simp "PosPlusAssoc")
    (simp (pf "SOne p1--SOne p0=SZero p1--SZero p0"))
    (simp 11)
    (use "PosEqSym")
    (use "PosTimesPlusDistrLeft")
    (use "Truth")
    (use "PosEqSym")
    (use "PosMinusPlusEq")
    (use 4)
    (use "Truth")
    (use "NatLtLeTrans" (pt "PosToNat(SOne p0)+PosToNat(SOne p1)"))
    (simp "PosToNatPlus")
    (use "NatLtMonPlus2")
    (use "Truth")
    (ng)
    (use "NatLeToLtSucc")
    (simp "NatDoubleLe")
    (simp "PosToNatLe")
    (use "Truth")
    (use "NatLtSuccToLe")
    (simp "<-" "PosToNatPlus")
    (use 2)
  ;; Case p0<p1 -> F
   (assume 3)
   ;; Proof p0<p1
    (assert "p1<p0")
    (simp "<-" "PosToNatLt")
    (use "NatLeNotEqToLt")
    (use "NatNotLtToLe")
    (simp "PosToNatLt")
    (use 4)
    (assume 5)
    (use 3)
    (use "PosToNatInj")
    (use "NatEqSym")
    (use 5)
    (assume 5)
    (simp "IfFalse")
    (simp "IfFalse")
   (inst-with 1 (pt "SZero p0--SZero p1") (pt "SOne p1") "?")
   ;; Inductionhypothesis Case 1
    (elim 6)
    (elim)
    (assume "q" 8)
    (intro 0)
    (intro 0 (pt "1"))
    (use "EfAtom")
    (use 8)
   ;; Inductionhypothesis Case 2
    (elim)
    (elim)
    (assume "q" 9)
    (intro 1)
    (intro 0)
    (intro 0 (pt "q+1"))
    (simp "PosTimesPlusDistrLeft")
    (simp 9)
    (ng)
    (use "PosMinusPlusEq")
    (use 5)
   ;; Inductionhypothesis Case 3
    (elim)
    (elim)
    (assume "p2")
    (elim)
    (assume "p3" 11)
    (drop 6 7 8 9 10)
    (intro 1)
    (intro 1)
    (intro 0)
    (intro 0 (pt "p2"))
    (intro 0 (pt "p3+p2"))
    (simp (pf "PosGcd(p0--p1)(SOne p1)=PosGcd(SZero p0--SZero p1)(SOne p1)"))
    (simp (pf "SOne p0=SOne p0--SOne p1+SOne p1"))
    (simp "PosTimesPlusDistr")
    (simp "PosPlusAssoc")
    (simp (pf "SOne p0--SOne p1=SZero p0--SZero p1"))
    (simp 11)
    (use "PosEqSym")
    (use "PosTimesPlusDistrLeft")
    (use "Truth")
    (use "PosEqSym")
    (use "PosMinusPlusEq")
    (use 5)
    (use "Truth")
   ;; Inductionhypothesis Case 4
    (elim)
    (assume "p2")
    (elim)
    (assume "p3" 11)
    (intro 1)
    (intro 1)
    (intro 1)
    (intro 0 (pt "p2"))
    (intro 0 (pt "p3+p2"))
    (simphyp 11 (pf "SZero p0--SZero p1=SOne p0--SOne p1"))
    (drop 6 7 8 9 10 11)
    (simp (pf "PosGcd(p0--p1)(SOne p1)=PosGcd(SOne p0--SOne p1)(SOne p1)"))
    (simp "PosTimesPlusDistrLeft")
    (simp "PosPlusAssoc")
    (simp 12)
    (simp "<-" "PosTimesPlusDistr")
    (simp "PosMinusPlusEq")
    (use "Truth")
    (use 5)
    (use "Truth")
    (use "Truth")
    (use "NatLtLeTrans" (pt "PosToNat(SOne p0)+PosToNat(SOne p1)"))
    (simp "PosToNatPlus")
    (use "NatLtMonPlus1")
    (simp "PosToNatLt")
    (use "Truth")
    (use "Truth")
    (use "NatLtSuccToLe")
    (simp "<-" "PosToNatPlus")
    (use 2)
;; General Case:
(strip)
(use 1 (pt "p0+p1+Succ Zero"))
(use "Truth")
;; (cp)
(save "PosGcdToLinComb")

(define etermStein (proof-to-extracted-term))

;; Extended Euclidean Algorithm
;; ============================

(add-program-constant "RoundDiv" (py "pos=>pos=>pos"))
(add-computation-rules
 "RoundDiv p q" "PosMonMax ([q0]q0*q<=p) (Succ(PosLog p--PosLog q))")

(set-totality-goal "RoundDiv")
(fold-alltotal)
(assume "p")
(fold-alltotal)
(assume "p0")
(use "TotalVar")
;; (cp)
(save-totality)

(add-program-constant "EuclidGcd" (py "pos=>pos=>pos"))
(add-computation-rules
 "EuclidGcd p q"
 "[if (q<=p) 
      (([q0][if (q0*q=p) q (EuclidGcd (p--q0*q) q)])(RoundDiv p q))
      (([q0][if (q0*p=q) p (EuclidGcd (q--q0*p) p)])(RoundDiv q p))]")

;;RoundDivProp0
(set-goal "all p,q(q<=p -> (RoundDiv p q)*q<= p)")
(assume "p" "q" 1)
(simp "RoundDiv0CompRule")
(use-with "PosMonMaxProp"
 (pt "[q0]q0*q<=p") (pt "Succ(PosLog p--PosLog q)") "?")
(use 1)
;; (cp)
(save "RoundDivProp0")

;; RoundDivProp1
(set-goal "all p,q(q<=p -> RoundDiv p q*q=p orb p--RoundDiv p q*q<q)")
(assume "p" "q" 1)
(cases (pt "RoundDiv p q*q=p"))
(assume 1)
(use "Truth")
(assume 2)
(simp "OrConst2CompRule")
(use "PosNotLeToLt")
(assume 1)
(inst-with "PosMonMaxNegProp"
 (pt "[q0]q0*q<=p") (pt "Succ(PosLog p--PosLog q)") "?" "?"
 (pt "RoundDiv p q+1") "?")
(bpe-ng)
(assert "(RoundDiv p q+1)*q<=p")
(simp "PosTimesPlusDistrLeft")
(use "PosLeTrans" (pt "RoundDiv p q*q+(p--RoundDiv p q*q)"))
(use "PosLeMonPlus")
(use "Truth")
(use 3)
(simp "PosPlusComm")
(simp "PosMinusPlusEq")
(use "Truth")
(use "PosLeNotEqToLt")
(use "RoundDivProp0")
(use 1)
(use 2)
(assume 5)
(simphyp 4 5)
(use 6)
(bpe-ng)
(cases (pt "(2**Succ(PosLog p--PosLog q))*q<=p"))
(assume 4)
(assert "p<p")
(use "PosLtLeTrans" (pt "2**Succ(PosLog p)"))
(use "PosLtExpTwoSuccLog")
(simp (pf "2**Succ(PosLog p) =2**Succ(PosLog p--PosLog q)*2**(PosLog q)"))
(use "PosLeTrans" (pt "2**Succ(PosLog p--PosLog q)*q"))
(use "PosLeMonTimes")
(use "Truth")
(use "PosLeExpTwoLog")
(use 4)
(simp "PosExpTwoNatPlus")
(ng #t)
(simp "NatMinusPlus")
(use "Truth")
(use "PosLeMonLog")
(use 1)
(search)
(search)
(assume "p0" "q0" 4 5)
(use "PosLeTrans" (pt "q0*q"))
(use "PosLeMonTimes")
(use 4)
(use "Truth")
(use 5)
(use "Truth")
;; (cp)
(save "RoundDivProp1")

;;NatGcdPlusMultiR
(set-goal "all l,n,m NatGcd n(l*n+m)=NatGcd n m")
(ind)
(strip)
(use "Truth")
(assume "l" 1)
(ng #t)
(assume "n" "m")
(inst-with 1 (pt "n") (pt "n+m"))
(ng)
(simp 2)
(cases (pt "n"))
(search)
(assume "n0" 3)
(simp (pf "Succ n0+m= Succ(n0+m)"))
(simp "NatGcd2CompRule")
(cases (pt "m"))
(search)
(assume "m0" 4)
(simp (pf "n0<n0+Succ m0"))
(simp "IfTrue")
(simp (pf "n0+Succ m0--n0=Succ m0"))
(use "Truth")
(simp "NatPlusComm")
(simp "<-" "NatPlusMinusAssoc")
(use "Truth")
(use "Truth")
(use "NatLeLtTrans" (pt "n0+Zero"))
(use "Truth")
(use "NatLtMonPlus2")
(use "Truth")
(use "Truth")
(use "Truth")
;; (cp)
(save "NatGcdPlusMultiR")

;;NatGcdPlusMultiL
(set-goal "all l,n,m NatGcd (l*n+m) n =NatGcd m n")
(strip)
(simp "NatGcdComm")
(simp "NatGcdPlusMultiR")
(use "NatGcdComm")
;; (cp)
(save "NatGcdPlusMultiL")

;; PosGcdPlusMultiR
(set-goal "all q,p0,p1 PosGcd p0(q*p0+p1)=PosGcd p0 p1")
(strip)
(use "PosToNatInj")
(simp "PosGcdToNatGcd")
(simp "PosGcdToNatGcd")
(simp "PosToNatPlus")
(simp "PosToNatTimes")
(use "NatGcdPlusMultiR")
;; (cp)
(save "PosGcdPlusMultiR")

;;PosGcdPlusMultiL
(set-goal "all q,p0,p1 PosGcd (q*p0+p1) p0=PosGcd p1 p0")
(strip)
(use "PosToNatInj")
(simp "PosGcdToNatGcd")
(simp "PosGcdToNatGcd")
(simp "PosToNatPlus")
(simp "PosToNatTimes")
(use "NatGcdPlusMultiL")
;; (cp)
(save "PosGcdPlusMultiL")

;; PosGcdToLinCombEuclid
(set-goal "all p0,p1(
     exl q q*p0=p1 ord 
     exl q q*p1=p0 ord 
     exd q0 exl q1 PosGcd p0 p1+q0*p0=q1*p1 ord 
     exd q0 exl q1 PosGcd p0 p1+q1*p1=q0*p0)")
(assert "all l,p0,p1(
     p0+p1<l -> p0<=p1 ->
     exl q q*p0=p1 ord 
     exl q q*p1=p0 ord 
     exd q0 exl q1 PosGcd p0 p1+q0*p0=q1*p1 ord 
     exd q0 exl q1 PosGcd p0 p1+q1*p1=q0*p0)")
(ind)
;; Case l=0
(strip)
(intro 0)
(intro 0 (pt "1"))
(use "EfAtom")
(use 1)
;; Case l=S...
(assume "l" 1 "p0" "p1" 2 3)
(inst-with "RoundDivProp1" (pt "p1") (pt "p0") 3)
(cases (pt "RoundDiv p1 p0*p0=p1"))
;; Case: p1 is a multiple of p0, i.e. the reminder of the devision is zero.
(assume 5)
(intro 0)
(intro 0 (pt "RoundDiv p1 p0"))
(use 5)
;; Case: there is a proper reminder by dividing p1 by p0
 (assume 5)
 (simphyp 4 5)
 (simphyp 6 "OrConst2CompRule")
 (drop 6)
 ;; The following formula is often needed:
  (assert "RoundDiv p1 p0*p0<p1")
  (use "PosLeNotEqToLt")
  (use "RoundDivProp0")
  (use 3)
  (use 5)
  (assume 8)
 ;; Applying the induction hypothesis to the reminder and p0
 (inst-with 1 (pt "p1--RoundDiv p1 p0*p0") (pt "p0")  "?" "?")
 ;; Considering the four cases of the induction hypothesis
 (elim 9)
 ;; Case 1
  (elim)
  (assume "q" 11)
  (intro 1)
  (intro 1)
  (intro 0)
  (intro 0 (pt "RoundDiv p1 p0"))
  (intro 0 (pt "1"))
  (assert "PosGcd p0 p1=p1--RoundDiv p1 p0*p0")
  (use "PosEqTrans" (pt "PosGcd p0 (p1--RoundDiv p1 p0*p0+RoundDiv p1 p0*p0)"))
  (simp "PosMinusPlusEq")
  (use "Truth")
  (use 8)
  (simp "PosPlusComm")
  (simp "PosGcdPlusMultiR")
  (simp (pf "PosGcd p0(p1--RoundDiv p1 p0*p0)=
             PosGcd (q*(p1--RoundDiv p1 p0*p0))(p1--RoundDiv p1 p0*p0)"))
  (use "PosGcdTimesId1")
  (simp 11)
  (use "Truth")
  (assume 12)
  (simp 12)
  (use "PosMinusPlusEq")
  (use 8)
 ;; Case 2
  (elim)
  (elim)
  (assume "q" 12)
  (intro 0)
  (intro 0 (pt "q+RoundDiv p1 p0"))
  (simp "PosTimesPlusDistrLeft")
  (simp 12)
  (use "PosMinusPlusEq")
  (use 8)
 ;; Case 3
  (elim)
  (elim)
  (assume "q0")
  (elim)
  (assume "q1" 14)
  (drop  9 10 11 12 13)
  (intro 1)
  (intro 1)
  (intro 1)
  (intro 0 (pt "q1+q0*RoundDiv p1 p0"))
  (intro 0 (pt "q0"))
  (simp "PosTimesPlusDistrLeft")
  (simp "<-" 14)
  (simp "PosTimesMinusDistr")
  (simp "<-" "PosPlusAssoc")
  (simp "PosTimesAssoc")
  (simp "PosMinusPlusEq")
  (simp (pf "PosGcd p0 p1= PosGcd(p1--RoundDiv p1 p0*p0)p0"))
  (use "Truth")
  (simp "PosGcdComm")
  (use "PosEqSym")
  (simp "<-" "PosGcdPlusMultiL" (pt "RoundDiv p1 p0"))
  (simp "PosPlusComm")
  (simp "PosMinusPlusEq")
  (use "Truth")
  (use 8)
  (simp "<-" "PosTimesAssoc")
  (use "PosLeLtMonTimes")
  (use "Truth")
  (use 8)
  (use 8)
 ;; Case 4
  (elim)
  (assume "q0")
  (elim)
  (assume "q1" 14)
  (drop 9 10 11 12 13)
  (intro 1)
  (intro 1)
  (intro 0)
  (intro 0 (pt "q1+q0*RoundDiv p1 p0"))
  (intro 0 (pt "q0"))
  (simp (pf "PosGcd p0 p1= PosGcd(p1--RoundDiv p1 p0*p0)p0"))
  (simp "PosTimesPlusDistrLeft")
  (simp "PosPlusAssoc")
  (simp 14)
  (simp "PosTimesMinusDistr")
  (simp "PosTimesAssoc")
  (use "PosMinusPlusEq")
  (simp "<-" "PosTimesAssoc")
  (use "PosLeLtMonTimes")
  (use "Truth")
  (use 8)
  (use 8)
  (use "PosEqSym")
  (simp "<-" "PosGcdPlusMultiL" (pt "RoundDiv p1 p0"))
  (simp "PosPlusComm")
  (simp "PosMinusPlusEq")
  (use "PosGcdComm")
  (use 8)
  (simp "PosToNatPlus")
  (use "NatLtLeTrans" (pt "NatPlus(PosToNat p0)(PosToNat p0)"))
  (use "NatLtMonPlus1")
  (simp "<-" "NatToPosLt")
  (simp "NatToPosToNatId")
  (simp "NatToPosToNatId")
  (use 7)
  (use "NatLtZeroPos")
  (use "NatLtZeroPos")
  (use "Truth")
  (use "NatLtSuccToLe")
  (use "NatLeLtTrans" (pt "NatPlus(PosToNat p0)(PosToNat p1)"))
  (use "NatLeMonPlus")
  (use "Truth")
  (simp "PosToNatLe")
  (use 3)
  (simp "<-" "PosToNatPlus")
  (use 2)
  (use "PosLtToLe")
  (use 7)
;; General Case
(assume 1)
(strip)
(cases (pt "p0<=p1"))
(assume 2)
(use 1 (pt "PosToNat(p0+p1)+1"))
(use "Truth")
(use 2)
(assume 2)
(simp "PosGcdComm")
(inst-with 1 (pt "PosToNat(p1+p0)+1") (pt "p1") (pt "p0") "?" "?")
(elim 3)
(assume 4)
(intro 1)
(intro 0)
(use 4)
(elim)
(assume 5)
(intro 0)
(use 5)
(elim)
(elim)
(assume "q0")
(elim)
(assume "q1" 6)
(intro 1)
(intro 1)
(intro 1)
(intro 0 (pt "q1"))
(intro 0 (pt "q0"))
(use 8)
(elim)
(assume "q0")
(elim)
(assume "q1" 8)
(intro 1)
(intro 1)
(intro 0)
(intro 0 (pt "q1"))
(intro 0 (pt "q0"))
(use 8)
(use "Truth")
(use "PosLtToLe")
(use "PosNotLeToLt")
(use 2)
;; (cp)
(save "PosGcdToLinCombEuclid")

(define etermEuclid (proof-to-extracted-term))

;; PosDiv
;; ======

(add-program-constant "PosDiv" (py "pos=>pos=>boole"))
(add-computation-rules
 "PosDiv p q" "PosGcd p q=p")

(set-totality-goal "PosDiv")
(fold-alltotal)
(assume "p")
(fold-alltotal)
(assume "q")
(simp "PosDiv0CompRule")
(use "TotalVar")
;; (cp)
(save-totality)

;; PosDivToLe
(set-goal "all p,q(PosDiv p q -> p<=q)")
(assume "p" "q" 1)
(ng)
(simp "<-" 1)
(use "PosGcdLe1")
;; (cp)
(save "PosDivToLe")

;; PosDivToNatDiv
(set-goal "all p,q(PosDiv p q -> NatDiv(PosToNat p)(PosToNat q))")
(assume "p" "q")
(simp "PosDiv0CompRule")
(assume 1)
(simp "<-" 1)
(simp "PosGcdToNatGcd")
(use "NatGcdDiv1")
;; (cp)
(save "PosDivToNatDiv")

;; PosProdToDiv
(set-goal "all p,q,p0(p0*p=q -> PosDiv p q)")
(strip)
(simp "<-" 1)
(use "PosGcdTimesId0")
;; (cp)
(save "PosProdToDiv")

;; NatDivToPosDiv
(set-goal "all n,m(
 Zero<n -> Zero<m -> NatDiv n m -> PosDiv(NatToPos n)(NatToPos m))")
(assume "n" "m" 1 2 3)
(inst-with "NatDivToProd" (pt "n") (pt "m") 3)
(by-assume 4 "l" 5)
(use "PosProdToDiv" (pt "NatToPos l"))
(simp "<-" "NatToPosTimes")
(simp 5)
(use "Truth")
(use 1)
(use "NatNotLeToLt")
(assume 1)
(simphyp 5 6)
(ng)
(simphyp 2 7)
(use 8)
;; (cp)
(save "NatDivToPosDiv")

;; PosDivToProd
(set-goal "all p,q(PosDiv p q -> exl p0 p0*p=q)")
(assert "all l,p,q(p+q<l -> PosDiv p q -> exl p0 p0*p=q)")
(ind)
(strip)
(intro 0 (pt "1"))
(use "EfAtom")
(use 1)
(assume "l" 1)
(cases)
(assume "q" 1 2)
(intro 0 (pt "q"))
(use "Truth")
(assume "p")
(cases)
(strip)
(intro 0 (pt "1"))
(use "EfAtom")
(use 3)
(assume "q" 1)
(ng #t)
(use 1)
(use "NatLtLeTrans" (pt "PosToNat(SZero p)+PosToNat(SZero q)"))
(simp "PosToNatPlus")
(use "NatLtMonPlus1")
(simp "PosToNatLt")
(use "Truth")
(simp "PosToNatLe")
(use "Truth")
(simp "<-" "PosToNatPlus")
(use "NatLtSuccToLe")
(use 2)
(assume "q" 2 3)
(ng)
(intro 0 (pt "1"))
(assert "p<p")
(simp "PosLtLeTrans" (pt "PosGcd p(SOne q)"))
(use "Truth")
(use "PosGcdLe0")
(simp 3)
(use "Truth")
(assume 4)
(use 4)
(assume "p")
(cases)
(assume 2 3)
(intro 0 (pt "1"))
(use "EfAtom")
(use 3)
(assume "q" 1 2)
(ng 3)
(inst-with 1 (pt "SOne p") (pt "q") "?" 3)
(by-assume 4 "p0" 5)
(intro 0 (pt "SZero p0"))
(use 5)
(use "NatLtLeTrans" (pt "PosToNat(SOne p)+PosToNat(SZero q)"))
(simp "PosToNatPlus")
(use "NatLtMonPlus2")
(use "Truth")
(simp "PosToNatLt")
(use "Truth")
(simp "<-" "PosToNatPlus")
(use "NatLtSuccToLe")
(use 2)
(assume "q" 2)
(ng #t)
(cases (pt "p=q"))
(simp "IfTrue")
(strip)
(simp 3)
(intro 0 (pt "1"))
(use "Truth")
(assume 3)
(simp "IfFalse")
(cases (pt "p<q"))
(simp "IfTrue")
(assume 4 5)
(inst-with 1 (pt "SOne p") (pt "q--p") "?" 5)
(by-assume 6 "p0" 7)
(intro 0 (pt "SOne p0"))
(ng)
(simp "<-" "PosPlusAssoc")
(simp (pf "p+p0=p0+p"))
(simp "PosPlusAssoc")
(simp 7)
(use "PosMinusPlusEq")
(use 4)
(use "PosPlusComm")
(use "NatLtLeTrans" (pt "PosToNat(SOne p) +PosToNat(SOne q)"))
(simp "PosToNatPlus")
(use "NatLtMonPlus2")
(use "Truth")
(use "NatLeLtTrans" (pt "PosToNat q"))
(simp "PosToNatLe")
(use "Truth")
(simp "PosToNatLt")
(use "PosLtTrans" (pt "SZero q"))
(use "Truth")
(use "Truth")
(simp "<-" "PosToNatPlus")
(use "NatLtSuccToLe")
(use 2)
(simp "IfFalse")
(assume 4 5)
(intro 0 (pt "1"))
(use "EfAtom")
(assert "p<p")
(use "PosLtLeTrans" (pt "SOne p"))
(use "PosLtTrans" (pt "SZero p"))
(use "Truth")
(use "Truth")
(simp "<-" 5)
(use "PosLeTrans" (pt "p--q"))
(use "PosGcdLe0")
(use "Truth")
(assume 6)
(use 6)
(strip)
(use 1 (pt "Succ(PosToNat(p+q))"))
(use "Truth")
(use 2)
;; (cp)
(save "PosDivToProd")

;; PosDivTrans
(set-goal "all p0,p1,p2(PosDiv p0 p1 -> PosDiv p1 p2 -> PosDiv p0 p2)")
(strip)
(inst-with "PosDivToProd" (pt "p0") (pt "p1") 1)
(by-assume 3 "q0" 4)
(inst-with "PosDivToProd" (pt "p1") (pt "p2") 2)
(by-assume 5 "q1" 6)
(use "PosProdToDiv" (pt "q1*q0"))
(simp "<-" "PosTimesAssoc")
(simp 4)
(use 6)
;; (cp)
(save "PosDivTrans")

;; PosDivAntiSym
(set-goal "all p,q(PosDiv p q -> PosDiv q p -> p=q)")
(strip)
(use "PosLeAntiSym")
(use "PosDivToLe")
(use 1)
(use "PosDivToLe")
(use 2)
;; (cp)
(save "PosDivAntiSym")

;; PosDivRefl
(set-goal "all p(PosDiv p p)")
(assume "p")
(use "PosProdToDiv" (pt "1"))
(use "Truth")
;; (cp)
(save "PosDivRefl")

;; PosOneDivToOne
(set-goal "all p (PosDiv p 1 -> p=1)")
(cases)
(auto)
;; (cp)
(save "PosOneDivToOne")

;; PosDivPlus
(set-goal "all p,q0,q1(PosDiv p q0 -> PosDiv p q1 -> PosDiv p(q0+q1))")
(strip)
(inst-with "PosDivToProd" (pt "p") (pt "q0") 1)
(inst-with "PosDivToProd" (pt "p") (pt "q1") 2)
(by-assume 3 "p0" 5)
(by-assume 4 "p1" 6)
(use "PosProdToDiv" (pt "p0+p1"))
(simp "PosTimesPlusDistrLeft")
(simp 5)
(simp 6)
(use "Truth")
;; (cp)
(save "PosDivPlus")

;;PosDivTimes
(set-goal "all p,q,q0(PosDiv p q -> PosDiv p(q0*q))")
(strip)
(inst-with "PosDivToProd" (pt "p") (pt "q") 1)
(by-assume 2 "p0" 3)
(use "PosProdToDiv" (pt "q0*p0"))
(simp "<-" "PosTimesAssoc")
(simp 3)
(use "Truth")
;; (cp)
(save "PosDivTimes")

;; PosDivPlusRev
(set-goal "all p,q0,q1(PosDiv p q0 -> PosDiv p(q0+q1) -> PosDiv p q1)")
(strip)
(inst-with "PosDivToProd" (pt "p") (pt "q0") 1)
(inst-with "PosDivToProd" (pt "p") (pt "q0+q1") 2)
(by-assume 3 "p0" 5)
(by-assume 4 "p1" 6)
(use "PosProdToDiv" (pt "p1--p0"))
(simp "PosTimesMinusDistrLeft")
(simp 6)
(simp 5)
(use "Truth")
(use "PosNotLeToLt")
(assume 7)
(assert "q0+q1<=q0")
(simp "<-" 6)
(simp "<-" 5)
(simp "PosLeMonTimes")
(use "Truth")
(use "Truth")
(use 7)
(assume 8)
(use 8)
;; (cp)
(save "PosDivPlusRev")

;; PosGcdDiv0
(set-goal "all p,q PosDiv(PosGcd p q) p")
(assume "p" "q")
(simp "<-" "NatToPosToNatId")
(simp "PosGcdToNatGcd")
(use "PosDivTrans" (pt "NatToPos(PosToNat p)"))
(use "NatDivToPosDiv")
(simp "NatGcdToPosGcd")
(use "NatLtZeroPos")
(use "NatLtZeroPos")
(use "NatLtZeroPos")
(use "NatLtZeroPos")
(use "NatGcdDiv0")
(simp "NatToPosToNatId")
(use "PosDivRefl")
;; (cp)
(save "PosGcdDiv0")

;; PosGcdDiv1
(set-goal "all p,q PosDiv(PosGcd q p) p")
(assume "p" "q")
(simp "PosGcdComm")
(use "PosGcdDiv0")
;; (cp)
(save "PosGcdDiv1")

;; PosDivGcd
(set-goal
 "all p1,p2,q(PosDiv q p1 -> PosDiv q p2 -> PosDiv q(PosGcd p1 p2))")
(strip)
(simp "<-""NatToPosToNatId")
(simp "<-" (pf "NatToPos(PosToNat (PosGcd p1 p2))=(PosGcd p1 p2)"))
(simp "<-" (pf "NatToPos(PosToNat p1)=p1"))
(simp "<-" (pf "NatToPos(PosToNat p2)=p2"))
(simp "PosGcdToNatGcd")
(use "NatDivToPosDiv")
(use "NatLtZeroPos")
(simp "<-" "PosGcdToNatGcd")
(use "NatLtZeroPos")
(use "NatDivGcd")
(use "PosDivToNatDiv")
(simp "NatToPosToNatId")
(use 1)
(simp "NatToPosToNatId")
(use "PosDivToNatDiv")
(use 2)
(use "NatToPosToNatId")
(use "NatToPosToNatId")
(use "NatToPosToNatId")
;; (cp)
(save "PosDivGcd")

;; To generate a Haskell file, please run the uncommented code below and
;; replace "/path/to/Haskell/file/" with the desired path for the Haskell file.

;; (terms-to-haskell-program
;; "/path/to/Haskell/file/gcd_pos.hs"
;; (list (list (pt "EuclidGcd") "euclid")
;;       (list (pt "PosGcd") "stein")
;;       (list etermEuclid "extEuclid")
;;       (list etermStein "extStein")))
