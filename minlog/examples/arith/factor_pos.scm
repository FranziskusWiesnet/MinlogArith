;; 2026-02-11.  factor_pos.scm.  Written by Franziskus Wiesnet.

;; (load "~/git/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (exload "arith/gcd_nat.scm")
;; (exload "arith/prime_nat.scm")
;; (libload "pos.scm")
;; (exload "arith/gcd_pos.scm")
;; (exload "arith/prime_pos.scm")
;; (set! COMMENT-FLAG #t)


;; Fast Sqrt
;; =========

(add-program-constant "FastSqrt" (py "pos=>pos"))
(add-computation-rules
 "FastSqrt 1" "1"
 "FastSqrt (SZero 1)" "1"
 "FastSqrt (SOne 1)" "1"
 "FastSqrt (SZero (SZero p))" "([q] [if ((SZero (SZero p)) < (SOne q)*(SOne q))  (SZero q) (SOne q)])(FastSqrt p)"
 "FastSqrt (SZero (SOne p))"  "([q] [if ((SZero (SOne p))  < (SOne q)*(SOne q))  (SZero q) (SOne q)])(FastSqrt p)"
 "FastSqrt (SOne (SZero p))"  "([q] [if ((SOne (SZero p))  < (SOne q)*(SOne q))  (SZero q) (SOne q)])(FastSqrt p)"
 "FastSqrt (SOne (SOne p))"   "([q] [if ((SOne (SOne p))   < (SOne q)*(SOne q))  (SZero q) (SOne q)])(FastSqrt p)"
 )

(set-totality-goal "FastSqrt")
(fold-alltotal)
(assert "all p (TotalPos(FastSqrt p) andi TotalPos(FastSqrt (SZero p)) andi TotalPos(FastSqrt (SOne p)))")
(ind)
(split)
(use "TotalVar")
(split)
(use "TotalVar")
(use "TotalVar")
(assume "p" 1)
(split)
(use 1)
(split)
(simp "FastSqrt3CompRule")
(bpe-ng)
(use "BooleIfTotal")
(use "PosLtTotal")
(use "TotalVar")
(use "PosTimesTotal")
(use "TotalPosSOne")
(use 1)
(use "TotalPosSOne")
(use 1)
(use "TotalPosSZero")
(use 1)
(use "TotalPosSOne")
(use 1)
(simp "FastSqrt5CompRule")
(bpe-ng)
(use "BooleIfTotal")
(use "PosLtTotal")
(use "TotalVar")
(use "PosTimesTotal")
(use "TotalPosSOne")
(use 1)
(use "TotalPosSOne")
(use 1)
(use "TotalPosSZero")
(use 1)
(use "TotalPosSOne")
(use 1)
(assume "p" 1)
(split)
(use 1)
(split)
(simp "FastSqrt4CompRule")
(bpe-ng)
(use "BooleIfTotal")
(use "PosLtTotal")
(use "TotalVar")
(use "PosTimesTotal")
(use "TotalPosSOne")
(use 1)
(use "TotalPosSOne")
(use 1)
(use "TotalPosSZero")
(use 1)
(use "TotalPosSOne")
(use 1)
(simp "FastSqrt6CompRule")
(bpe-ng)
(use "BooleIfTotal")
(use "PosLtTotal")
(use "TotalVar")
(use "PosTimesTotal")
(use "TotalPosSOne")
(use 1)
(use "TotalPosSOne")
(use 1)
(use "TotalPosSZero")
(use 1)
(use "TotalPosSOne")
(use 1)
(assume 1 "p")
(use 1)
;;(cp)
(save-totality)

;;PosSZeroLtToSOneLe
(set-goal "all p,q(SZero q < p -> SOne q <= p)")
(ind)
(auto)
;;(cp)
(save "PosSZeroLtToSOneLe")

;;PosSquareFastSqrtUpBound
(set-goal "all p (FastSqrt p)*(FastSqrt p)<= p")
(assert "all p(
     FastSqrt p*FastSqrt p<=p andnc 
     FastSqrt(SZero p)*FastSqrt(SZero p)<=SZero p andnc 
     FastSqrt(SOne p)*FastSqrt(SOne p)<=SOne p)")
(ind)
(split)
(use "Truth")
(split)
(use "Truth")
(use "Truth")
(assume "p" 1)
(split)
(use 1)
(split)
(simp "FastSqrt3CompRule")
(bpe-ng)
(cases (pt "SZero(SZero p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 2)
(simp "IfTrue")
(use 1)
(assume 2)
(simp "IfFalse")
(use "PosNotLtToLe")
(use 2)
(simp "FastSqrt5CompRule")
(bpe-ng)
(cases (pt "(SOne(SZero p)<SOne(FastSqrt p)*SOne(FastSqrt p))"))
(assume 2)
(simp "IfTrue")
(ng #t)
(use 1)
(assume 2)
(simp "IfFalse")
(use "PosNotLtToLe")
(use 2)
(assume "p" 1)
(split)
(use 1)
(split)
(simp "FastSqrt4CompRule")
(bpe-ng)
(cases (pt "SZero(SOne p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 2)
(simp "IfTrue")
(use 1)
(assume 2)
(simp "IfFalse")
(use "PosNotLtToLe")
(use 2)
(simp "FastSqrt6CompRule")
(bpe-ng)
(cases (pt "SOne(SOne p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 2)
(simp "IfTrue")
(use 1)
(assume 2)
(simp "IfFalse")
(use "PosNotLtToLe")
(use 2)
(assume 1 "p")
(use 1)
;;(cp)
(save "PosSquareFastSqrtUpBound")

;;PosSquareFastSqrtLowBound
(set-goal "all p,q(FastSqrt p<q -> p<q*q)")
(assert "all p( all q(FastSqrt p<q -> p<q*q) andnc 
    all q(FastSqrt(SZero p)<q -> SZero p<q*q) andnc 
    all q(FastSqrt(SOne p)<q -> SOne p<q*q))")
(ind)
(split)
(assume "q" 1)
(simp (pf "1=1*1"))
(use "PosLtMonTimes")
(use 1)
(use 1)
(use "Truth")
(ng)
(split)
(assume "q" 1)
(assert "2<=q")
(simp "<-" "PosToNatLe")
(ng #t)
(use "NatLtToSuccLe")
(simp "<-" "NatToPosLt")
(simp "NatToPosToNatId")
(use 1)
(use "NatLtZeroPos")
(use "Truth")
(assume 2)
(use "PosLtLeTrans" (pt "2*2"))
(use "Truth")
(use "PosLeMonTimes")
(use 2)
(use 2)
(assume "q" 1)
(assert "2<=q")
(simp "<-" "PosToNatLe")
(ng #t)
(use "NatLtToSuccLe")
(simp "<-" "NatToPosLt")
(simp "NatToPosToNatId")
(use 1)
(use "NatLtZeroPos")
(use "Truth")
(assume 2)
(use "PosLtLeTrans" (pt "2*2"))
(use "Truth")
(use "PosLeMonTimes")
(use 2)
(use 2)
(assume "p")
(elim)
(assume 2)
(elim)
(assume 4 5)
(drop 1 3)
(split)
(use 4)
(split)
(simp "FastSqrt3CompRule")
(bpe-ng)
(cases (pt "SZero(SZero p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 2 "q")
(simp "IfTrue")
(assume 3)
(use "PosLtLeTrans" (pt "SOne(FastSqrt p)*SOne(FastSqrt p)"))
(use 6)
(use "PosLeMonTimes")
(use "PosSZeroLtToSOneLe")
(use 7)
(use "PosSZeroLtToSOneLe")
(use 7)
(assume 2)
(simp "IfFalse")
(cases)
(assume 7)
(use "Efq")
(use 7)
(assume "q0" 7)
(use 2)
(use 7)
(assume "q0" 1)
(use "PosLtTrans" (pt "SZero q0*SZero q0"))
(ng #t)
(use 2)
(use 7)
(use "PosLtMonTimes")
(use "Truth")
(use "Truth")
(simp "FastSqrt5CompRule")
(bpe-ng)
(cases (pt "SOne(SZero p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 6)
(simp "IfTrue")
(cases)
(assume 7)
(use 7)
(search)
(assume "q0" 7)
(use "PosLtLeTrans" (pt "SOne(FastSqrt p)*SOne(FastSqrt p)"))
(use 6)
(use "PosLeMonTimes")
(use "PosSZeroLtToSOneLe")
(use 7)
(use "PosSZeroLtToSOneLe")
(use 7)
(assume 6)
(simp "IfFalse")
(cases)
(search)
(use 2)
(assume "q0" 7)
(inst-with 2 (pt "q0") 7)
(use "PosLtLeTrans" (pt "SOne(SZero (q0*q0))"))
(use 8)
(ng #t)
(use "PosLeTrans" (pt "SZero(q0*q0)+q0"))
(use "Truth")
(use "Truth")
(assume "p")
(elim)
(assume 2)
(elim)
(assume 4 5)
(drop 1 3)
(split)
(use 5)
(split)
(simp "FastSqrt4CompRule")
(bpe-ng)
(cases (pt "SZero(SOne p)<SOne(FastSqrt p)*SOne(FastSqrt p)"))
(assume 6)
(simp "IfTrue")
(cases)
(search)
(assume "q0" 7)
(use "PosLtLeTrans" (pt "SOne(FastSqrt p)*SOne(FastSqrt p)"))
(use 6)
(use "PosLeMonTimes")
(use 7)
(use 7)
(assume "q0" 7)
(use "PosLtLeTrans" (pt "SOne(FastSqrt p)*SOne(FastSqrt p)"))
(use 6)
(use "PosLeMonTimes")
(use 7)
(use 7)
(simp "IfFalse")
(assume 6)
(cases)
(search)
(use 2)
(assume "q0" 7)
(inst-with 2 (pt "q0") 7)
(use "PosLtTrans" (pt "SZero(SOne (q0*q0))"))
(use 8)
(ng #t)
(use "PosLeTrans" (pt "SZero(q0*q0)+q0"))
(use "PosLeTrans" (pt "SZero(q0*q0)+1"))
(use "Truth")
(use "PosLeMonPlus")
(use "Truth")
(use "Truth")
(use "Truth")
(simp "FastSqrt6CompRule")
(bpe-ng)
(cases (pt "(SOne(SOne p)<SOne(FastSqrt p)*SOne(FastSqrt p))"))
(assume 6)
(simp "IfTrue")
(cases)
(search)
(use 2)
(assume "q0" 7)
(use "PosLtLeTrans" (pt "SOne(FastSqrt p)*SOne(FastSqrt p)"))
(use 6)
(use "PosLeMonTimes")
(use 7)
(use 7)
(simp "IfFalse")
(assume 6)
(cases)
(search)
(assume "q0" 7)
(use 2)
(use 7)
(ng #t)
(assume "q0" 7)
(inst-with 2 (pt "q0") 7)
(use "PosLtLeTrans" (pt "SOne (q0*q0)"))
(use 8)
(use "PosLeTrans" (pt "SZero(q0*q0)+1"))
(use "Truth")
(use "PosLeTrans" (pt "SZero(q0*q0)+q0"))
(use "PosLeMonPlus")
(use "Truth")
(use "Truth")
(use "Truth")
(assume 1 "p")
(use 1)
;;(cp)
(save "PosSquareFastSqrtLowBound")

;;FastSqrtEqPosSqrt
(set-goal "all p(FastSqrt p = PosSqrt p)")
(assume "p")
(use "PosSqrtChar")
(use "PosSquareFastSqrtUpBound")
(use "PosSquareFastSqrtLowBound")
;;(cp)
(save "FastSqrtEqPosSqrt")


;; Fermat Factorisation
;; ====================

;; FastSqrtSOneBound
(set-goal "all p (2<p->FastSqrt(SOne p)<p)")
(assume "p" 1)
(simp "FastSqrtEqPosSqrt")
(cases (pt "p=3"))
(assume 2)
(simp 2)
(use "Truth")
(assume 2)
(use "PosNotLeToLt")
(assume 3)
(inst-with "PosLeMonSquare" (pt "p") (pt "PosSqrt(SOne p)") 3)
(assert "3*p<3*p")
(use "PosLtLeTrans" (pt "p*p"))
(use "PosLtLeMonTimes")
(cases (pt "p"))
(assume 5)
(simphyp 1 5)
(use 6)
(cases)
(assume 5)
(simphyp 1 5)
(auto)
(cases)
(auto)
(use "PosLeTrans" (pt "PosSquare(PosSqrt(SOne p))"))
(use 4)
(use "PosLeTrans" (pt "SOne p"))
(use "PosSquareSqrtUpBound")
(ng #t)
(use "PosLeTrans" (pt "SZero p +1"))
(use "Truth")
(use "PosLeMonPlus")
(auto)
;; (cp)
(save "FastSqrtSOneBound")

;; PosOddProdToDiffSq
(set-goal "all p,q0,q1(
     SOne p=q0*q1 -> 
     1<q0 ->
     1<q1 ->
     (q0=q1 -> F)->
     exnc p0,p1(
      p0<p1 andnc 
      p1<p andnc SOne p=p1*p1--p0*p0))")
;; We first add the assumption q0<q1 and do the general proof later.
(assert "all p,q0,q1(
     SOne p=q0*q1 -> 
     1<q0 ->
     1<q1 ->
     q0<q1 ->
     exnc p0,p1(
      p0<p1 andnc 
      p1<p andnc SOne p=p1*p1--p0*p0))")
(assume "p")
(cases)
;; Case q0=1
 (strip)
 (intro 0 (pt "1"))
 (intro 0 (pt "1"))
 (split)
 (use 2)
 (split)
 (use "EfAtom")
 (use 2)
 (use 2)
;; Case q0=SZero...
 (strip)
 (intro 0 (pt "1"))
 (intro 0 (pt "1"))
 (ng 1)
 (split)
 (use 1)
 (split)
 (use "EfAtom")
 (use 1)
 (use 1)
;; Case q0=SOne...
 (assume "q0")
 (cases)
 ;; Case q1=1
  (strip)
  (intro 0 (pt "1"))
  (intro 0 (pt "1"))
  (split)
  (use 3)
  (split)
  (use "EfAtom")
  (use 3)
  (use 3)
 ;; Case q1=SZero...
  (strip)
  (intro 0 (pt "1"))
  (intro 0 (pt "1"))
  (ng 1)
  (split)
  (use 1)
  (split)
  (use "EfAtom")
  (use 1)
  (use 1)
 ;; Case q1=SOne...
  (assume "q1")
  (strip)
  (ng 2 3 4)
  (drop 2 3)
  (intro 0 (pt "PosHalf(SOne q1--SOne q0)"))
  (intro 0 (pt "PosHalf(SOne q1+SOne q0)"))
  ;; Proof of the first part of the conjuction:
  (split)
   (ng #t)
   (use "PosLeLtTrans" (pt "q1+q0"))
   (use "PosLeTrans" (pt "q1"))
   (use "Truth")
   (use "Truth")
   (use "Truth")
  ;; Proof of the second part of the conjuction:
  (split)
   (ng #t)
   (ng 1)
   (simp 1)
   (simp (pf "PosS(q1+q0)=1+q1+q0"))
   (simp "SZeroPosPlus")
   (use "PosLeLtTrans" (pt "q0*q1+q1+q0"))
   (use "PosLeMonPlus")
   (use "PosLeMonPlus")
   (use "Truth")
   (use "Truth")
   (use "Truth")
   (use "Truth")
   (use "Truth")
  ;; Proof of the last part of the conjuction:
   (ng #t)
   (simp "PosThirdBinom")
   (simp (pf "PosS(q1+q0)+(q1--q0)=SOne q1"))
   (simp (pf "PosS(q1+q0)--(q1--q0)=SOne q0"))
   (simp "PosTimesComm")
   (use 1)
   (simp "PosMinusMinus")
   (simp "PosPlusComm")
   (simp (pf "q0+PosS(q1+q0)=SOne q0 +q1"))
   (use "Truth")
   (ng #t)
   (simp "PosPlusComm")
   (use "PosEqTrans" (pt "PosS(q0+q0)+q1"))
   (use "Truth")
   (simp "<-" "SZeroPosPlus")
   (use "Truth")
   (use "PosLtTrans" (pt "PosS(q1+q0)"))
   (use "PosLeLtTrans" (pt "q1+q0"))
   (use "Truth")
   (use "Truth")
   (use "Truth")
   (use 4)
   (simp "PosPlusComm")
   (simp (pf "PosS(q1+q0)=q0+q1+1"))
   (ng #t)
   (simp "PosMinusPlusEq")
   (simp "<-" "SZeroPosPlus")
   (use "Truth")
   (use 4)
   (simp "PosPlusComm")
   (use "Truth")
   (use "PosLeLtTrans" (pt "q1"))
   (use "Truth")
   (use "PosLtTrans" (pt "q1+q0"))
   (use "Truth")
   (use "Truth")
;; General proof
(strip)
(cases (pt "q0<q1"))
(assume 5)
(use 1 (pt "q0") (pt "q1"))
(auto)
(assume 5)
(assert "q1<q0")
(use "PosLeNotEqToLt")
(use "PosNotLtToLe")
(use 6)
(assume 7)
(use 5)
(use "PosEqSym")
(use 7)
(assume 7)
(use 1 (pt "q1") (pt "q0"))
(simp "PosTimesComm")
(auto)
;; (cp)
(save "PosOddProdToDiffSq")

(add-program-constant "FastSquareNumber" (py "pos=>boole"))
(add-computation-rules
 "FastSquareNumber p" "([q]q*q=p)(FastSqrt p)")

(set-totality-goal "FastSquareNumber")
(fold-alltotal)
(assume "p")
(ng)
(use "TotalVar")
(save-totality)

;;FastSqr
(set-goal "all p exl q q = FastSqrt p")
(assume "p")
(intro 0 (pt "FastSqrt p"))
(use "Truth")
;;(cp)
(save "FastSqr")

(animate "FastSqr")

;;FastSqrExFree
(set-goal "all p cFastSqr p = FastSqrt p")
(assume "p")
(use "Truth")
;;(cp)
(save "FastSqrExFree")

(deanimate "FastSqr")

;;FastSqrExFreePosSqrt
(set-goal "all p cFastSqr p = PosSqrt p")
(assume "p")
(simp "FastSqrExFree")
(use "FastSqrtEqPosSqrt")
;;(cp)
(save "FastSqrExFreePosSqrt")

;; FastSquareNumberSquare
(set-goal "all p FastSquareNumber(PosSquare p)")
(assume "p")
(simp "FastSquareNumber0CompRule")
(bpe-ng)
(simp "FastSqrtEqPosSqrt")
(simp "PosSqrtSquareId")
(use "Truth")
;; (cp)
(save "FastSquareNumberSquare")

;; PosPrimeOrComposedFermat
(set-goal "all p(
     1<p -> 
     PosPrime p orr exd q0 exl q1(1<q0 andnc 1<q1 andnc p=q0*q1))")
(cases)
;; Case 1 
 (assume 1)
 (intro 0)
 (use "EfAtom")
 (use 1)
;; Case SZero p
 (cases)
 (assume 1)
 (intro 0)
 (use "Truth")
 (assume "p" 1)
 (intro 1)
 (intro 0 (pt "2"))
 (intro 0 (pt "SZero p"))
 (split)
 (use "Truth")
 (split)
 (use "Truth")
 (use "Truth")
 (assume "p" 1)
 (intro 1)
 (intro 0 (pt "2"))
 (intro 0 (pt "SOne p"))
 (split)
 (use "Truth")
 (split)
 (use "Truth")
 (use "Truth")
 (assume "p" 1)
;; Case SOne p
 (cases (pt "FastSquareNumber(SOne p)"))
  ;; Case "FastSquareNumber(SOne p)"
  (assume 2)
  (intro 1)
  (intro 0 (pt "FastSqrt (SOne p)"))
  (intro 0 (pt "FastSqrt (SOne p)"))
  (assert "1<FastSqrt(SOne p)")
  (use "PosNotLeToLt")
  (assume 3)
  (inst-with "PosEqSqrtToOne" (pt "SOne p") "?")
  (use 4)
  (simphyp 2 "FastSquareNumber0CompRule")
  (bpe-ng)
  (simp "<-" 4)
  (use "PosLeTrans" (pt "FastSqrt(SOne p)*FastSqrt(SOne p)"))
  (use "Truth")
  (simp (pf "FastSqrt(SOne p)=1"))
  (use "Truth")
  (use 3)
  (assume 3)
  (split)
  (use 3)
  (split)
  (use 3)
  (use "PosEqSym")
  (use 2)
 ;; Case "FastSquareNumber(SOne p) -> F"
  (assume 2)
  (cases (pt "p<=2"))
  ;; Case p<=2
   (assume 3)
   (cases (pt "p"))
   (assume 4)
   (intro 0)
   (use "Truth")
   (cases)
   (assume 4)
   (intro 0)
   (use "Truth")
   (assume "q" 4)
   (simphyp 3 4)
   (intro 0)
   (use "EfAtom")
   (use 5)
   (assume "q" 4)
   (simphyp 3 4)
   (intro 0)
   (use "EfAtom")
   (use 5)
   (assume "q" 4)
   (intro 0)
   (use "EfAtom")
   (simphyp 3 4)
   (use 5)
  ;; Case 2<p
   (assume 3)
   (assert
    "exi l(l=NatLeastUp(PosToNat(cFastSqr(SOne p)+1)) 
          (PosToNat p)
          ([l]FastSquareNumber ((cNatPos l)*(cNatPos l)--(SOne p))))")
   (intro 0 (pt "NatLeastUp(PosToNat(cFastSqr(SOne p)+1)) 
                (PosToNat p)
                ([l]FastSquareNumber ((cNatPos l)*(cNatPos l)--(SOne p)))"))
   (use "Truth")
   (assume 4)
   (by-assume 4 "l" 5)
   (cases (pt "l=PosToNat p"))
   ;; Case l=PosToNat p
    (assume 6)
    (intro 0)
    (use "PosProdToPrime")
    (use 1)
    (assume "q0" "q1" 7)
    (assert "1<q0->1<q1 -> F")
    (assume 8 9)
    (inst-with "PosEqSym" (pt "q0*q1") (pt "SOne p") 7)
    (inst-with "PosOddProdToDiffSq" (pt "p") (pt "q0") (pt "q1") 10 8 9 "?")
    (by-assume 11 "p0" 12)
    (by-assume 12 "p1" 13)
    (inst-with "NatLeastUpLeIntro"
    	       (pt "PosToNat (cFastSqr (SOne p) +1)")
	       (pt "PosToNat p")
	       (pt "PosToNat p1")
	       (pt "[l0]FastSquareNumber(cNatPos l0*cNatPos l0--SOne p)")
	       "?"
	       "?")
    (assert "p1<p1")
    (use "PosLtLeTrans" (pt "p"))
    (use 13)
    (simp "<-" "PosToNatLe")
    (simp "<-" 6)
    (simp 5)
    (use 14)
    (assume 15)
    (use 15)
    (simp "PosToNatPlus")
    (simp (pf "NatPlus(PosToNat(cFastSqr(SOne p)))
                      (PosToNat 1)=Succ(PosToNat(cFastSqr(SOne p)))"))
    (use "NatLtToSuccLe")
    (simp "PosToNatLt")
    (simp (pf "SOne p=p1*p1--p0*p0"))
    (use "PosLtLeTrans" (pt "cFastSqr(PosSquare p1)"))
    (use "PosNotLeToLt")
    (assume 11)
    (inst-with "PosLeMonSquare"
	       (pt "cFastSqr(PosSquare p1)")
	       (pt "cFastSqr(p1*p1--p0*p0)")
	       14)
    (simphyp 15 "FastSqrExFreePosSqrt")
    (simphyp 16 "FastSqrExFreePosSqrt")
    (simphyp 17 "PosSqrtSquareId")
    (assert "p1*p1<=p1*p1--p0*p0")
    (use "PosLeTrans" (pt "PosSquare(PosSqrt(p1*p1--p0*p0))"))
    (use 18)
    (use "PosSquareSqrtUpBound")
    (assume 19)
    (assert "p1*p1<p1*p1")
    (use "PosLeLtTrans" (pt "p1*p1--p0*p0"))
    (use 19)
    (simp "<-" "PosToNatLt")
    (simp "PosToNatMinus")
    (simp "PosToNatTimes")
    (use "NatLtPlusMinus1")
    (simp "<-""PosToNatTimes")
    (simp "PosToNatLe")
    (use "PosLeMonSquare")
    (use "PosLtToLe")
    (use 13)
    (simp "<-" "PosToNatTimes")
    (simp "<-" "PosToNatPlus")
    (simp "PosToNatLt")
    (use "Truth")
    (use "PosLtMonTimes")
    (use 13)
    (use 13)
    (assume 20)
    (use 20)
    (simp "FastSqrExFreePosSqrt")
    (simp "PosSqrtSquareId")
    (use "Truth")
    (use 13)
    (use "Truth")
    (bpe-ng)
    (simp "NatPosExFree")
    (simp (pf "SOne p=p1*p1--p0*p0"))
    (simp "NatToPosToNatId")
    (simp (pf "p1*p1--(p1*p1--p0*p0)=p0*p0"))
    (use "FastSquareNumberSquare")
    (simp "PosMinusMinus")
    (use "Truth")
    (use "Truth")
    (use "PosLtMonSquare")
    (use 13)
    (use 13)
    (assume 10)
    (use 2)
    (simp "<-" 7)
    (simp 11)
    (use "FastSquareNumberSquare")
    (assume 8)
    (cases (pt "q0"))
    (assume 9)
    (use "Truth")
    (assume "q10" 1)
    (simphyp 8 9)
    (ng 10 #t)
    (cases (pt "q1"))
    (assume 10)
    (use "Truth")
    (assume "q11" 11)
    (use "EfAtom")
    (use 10)
    (use "Truth")
    (simp 11)
    (use "Truth")
    (assume "q11" 11)
    (use 10)
    (use "Truth")
    (simp 11)
    (use "Truth")
    (assume "p10" 9)
    (simphyp 8 9)
    (ng #t 10)
    (cases (pt "q1"))
    (assume 11)
    (use "Truth")
    (assume "q11" 11)
    (use 10)
    (use "Truth")
    (simp 11)
    (use "Truth")
    (assume "q11" 11)
    (use 10)
    (use "Truth")
    (simp 11)
    (use "Truth")
   ;; Case l=PosToNat p -> F
    (assume 6)
    ;;In this case SOne p is a composed number.
    (intro 1)
;; l will be used later as part of the prime factors.
;; Hence, we need a few properties about l.
     (assert "cFastSqr(SOne p)+1<=l")
     (simp 5)
     (use "NatLeastUpLBound")
     (simp "PosToNatPlus")
     (simp (pf "NatPlus(PosToNat(cFastSqr(SOne p)))
                       (PosToNat 1)=Succ(PosToNat(cFastSqr(SOne p)))"))
     (use "NatLtToSuccLe")
     (simp "PosToNatLt")
     (simp "FastSqrExFree")
     (use "FastSqrtSOneBound")
     (use "PosNotLeToLt")
     (use 3)
     (use "Truth")
     (assume 7)
    ;; Zero<l
     (assert "Zero<l")
     (use "NatLtLeTrans" (pt "PosToNat(cFastSqr(SOne p)+1)"))
     (use "NatLtZeroPos")
     (use 7)
     (assume 8)
    ;; PosSquareNumber(cNatPos l*cNatPos l--SOne p)
     (assert "FastSquareNumber(cNatPos l*cNatPos l--SOne p)")
     (simp 5)
     (use-with "NatLeastUpLtElim"
	        (pt "PosToNat (cFastSqr (SOne p) + 1)")
	        (pt "PosToNat p")
	        (pt "[l0]FastSquareNumber(cNatPos l0*cNatPos l0--SOne p)")
	        "?"
	        "?")
     (simp "<-" 5)
     (use 7)
     (use "NatLeNotEqToLt")
     (use "NatLeastUpBound")
     (simp "<-" 5)
     (use 6)
     (assume 9)
    ;; SOne < l*l
     (assert "SOne p < l*l")
     (use "NatLtLeTrans"
           (pt "PosToNat(cFastSqr(SOne p)+1)*PosToNat(cFastSqr(SOne p)+1)"))
     (simp "<-" "PosToNatTimes")
     (simp "PosToNatLt")
     (simp "<-" "PosSquare0CompRule")
     (use "PosSquareSqrtLowBound")
     (simp "FastSqrExFreePosSqrt")
     (use "Truth")
     (use "NatLeMonTimes")
     (use 7)
     (use 7)
     (assume 10)
    ;; Abbreviation q
     (assert "exl q q=cFastSqr(cNatPos l*cNatPos l--SOne p)")
     (intro 0 (pt "cFastSqr(cNatPos l*cNatPos l--SOne p)"))
     (use "Truth")
     (assume 10)
     (by-assume 11 "q" 12)
    ;;q<l
     (assert "q<l")
     (simp 12)
     (simp "<-" "NatToPosLt")
     (simp "NatToPosToNatId")
     (use "PosLtMonSquareInv")
     (simphyp 9 "FastSquareNumber0CompRule")
     (bpe-ng)
     (simp "PosSquare0CompRule")
     (simp "FastSqrExFree")
     (simp 13)
     (simp "PosSquare0CompRule")
     (simp "<-" "NatToPosTimes")
     (simp "<-" "PosToNatLt")
     (simp (pf "SOne p=NatToPos(PosToNat(SOne p))"))
     (simp "NatPosExFree")
     (simp "<-" "NatToPosTimes")
     (simp "<-" "NatToPosMinus")
     (simp "PosToNatLt")
     (simp "NatToPosLt")
     (use "NatLtLeTrans" (pt "l*l--Zero"))
     (use "NatLtMonMinusRight")
     (use "Truth")
     (use "NatLtToLe")
     (use 10)
     (use "Truth")
     (use "NatLtTimesPos")
     (use 8)
     (use 8)
     (simp "<-" "NatLtMinusZero")
     (use 10)
     (use 10)
     (use "Truth")
     (use 8)
     (use 8)
     (use "PosEqSym")
     (use "NatToPosToNatId")
     (use 8)
     (use 8)
     (use 8)
     (use "NatLtZeroPos")
     (assume 13)
    ;; Main Proof
    (intro 0 (pt "cNatPos l+q"))
    (intro 0 (pt "cNatPos l--q"))
;; All three parts of the conjunction follow by the last one.
;; Hence, we proof it first.
     (assert "SOne p=(cNatPos l+q)*(cNatPos l--q)")
     (simp "<-" "PosThirdBinom")
     (simphyp 9 "FastSquareNumber0CompRule")
     (bpe-ng)
     (simp 12)
     (simp "FastSqrExFree")
     (simp 14)
     (simp "PosMinusMinus")
     (simp "PosPlusComm")
     (use "Truth")
     (use "Truth")
     (simp "NatPosExFree")
     (simp "<-" "NatToPosTimes")
     (simp "<-" "PosToNatLt")
     (simp "PosToNatToPosId")
     (use 10)
     (use "NatLtTimesPos")
     (use 8)
     (use 8)
     (use 8)
     (use 8)
     (simp "<-" "PosToNatLt")
     (simp "NatPosExFree")
     (simp "PosToNatToPosId")
     (use 13)
     (use 8)
     (assume 14)
    ;; Proof of the first part of the conjunction:
    (split)
    (use "PosLeLtTrans" (pt "cNatPos l"))
    (use "Truth")
    (use "Truth")
    ;; Proof of the secound part of the conjucntion
    (split)
    (cases (pt "l--q=1"))
    ;; Case l--q=1 (leads to F)
     (assume 15)
     ;; Transformation to Pos
     (assert "cNatPos l--q=1")
      (use "PosToNatInj")
      (simp (pf "q=NatToPos(PosToNat q)"))
      (simp "NatPosExFree")
      (simp "<-" "NatToPosMinus")
      (simp "PosToNatToPosId")
      (use 15)
      (simp 15)
      (use "Truth")
      (use 13)
      (use "NatLtZeroPos")
      (use "PosEqSym")
      (use "NatToPosToNatId")
      (assume 16)
     ;; Proof of Falsum
     (assert "PosToNat q<PosToNat q")
      (use "NatLtLeTrans" (pt "l"))
      (use 13)
      (simp 5)
      (simphyp 14 16)
      (simp (pf "p=q")) 
      (use "NatLeastUpBound")
      (assert "SOne p=SOne q")
       (simp 17)
       (simp (pf "l=q+1"))
       (simp "PosToNatPlus")
       (simp "NatPosExFree")
       (simp "NatToPosPlus")
       (simp "NatToPosToNatId")
       (simp "NatToPosToNatId")
       (ng #t)
       (simp "<-" "SZeroPosPlus")
       (use "Truth")
       (use "Truth")
       (use "NatLtZeroPos")
       (simp "<-" 16)
       (simp "PosPlusComm")
       (simp "PosMinusPlusEq")
       (use "NatEqSym")
       (simp "NatPosExFree")
       (use "PosToNatToPosId")
       (use 8)
       (simp "<-" "PosToNatLt")
       (simp "NatPosExFree")
       (simp "PosToNatToPosId")
       (use 13)
       (use 8)
       (assume 18)
      (use 18)
     (assume 17)
     (use "EfAtom")
     (use 17)
    ;; Case l--q=PosToNat 1 -> F)
     (assume 1)
     (use "PosNotLeToLt")
     (assume 16)
     (use 15)
     (simp "<-" "PosToNatToPosId")
     (simp "NatToPosMinus")
     (simp "NatToPosToNatId")
     (simp (pf "NatToPos l--q=1"))
     (use "Truth")
     (simp "<-" "NatPosExFree")
     (use 16)
     (use 13)
     (use "NatLtZeroPos")
     (simp "<-" "NatLtMinusZero")
     (use 13)
    ;;The last part of the conjuction is already proven:
    (use 14)
;; (cp)
(save "PosPrimeOrComposedFermat")

(define eterm (proof-to-extracted-term))

(define posSqrt (proof-to-extracted-term "PosSqr"))

(define neterm (bpe-nt eterm))

;; To generate a Haskell file, please run the uncommented code below and
;; replace "/path/to/Haskell/file/" with the desired path for the Haskell file.

;; (animate-bpe-nt "FastSqr")
;; (animate-bpe-nt "NatPos")
;; (animate-bpe-nt "PosSqr")
;; (animate-bpe-nt "Rht")
;; (animate-bpe-nt "Lft")

(terms-to-haskell-program
 "/path/to/Haskell/file/factor_pos.hs"
 (list (list eterm "fermat")
       (list posSqrt "testSqrt")))

(ppc (rename-variables neterm))

;; [p]
;;  [case p
;;    (1 -> DummyL)
;;    (SZero p0 -> 
;;    [case p0
;;      (1 -> DummyL)
;;      (SZero p1 -> Inr(2 pair SZero p1))
;;      (SOne p1 -> Inr(2 pair SOne p1))])
;;    (SOne p0 -> 
;;    [case (FastSquareNumber(SOne p0))
;;      (True -> Inr(FastSqrt(SOne p0)pair FastSqrt(SOne p0)))
;;      (False -> 
;;      [case (p0<=2)
;;        (True -> 
;;        [case p0
;;          (1 -> DummyL)
;;          (SZero p1 -> 
;;          [case p1 (1 -> DummyL) (SZero q -> DummyL) (SOne q -> DummyL)])
;;          (SOne q -> DummyL)])
;;        (False -> 
;;        [case (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;                ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0))=
;;                PosToNat p0)
;;          (True -> DummyL)
;;          (False -> 
;;          Inr(cNatPos
;;              (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;               ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))+
;;              cFastSqr
;;              (cNatPos
;;               (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;                ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))*
;;               cNatPos
;;               (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;                ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))--
;;               SOne p0)pair 
;;              cNatPos
;;              (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;               ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))--
;;              cFastSqr
;;              (cNatPos
;;               (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;                ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))*
;;               cNatPos
;;               (NatLeastUp(PosToNat(cFastSqr(SOne p0)+1))(PosToNat p0)
;;                ([l]FastSquareNumber(cNatPos l*cNatPos l--SOne p0)))--
;;               SOne p0)))])])])]
