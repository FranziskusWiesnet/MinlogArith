;; 2025-03-23.  examplesarithfta_pos.scm.  Based on Franziskus Wiesnet's
;; div_pos.scm gcd_pos.scm prime_pos.scm and FTA_pos.scm

;; Revised by Franziskus Wiesnet

;; (load "/home/fwiesnet/Minlog/minlog/init.scm")
;; (set! COMMENT-FLAG #f)
;; (libload "libnat2503.scm")
;; (exload "arith/FTA/examplesarithgcd_nat.scm")
;; (exload "arith/FTA/examplesarithprime_nat.scm")
;; (exload "arith/FTA/examplesarithfta_nat.scm")
;; (libload "libpos.scm")
;; (exload "arith/FTA/examplesarithgcd_pos.scm")
;; (exload "arith/FTA/examplesarithprime_pos.scm")
;; (set! COMMENT-FLAG #t)

;;  Fundamental theorem of arithmetic
;;  =================================

;; PosExPrimeFactorisation
(set-goal "all p exd ps exl m PosPrimes ps m andb PosProd Zero m ps=p")
(assert "all l,p(
 p<l -> exd ps exl m PosPrimes ps m andb PosProd Zero m ps=p)")
(ind)
(assume "p" 1)
(intro 0 (pt "[n]1"))
(intro 0 (pt "Zero"))
(use "EfAtom")
(use 1)
(assume "l10" 1 "p")
(cases (pt "p=1"))
(assume 2)
(simp 2)
(assume 3)
(intro 0 (pt "[n]1"))
(intro 0 (pt "Zero"))
(use "Truth")
(assume 2 3)
(assert "1<p")
(use "PosNotLeToLt")
(assume 4)
(use 2)
(use 4)
(assume 4)
(inst-with "PosOneLtLeastFactor" (pt "p") "?")
(inst-with "PosLeastFactorDiv" (pt "p"))
(inst-with "PosDivToProd" (pt "PosLeastFactor p") (pt "p") 6)
(by-assume 7 "q" 8)
(inst-with 1 (pt "q") "?")
(by-assume 9 "qs" 10)
(by-assume 10 "n" 11)
(intro 0 (pt "[n0] [if (n0<n) (qs n0) (PosLeastFactor p)]"))
(intro 0 (pt "Succ n"))
(split)
(simp "PosPrimes1CompRule")
(split)
(bpe-ng)
(simp "NatLt1RewRule")
(simp "IfFalse")
(use "PosLeastFactorPrime")
(use 4)
(simp "PosPrimesCompat" (pt "qs"))
(use 11)
(assume "l" 12)
(bpe-ng)
(simp 12)
(use "Truth")
(simp "PosProd1CompRule")
(simp "PosProdCompat" (pt "qs"))
(bpe-ng)
(simp "NatPlus0RewRule")
(simp "NatLt1RewRule")
(simp "IfFalse")
;; (pp "PosProdCompat")
(simp (pf "PosProd Zero n qs=q"))
(use 8)
(use 11)
(strip)
(bpe-ng)
(ng 13)
(simp 13)
(use "Truth")
(use "NatLtLeTrans" (pt "PosToNat p"))
(simp "PosToNatLt")
(use "PosLtTimesCancelR" (pt "PosLeastFactor p"))
(simp 8)
(use "PosLtPosToLtTimes")
(use 5)
(use "NatLtSuccToLe")
(use 3)
(use 4)
(strip)
(use 1 (pt "PosToNat p +1"))
(use "Truth")
;; (cp)
(save "PosExPrimeFactorisation")

(define etermExPrime (proof-to-extracted-term))
;;(ppc etermExPrime)

;; Permutation pairs Pms
;; =====================

;; (remove-var-name "f" "g")
;; (add-var-name "f" "g" (py "nat=>nat"))

;; PosProdInvTranspAux
(set-goal "all m,n,ps(
 n<m -> PosProd Zero(Succ m) ps=PosProd Zero(Succ m)([l]ps(Transp n m l)))")
(ind)
;; Case 0
 (assume "n" "ps" 1)
 (use "EfAtom")
 (use 1)
;; Case Succ m
 (assume "m" 1 "n" "ps" 2)
 (ng)
 (assert "Succ m=n -> F")
  (assume 3)
  (simphyp 2 3)
  (use 4)
 (assume 3)
 (simp 3)
 (ng)
 (cases (pt "m=n"))
 ;;Case m=n
  (assume 4)
  (simp 4)
  (ng)
  (simp (pf "PosProd Zero n
 ([l]ps[if (l=n) (Succ n) [if (l=Succ n) n l]]) = PosProd Zero n ps")) ;;(1)
  (simp "<-" "PosTimesAssoc")
  (simp (pf "ps n*ps(Succ n) =ps(Succ n)*ps n"))
  (use "Truth")
  (use "PosTimesComm")
  ;; Proof of (1)
   (use "PosProdCompat")
   (strip)
   (ng)
   (assert "l=n -> F")
    (assume 7)
    (simphyp 6 7)
    (use 8)
   (assume 7)
   (simp 7)
   (assert "l=Succ n -> F")
    (assume 8)
    (simphyp 6 8)
    (use 9)
   (assume 8)
   (simp 8)
   (use "Truth")
 ;; Case m=n -> F
  (assume 4)
  (ng)
  (simp (pf "m=Succ m -> F")) ;;(2)
  (simp "<-" "PosTimesAssoc")
  (simp "<-" "PosTimesAssoc")
  (simp (pf "ps m*ps(Succ m)=ps(Succ m)*ps m"))  ;;(3)
  (simp (pf "ps[if False n m]*ps n=ps n *ps m")) ;;(4)
  (ng)
  (inst-with 1 (pt "n") (pt "[l]ps([if (l=m) (Succ m) l])") "?")
  (ng)
  (simphyp 5 (pf "PosProd Zero m(
   [n0]ps[if (n0=m) (Succ m) n0])=PosProd Zero m ps")) ;;(5)
  (drop 5)
  (simphyp 6 4)
  (ng)
  (simphyp 7 (pf "n=m -> F")) ;;(6)
  (drop 6 7)
  (ng)
  (simphyp 8 (pf "PosProd Zero m
      ([n0]
	ps
	[if ([if (n0=n) m [if (n0=m) n n0]]=m)
	  (Succ m)
	  [if (n0=n) 
              m 
              [if (n0=m) n n0]]])=
   PosProd Zero m([n0]ps[if (n0=n) (Succ m) [if (n0=Succ m) n n0]])")) ;;(7)
  (simp 9)
  (use "Truth")
  ;; Proof of (7)
   (use "PosProdCompat")
   (strip)
   (ng)
   (assert "l=m -> F")
    (assume 11)
    (simphyp 10 11)
    (use 12)
   (assume 11)
   (simp 11)
   (ng)
   (cases (pt "l=n"))
   ;; Case l=n
    (assume 12)
    (use "Truth")
   ;; Case l=n -> F
    (assume 12)
    (ng)
    (simp 11)
    (ng)
    (simp (pf "l=Succ m -> F"))
    (use "Truth")
    (assume 13)
    (simphyp 10 13)
    (use 14)
  ;; Proof of (6)
   (assume 8)
   (use 4)
   (use "NatEqSym")
   (use 8)
  ;; Proof of (5)
   (use "PosProdCompat")
   (assume "l" 6 7)
   (ng)
   (simp (pf "l=m -> F"))
   (use "Truth")
   (assume 8)
   (simphyp 7 8)
   (use 9)
    (use "NatLtSuccNotEqToLt")
    (use 2)
    (assume 5)
    (use 4)
    (use "NatEqSym")
    (use 5)
  ;; Proof of (4)
   (use "PosTimesComm")
  ;; Proof of (3)
   (use "PosTimesComm")
  ;; Proof of (2)
   (assume 5)
   (assert "m<m")
    (use "NatLtLeTrans" (pt "Succ m"))
    (use "Truth")
    (simp "<-" 5)
    (use "Truth")
   (search)
;; (cp)
(save "PosProdInvTranspAux")

;; PosProdInvPms
(set-goal "all n,ns,ms,ps(
 Pms n ns ms -> PosProd Zero n ps = PosProd Zero n ([l]ps(ns l)))")
(ind)
;; Case 0
 (strip)
 (use "Truth")
;; Case S n
 (assume "n" 1 "ns" "ms" "ps" 2)
 (cases (pt "ns n<n"))
 ;; Case ns n<n
  (assume 3)
  (simp "PosProdInvTranspAux" (pt "ns n"))
  (simp "PosProd1CompRule")
  (simp "PosProd1CompRule")
  (simp 1 (pt "[l]Transp(ns n)n (ns l)") (pt "[l]ms(Transp(ns n)n l)"))
  (simp (pf "PosProd Zero n
    ([l]([l0]ps(Transp(ns n)n l0))(([l0]Transp(ns n)n(ns l0))l))= 
    PosProd Zero n([l]ps(ns l))")) ;;(1)
  (ng #t)
  (cases (pt "n=ns n"))
  ;; Case n=ns n
   (assume 4)
   (simp "<-" 4)
   (use "Truth")
  ;; Case n=ns n->F
   (assume 4)
   (use "Truth")
  ;; Proof of (1)
  (use "PosProdCompat")
  (strip)
  (ng)
  (cases (pt "ns l=ns n"))
  ;; Case ns l=ns n
   (assume 6)
   (simp 6)
   (ng)
   (cases (pt "n=ns n"))
   ;; Case n=ns n
    (assume 7)
    (simp "<-" 7)
    (use "Truth")
   ;;Case n=ns n -> F
    (assume 7)
    (use "Truth")
  ;; Case ns l=ns n -> F
   (assume 6)
   (ng)
   (cases (pt "ns l=n"))
   (assume 7)
   (simp 7)
   (use "Truth")
   (assume 7)
   (ng)
   (simp 6)
   (simp 7)
   (use "Truth")
   (use "PmsSuccInv")
   (use "PmsConcat")
   (use "PmsTransp")
   (use "NatLeToLtSucc")
   (use "NatMaxLUB")
   (use "NatNotLtToLe")
   (assume 4)
   (inst-with
     "PmsIdOutInv" (pt "Succ n") (pt "ns") (pt "ms") 2 (pt "ns n") "?")
 ;; open: Succ n<=ns n (2)
   (simphyp 5 "PmsCirc" (pt "Succ n"))
   (assert "ns n<ns n")
    (use "NatLeLtTrans" (pt "n"))
    (simp "<-" 6)
    (use "Truth")
    (use 4)
   (search)
   (use 2)
   ;; Proof of (2)
    (use "NatLtToSuccLe")
    (use 4)
   (use "Truth")
   (use 2)
   (use "Truth")
   (use 3)
 ;; Case ns n<n -> F
  (assume 3)
  (simp "PosProd1CompRule")
  (simp "PosProd1CompRule")
  (assert "ns n=n")
   (use "NatLeAntiSym")
   (use "NatNotLtToLe")
   (assume "4")
   (inst-with
     "PmsIdOutInv" (pt "Succ n") (pt "ns") (pt "ms") 2 (pt "ns n") "?")
   (simphyp 5 "PmsCirc" (pt "Succ n"))
   (assert "ns n<ns n")
    (use "NatLeLtTrans" (pt "n"))
    (simp "<-" 6)
    (use "Truth")
    (use 4)
   (search)
   (use 2)
   (use "NatLtToSuccLe")
   (use 4)
   (use "NatNotLtToLe")
   (use 3)
  (assume 4)
  (ng)
  (simp 4)
  (simp 1 (pt "ns") (pt "ms"))
  (use "Truth")
  (use "PmsSuccInv")
  (use 2)
  (use 4)
;; (cp)
(save "PosProdInvPms")

;; PrimesConstInvTranspAux
(set-goal "all m,n,ps(n<m -> PosPrimes ps (Succ m)=
                             PosPrimes ([l]ps(Transp n m l)) (Succ m))") 
(ind)
(assume "n" "ps" 1)
(use "EfAtom")
(use 1)
(assume "m" 1 "n" "ps" 1)
(simp "PosPrimes1CompRule")
(simp "PosPrimes1CompRule")
(simp "PosPrimes1CompRule")
(simp "PosPrimes1CompRule")
(assert "Succ m=n->F")
(assume 3)
(simphyp 2 3)
(use 4)
(assume 3)
(simp 3)
(cases (pt "m=n"))
(assume 4)
(simp 4)
(ng #t)
(simp (pf "PosPrimes
  ([n0]ps[if (n0=n) (Succ n) [if (n0=Succ n) n n0]])n=PosPrimes ps n"))
(cases (pt "Succ Zero<ps(Succ n)"))
(cases (pt "negb(ExBPos
            [if (2**NatHalf(PosLog(ps n))*2**NatHalf(PosLog(ps n))<=ps n)
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))
              (2**NatHalf(PosLog(ps n))))
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))1)]
            ([p]1<p andb PosGcd p(ps n)=p))andb 
       1<ps n"))
(strip)
(use "Truth")
(strip)
(use "Truth")
(cases (pt "negb(ExBPos
            [if (2**NatHalf(PosLog(ps n))*2**NatHalf(PosLog(ps n))<=ps n)
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))
              (2**NatHalf(PosLog(ps n))))
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))1)]
            ([p]1<p andb PosGcd p(ps n)=p))andb 
       1<ps n"))
(strip)
(use "Truth")
(strip)
(use "Truth")
(use "PosPrimesCompat")
(assume "l" 5)
(ng)
(assert "l=n->F")
(assume 5)
(simphyp 5 6)
(use 7)
(assume 6)
(simp 6)
(assert "l=Succ n -> F")
(assume 7)
(simphyp 5 7)
(use 8)
(assume 7)
(simp 7)
(use "Truth")
(assume 4)
(ng)
(simp (pf "m=Succ m ->F"))
(ng)
(cases (pt "negb(ExBPos
            [if (2**NatHalf(PosLog(ps m))*2**NatHalf(PosLog(ps m))<=ps m)
              (PosMonMaxAux([p]p*p<=ps m)(NatHalf(PosLog(ps m)))
              (2**NatHalf(PosLog(ps m))))
              (PosMonMaxAux([p]p*p<=ps m)(NatHalf(PosLog(ps m)))1)]
            ([p]1<p andb PosGcd p(ps m)=p))andb 
       1<ps m"))
(ng)
(assume 15)
(inst-with 1 (pt "n") (pt "[l]ps([if (l=m) (Succ m) l])") "?")
(ng)
(simphyp 6 4)
(drop 6)
(ng)
(simphyp 7 (pf "n=m -> F"))
(drop 7)
(ng)
(simp (pf "PosPrimes ps m=PosPrimes([n0]ps[if (n0=m) (Succ m) n0])m"))
(drop 7)
(simp 8)
(ng)
(cases (pt "negb(ExBPos
            [if (2**NatHalf(PosLog(ps n))*2**NatHalf(PosLog(ps n))<=ps n)
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))
              (2**NatHalf(PosLog(ps n))))
              (PosMonMaxAux([p]p*p<=ps n)(NatHalf(PosLog(ps n)))1)]
            ([p]1<p andb PosGcd p(ps n)=p))andb 
       1<ps n"))
(ng)
(assume 9)
(use "PosPrimesCompat")
(assume "l" 10)
(ng)
(assert "l=m -> F")
(assume 11)
(simphyp 10 11)
(use 12)
(assume 11)
(simp 11)
(simp (pf "l=Succ m -> F"))
(ng)
(cases (pt "l=n"))
(search)
(assume 12)
(ng)
(simp 11)
(use "Truth")
(assume 12)
(simphyp 10 12)
(use 13)
(search)
(use "PosPrimesCompat")
(assume "l" 9)
(ng)
(simp (pf "l=m->F"))
(use "Truth")
(assume 10)
(simphyp 9 10)
(use 11)
(assume 8)
(use 4)
(use "NatEqSym")
(use 8)
(use "NatLtSuccNotEqToLt")
(use 2)
(assume 6)
(use 4)
(use "NatEqSym")
(use 6)
(search)
(assume 5)
(assert "m<m")
(use "NatLtLeTrans" (pt "Succ m"))
(use "Truth")
(simp "<-" 5)
(use "Truth")
(search)
;; (cp)
(save "PosPrimesInvTranspAux")

;; Uniqueness of prime factorisation
;; =================================

;; PosPrimeFactorisationsToPms
(set-goal "all n,m,ps,qs(
            PosPrimes ps n -> 
            PosPrimes qs m -> 
            PosProd Zero n ps=PosProd Zero m qs -> 
            n=m andr exd ns exl ms (Pms n ns ms andnc
                                    all l(l<n -> ps(ns l)=qs l)))")
(ind)
;; Case n=0
 (cases)
 (strip)
 (split)
 (use "Truth")
 (intro 0 (pt "[n]n"))
 (intro 0 (pt "[n]n"))
 (split)
 (intro 0)
 (auto)
 (assume "l" 4)
 (use "EfAtom")
 (use 4)
 (assume "m" "ps" "qs" 1)
 (simp "PosPrimes1CompRule")
 (simp "PosPrime0CompRule")
 (assume 2 3)
 (ng 3)
 (assert "1<PosProd Zero m qs *qs m")
 (use "PosLeLtTrans" (pt "PosProd Zero m qs"))
 (use "Truth")
 (use "PosLtPosToLtTimes")
 (use 2)
 (assume 4)
 (simphyp 4 3)
 (split)
 (use "EfAtom")
 (use 5)
 (intro 0 (pt "[n]n"))
 (intro 0 (pt "[n]n"))
 (split)
 (use "EfPms")
 (use 5)
 (strip)
 (use "EfAtom")
 (use 5)
;; Case n= Succ...
 (assume "n" 1)
 (cases)
 ;; Case m=0
  (strip)
  (ng 4)
  (assert "ps n=1")
  (use "PosTimesEqualOneToOne" (pt "PosProd Zero n ps"))
  (simp "PosTimesComm")
  (use 4)
  (assume 5)
  (ng 2)
  (simphyp 2 5)
  (split)
  (use 6)
  (intro 0 (pt "[n]n"))
  (intro 0 (pt "[n]n"))
  (split)
  (use "EfPms")
  (use 6)
  (strip)
  (use "EfAtom")
 ;; Case m=Succ...
  (use 6)
  (assume "m" "ps" "qs" 2 3 4)
  (inst-with "PosPrimeToIrred"
	     (pt "qs m") (pt "PosProd Zero n ps") (pt "ps n") "?" "?") ;;(2)
  (cases (pt "PosDiv(qs m) (PosProd Zero n ps)"))
  ;;Case PosDiv(qs m)(PosProd Zero n ps)
   (assume 6)
   (inst-with "PosPrimeDivProdPrimesToInPrimes"
     (pt "ps") (pt "qs m") (pt "n") "?" "?" 6)
   (by-assume 7 "l" 8)
   (inst-with 1 (pt "m") (pt "[l0]ps(Transp l n l0)") (pt "qs") "?" "?" "?")
   (elim 9)
   (drop 9)
   (assume 10 11)
   (by-assume 11 "ns" 12)
   (by-assume 12 "ms" 13)
   (split)
   (use 10)
   (intro 0 (pt "[l1](Transp l n (ns l1))"))
   (intro 0 (pt "[l1]ms(Transp l n l1)"))
   (split)
   (use-with "PmsConcat" (pt "Succ n")
     (pt "Transp l n") (pt "Transp l n")(pt "ns") (pt "ms") "?" "?")
   (use "PmsTransp")
   (use "NatLeToLtSucc")
   (use "NatMaxLUB")
   (use "NatLtToLe")
   (use 8)
   (use "Truth")
   (use "PmsSucc")
   (use 13)
   (assume "l0" 14)
   (cases (pt "l0=n"))
   ;; Case l0=n
   (assume 15)
   (simp 15)
   (ng)
   (assert "ns n =n")
    (use "PmsIdOut" (pt "n") (pt "ms"))
    (use 13)
    (use "Truth")
   (assume "16")
   (simp 16)
   (assert "ns n=l -> F")
    (simp 16)
    (assume 17)
    (simphyp 8 17)
    (use 18)
   (assume 17)
   (simp 17)
   (ng)
   (simp 10)
   (use 8)
   (assume 15)
   (use 13)
   (use "NatLtSuccNotEqToLt")
   (use 14)
   (use 15)
   (simphyp 2 "PosPrimesInvTranspAux" (pt "l"))
   (simphyp 9 "PosPrimes1CompRule")
   (use 10)
   (use 8)
   (simphyp 3 "PosPrimes1CompRule")
   (use 9)
   ;; Proof of (1)
   (simphyp 4 "PosProdInvTranspAux" (pt "l"))
   (simphyp 9 "PosProd1CompRule")
   (simphyp 10 "PosProd1CompRule")
   (simphyp 11 (pf "([l0]ps(Transp l n l0))(Zero+n)=ps l"))
   (simphyp 12 (pf "ps l=qs m"))
   (use "PosTimesCancelR" (pt "qs m"))
   (use 13)
   (use 8)
   (ng #t)
   (cases (pt "n=l"))
   (assume 12)
   (simp 12)
   (use "Truth")
   (assume 13)
   (use "Truth")
   (use 8)
   (ng 3)
   (use 3)
   (ng 2)
   (use 2)
  ;; Case PosDiv(qs m)(ps n)
   (assume 6)
   (simphyp 5 6)
   (inst-with "PosDivPrimeToEq" (pt "qs m") (pt "ps n") "?" "?" 7)
   (inst-with 1 (pt "m") (pt "ps") (pt "qs") "?" "?" "?")
   (elim 9)
   (assume 10 11)
   (split)
   (use 10)
   (by-assume 11 "ns" 12)
   (by-assume 12 "ms" 13)
   (intro 0 (pt "ns"))
   (intro 0 (pt "ms"))
   (split)
   (use "PmsSucc")
   (use 13)
   (assume "l" 14)
   (cases (pt "l=n"))
   (assume 15)
   (simp 15)
   (simp (pf "ns n=n"))
   (simp 10)
   (simp 8)
   (simp 10)
   (use "Truth")
   (use "PmsIdOut" (pt "n") (pt "ms"))
   (use 13)
   (use "Truth")
   (assume 14)
   (use 13)
   (use "NatLtSuccNotEqToLt")
   (use 14)
   (use 15)
   (simphyp 2 "PosPrimes1CompRule")
   (use 9)
   (simphyp 3 "PosPrimes1CompRule")
   (use 9)
   (ng 4)
   (simphyp 4 8)
   (use "PosTimesCancelR" (pt "ps n"))
   (use 9)
   (ng 3)
   (use 3)
   (ng 2)
   (use 2)
  ;; Premises of (2) (inst-with "PosPrimeToIrred" ...)
   (ng 3)
   (use 3)
   (simp 4)
   (use "PosProdToDiv" (pt" PosProd Zero m qs"))
   (use "Truth")
;; (cp)
(save "PosPrimeFactorisationsToPms")

(define etermToPms (proof-to-extracted-term))

;; Application
;; ===========

(add-program-constant "PosSeqConcat"
 (py "nat=>nat=>(nat=>pos)=>(nat=>pos)=>nat=>pos"))
(add-computation-rules
 "PosSeqConcat n m ps qs l" "[if (l<n) (ps l) (qs(l--n))]")

(set-totality-goal "PosSeqConcat")
(fold-alltotal)
(assume "n")
(fold-alltotal)
(assume "m")
(fold-alltotal)
(assume "ps")
(fold-alltotal)
(assume "qs")
(fold-alltotal)
(assume "l")
(use "TotalVar")
(save-totality)

;; PosPrimeFactorSeqConcat
(set-goal "all n,m,ps,qs(
     PosPrimes ps n -> 
     PosPrimes qs m -> PosPrimes(PosSeqConcat n m ps qs)(n+m))")
(ind)
(assume "m" "ps" "qs" 1 2)
(use 2)
(assume "n" 1)
(ind)
(assume "ps" "qs " 1 2)
(simp "PosPrimesCompat" (pt "ps"))
(use 2)
(assume "n0" 4)
(ng #t)
(simp 4)
(use "Truth")
(assume "m" 2 "ps" "qs" 3 4)
(simp (pf "Succ n+Succ m=Succ(Succ n + m)"))
(simp "PosPrimes1CompRule")
(split)
(simp "PosSeqConcat0CompRule")
(simp (pf "Succ n+m<Succ n -> F"))
(ng)
(use 4)
(search)
(use 2)
(use 3)
(ng)
(use 4)
(use "Truth")
;; (cp)
(save "PosPrimeFactorSeqConcat")

;; PosProdSeqConcat
(set-goal "all n,m,ps,qs 
     PosProd Zero n ps*PosProd Zero m qs=
     PosProd Zero(n+m)(PosSeqConcat n m ps qs)")
(assume "n")
(ind)
(strip)
(use "PosProdCompat")
(strip)
(ng #t)
(simp 2)
(use "Truth")
(assume "m" 1  "ps" "qs")
(ng #t)
(simp 1)
(use "Truth")
;; (cp)
(save "PosProdSeqConcat")

;; PosProdSeqConcatSplit0
(set-goal "all n,m,ps,qs
 PosProd Zero n ps=PosProd Zero n(PosSeqConcat n m ps qs)")
(ind)
(strip)
(use "Truth")
(assume "n" 1 "m" "ps" "qs")
(ng)
(simp (pf "PosProd Zero n ps=
           PosProd Zero n([n0][if (n0<Succ n) (ps n0) (qs(Pred(n0--n)))])"))
(use "Truth")
(use "PosProdCompat")
(strip)
(ng)
(simp (pf "l<Succ n"))
(use "Truth")
(use "NatLtTrans" (pt "n"))
(use 3)
(use "Truth")
;; (cp)
(save "PosProdSeqConcatSplit0")

;; PosProdSeqConcatSplit1
(set-goal "all m,n,ps,qs
 PosProd Zero m qs=PosProd n m(PosSeqConcat n m ps qs)")
(ind)
(strip)
(use "Truth")
(assume "m" 1 "n" "ps" "qs")
(ng)
(simp (pf "PosProd Zero m qs=
           PosProd n m([n0][if (n0<n) (ps n0) (qs(n0--n))])"))
(use "Truth")
(use "PosEqTrans" (pt "PosProd n m ([l]qs(l--n))"))
(use "PosProdShift")
(use "PosProdCompat")
(strip)
(ng)
(simp (pf "l<n -> F"))
(use "Truth")
(assume 4)
(assert "l<l")
(use "NatLtLeTrans" (pt "n"))
(use 4)
(use 2)
(search)
;; (cp)
(save "PosProdSeqConcatSplit1")

(add-program-constant "PosSeqFilter"
		      (py "(nat=>pos)=>(nat=>boole)=>nat=>pos"))
(add-computation-rules
 "PosSeqFilter ps ws n" "[if (ws n) (ps n) 1]")

(set-totality-goal "PosSeqFilter")
(fold-alltotal)
(assume "ps")
(fold-alltotal)
(assume "ws")
(fold-alltotal)
(assume "n")
(use "TotalVar")
;; (cp)
(save-totality)

;; PosSeqFilterNegbTimes
(set-goal "all ps,ws,n
  PosSeqFilter ps ws n*PosSeqFilter ps ([l](negb (ws l)))  n=ps n")
(strip)
(ng)
(cases (pt "ws n"))
(auto)
;; (cp)
(save "PosSeqFilterNegbTimes")

;; PosSeqFilterSucc
(set-goal
 "all n,m,ps,ms 
     PosSeqFilter ps([l0]ms l0<Succ n)m=
     (PosSeqFilter ps([l0]ms l0<n)m)*(PosSeqFilter ps ([l0]ms l0=n)m)")
(strip)
(ng)
(cases (pt "ms m=n"))
(assume 1)
(simp 1)
(use "Truth")
(assume 1)
(cases (pt "ms m < n"))
(assume 2)
(simp (pf "ms m < Succ n"))
(use "Truth")
(use "NatLtTrans" (pt "n"))
(auto)
(assume 2)
(simp (pf "ms m<Succ n -> F"))
(use "Truth")
(assume 3)
(use 2)
(use "NatLeNotEqToLt")
(use "NatLtSuccToLe")
(use 3)
(use 1)
;; (cp)
(save "PosSeqFilterSucc")

;; PosProdSeqFilterSucc
(set-goal "all l,ps,n,qs,ms 
     PosProd Zero l([m]PosSeqFilter qs([l0]ms l0<Succ n)(ps m))=
     PosProd Zero l
     ([m]PosSeqFilter qs([l0]ms l0<n)(ps m)*
         PosSeqFilter qs([l0]ms l0=n)(ps m))")
(strip)
(use "PosProdCompat")
(strip)
(use "PosSeqFilterSucc")
;; (cp)
(save "PosProdSeqFilterSucc")

;; PosProdSeqFilterProp0
(set-goal "all n0,n1,ns,ms,ps(
     Pms(n0+n1)ns ms -> 
     PosProd Zero(n0+n1)(PosSeqFilter ps([l]ms l<n0))=
     PosProd Zero n0 ([l]ps (ns l)))")
(assume "n0")
(ind)
(strip)
(use "PosEqTrans" (pt "PosProd Zero(n0+Zero)ps"))
(use "PosProdCompat")
(strip)
(ng)
(simp (pf "ms l<n0"))
(use "Truth")
(use "NatNotLeToLt")
(assume 4)
(inst-with "PmsIdOut" (pt "n0") (pt "ns") (pt "ms") 1 (pt "ms l") 4)
(simphyp 5 "PmsCircInv" (pt "n0"))
(assert "ms l<ms l")
(use "NatLeLtTrans" (pt "l"))
(simp "<-" 6)
(use "Truth")
(use "NatLtLeTrans" (pt "n0"))
(use 3)
(use 4)
(search)
(use 1)
(use "PosProdInvPms" (pt "ms"))
(use 1)
(assume "n1" 1 "ns" "ms" "ps" 2)
(simp (pf "n0+Succ n1=Succ(n0+n1)"))
(cases (pt "ns (n0+n1)< n0+n1"))
(assume 3)
(simp "PosProdInvTranspAux" (pt "ns (n0+n1)"))
(simp "PosProd1CompRule")
(simp (pf "([l]PosSeqFilter ps
 ([l0]ms l0<n0)(Transp(ns(n0+n1))(n0+n1)l))(Zero+(n0+n1)) =1"))
(inst-with 1
	   (pt "[l]Transp(ns (n0+n1))(n0+n1)(ns l)")
	   (pt "[l]ms(Transp(ns (n0+n1))(n0+n1)l)")
	   (pt "[l]ps (Transp(ns (n0+n1))(n0+n1)l)")
	   "?")
(use "PosEqTrans" (pt "PosProd Zero(n0+n1)
    (PosSeqFilter([l]ps(Transp(ns (n0+n1))(n0+n1)l))
     ([l]([l0]ms(Transp(ns (n0+n1))(n0+n1)l0))l<n0))"))
(use "Truth")
(simp 4)
(use "PosProdCompat")
(strip)
(ng #t)
(cases (pt "ns l=ns (n0+n1)"))
(assume 7)
(ng #t)
(simp 7)
(cases (pt "n0+n1=ns(n0+n1)"))
(assume 8)
(simp "<-" 8)
(use "Truth")
(search)
(assume 7)
(ng #t)
(cases (pt "ns l=n0+n1"))
(assume 8)
(ng #t)
(simp 8)
(use "Truth")
(assume 8)
(ng #t)
(simp 7)
(simp 8)
(use "Truth")
(use "PmsSuccInv")
(use "PmsConcat")
(use "PmsTransp")
(use "NatLeToLtSucc")
(use "NatMaxLUB")
(use "NatLtToLe")
(use 3)
(use "Truth")
(use 2)
(use "Truth")
(ng)
(simp (pf "n0+n1=ns(n0+n1)->F"))
(ng)
(simp "PmsCirc" (pt "Succ(n0+n1)"))
(use "Truth")
(use 2)
(assume 4)
(assert "ns(n0+n1)<ns(n0+n1)")
(use "NatLtLeTrans" (pt "n0+n1"))
(use 3)
(simp "<-" 4)
(use "Truth")
(search)
(use 3)
(assume 3)
(assert "ns(n0+n1)=n0+n1")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(assume 4)
(inst-with "PmsIdOutInv"
 (pt "n0+Succ n1") (pt "ns") (pt "ms") 2 (pt "ns(n0+n1)") "?")
(simphyp 5 "PmsCirc" (pt "n0+Succ n1"))
(assert "n0+n1<n0+n1")
(use "NatLtLeTrans" (pt "ns(n0+n1)"))
(use 4)
(simp "<-" 6)
(use "Truth")
(search)
(use 2)
(use "NatLtToSuccLe")
(use 4)
(use "NatNotLtToLe")
(use 3)
(assume 4)
(simp "PosProd1CompRule")
(simp 1 (pt "ns"))
(ng)
(simp (pf "ms(n0+n1)<n0 -> F"))
(use "Truth")
(simp "<-" 4)
(simp "PmsCirc" (pt "Succ(n0+n1)"))
(search)
(use 2)
(use "PmsSuccInv")
(use 2)
(use 4)
(use "Truth")
;; (cp)
(save "PosProdSeqFilterProp0")

;; PosProdSeqFilterProp1
(set-goal "all n0,n1,ns,ms,ps(
     Pms(n0+n1)ns ms -> 
     PosProd Zero(n0+n1)(PosSeqFilter ps
      ([l]negb(ms l<n0)))=PosProd n0 n1 ([l]ps (ns l)))")
(assume "n0")
(ind)
(strip)
(use "PosEqTrans" (pt "PosProd Zero n0 ([l]1)"))
(use "PosProdCompat")
(strip)
(ng)
(cases (pt "ms l<n0"))
(assume 4)
(use "Truth")
(assume 4)
(use "EfAtom")
(inst-with "PmsIdOut" (pt "n0") (pt "ns") (pt "ms") 1 (pt "ms l") "?")
(use 4)
(simphyp 5 "PmsCircInv" (pt "n0"))
(simp "<-" 6)
(use 3)
(use 1)
(use "NatNotLtToLe")
(use 4)
(use "PosProdOne")
(assume "n1" 1 "ns" "ms" "ps" 2)
(simp (pf "n0+Succ n1=Succ(n0+n1)"))
(cases (pt "ns (n0+n1)< n0+n1"))
(assume 3)
(simp "PosProdInvTranspAux" (pt "ns (n0+n1)"))
(simp "PosProd1CompRule")
(simp "PosProd1CompRule")
(simp (pf "([l]PosSeqFilter ps([l0]negb(ms l0<n0))
  (Transp(ns (n0+n1))(n0+n1)l))(Zero+(n0+n1))=([l]ps(ns l))(n0+n1)"))
(inst-with 1
	   (pt "[l]Transp(ns (n0+n1))(n0+n1)(ns l)")
	   (pt "[l]ms(Transp(ns (n0+n1))(n0+n1)l)")
	   (pt "[l]ps (Transp(ns (n0+n1))(n0+n1)l)")
	   "?")
(use "PosEqTrans" (pt "PosProd Zero(n0+n1)
    (PosSeqFilter([l]ps(Transp(ns(n0+n1))(n0+n1)l))
                 ([l]negb(([l0]ms(Transp(ns(n0+n1))(n0+n1)l0))l<n0)))*
                 ([l]ps(ns l))(n0+n1)"))
(use "Truth")
(simp 4)
(simp (pf "PosProd n0 n1
       ([l]
        ([l0]ps(Transp(ns(n0+n1))(n0+n1)l0))
        (([l0]Transp(ns(n0+n1))(n0+n1)(ns l0))l))=
       PosProd n0 n1([l]ps(ns l))"))
(use "Truth")
(use "PosProdCompat")
(strip)
(ng #t)
(cases (pt "ns l=ns (n0+n1)"))
(assume 7)
(ng #t)
(simp 7)
(cases (pt "n0+n1=ns (n0+n1)"))
(assume 8)
(simp "<-" 8)
(use "Truth")
(search)
(assume 7)
(ng #t)
(cases (pt "ns l=n0+n1"))
(assume 8)
(ng #t)
(simp 8)
(use "Truth")
(assume 8)
(ng #t)
(simp 7)
(simp 8)
(use "Truth")
(use "PmsSuccInv")
(use "PmsConcat")
(use "PmsTransp")
(use "NatLeToLtSucc")
(use "NatMaxLUB")
(use "NatLtToLe")
(use 3)
(use "Truth")
(use 2)
(use "Truth")
(ng)
(simp (pf "n0+n1=ns(n0+n1)->F"))
(ng)
(simp "PmsCirc" (pt "Succ(n0+n1)"))
(use "Truth")
(use 2)
(assume 4)
(assert "ns(n0+n1)<ns(n0+n1)")
(use "NatLtLeTrans" (pt "n0+n1"))
(use 3)
(simp "<-" 4)
(use "Truth")
(search)
(use 3)
(assume 3)
(assert "ns(n0+n1)=n0+n1")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(assume 4)
(inst-with "PmsIdOutInv"
 (pt "n0+Succ n1") (pt "ns") (pt "ms") 2 (pt "ns(n0+n1)") "?")
(simphyp 5 "PmsCirc" (pt "n0+Succ n1"))
(assert "n0+n1<n0+n1")
(use "NatLtLeTrans" (pt "ns(n0+n1)"))
(use 4)
(simp "<-" 6)
(use "Truth")
(search)
(use 2)
(use "NatLtToSuccLe")
(use 4)
(use "NatNotLtToLe")
(use 3)
(assume 4)
(simp "PosProd1CompRule")
(simp 1 (pt "ns"))
(ng)
(simp (pf "ms(n0+n1)<n0 -> F"))
(simp 4)
(use "Truth")
(simp "<-" 4)
(simp "PmsCirc" (pt "Succ(n0+n1)"))
(search)
(use 2)
(use "PmsSuccInv")
(use 2)
(use 4)
(use "Truth")
;; (cp)
(save "PosProdSeqFilterProp1")

;; PosProdEqProdSplit
(set-goal "all p0,p1,q0,q1(
     p0*p1=q0*q1 -> 
     exd p10,p11,p12 
     exl p13(p0=p10*p11 andnc p1=p12*p13 andnc
             q0=p10*p12 andnc q1=p11*p13))")
(strip)
(inst-with "PosExPrimeFactorisation" (pt "p0"))
(inst-with "PosExPrimeFactorisation" (pt "p1"))
(inst-with "PosExPrimeFactorisation" (pt "q0"))
(inst-with "PosExPrimeFactorisation" (pt "q1"))
(by-assume 2 "ps0" 6)
(by-assume 3 "ps1" 7)
(by-assume 4 "qs0" 8)
(by-assume 5 "qs1" 9)
(by-assume 6 "m10" 10)
(by-assume 7 "m11" 11)
(by-assume 8 "n10" 12)
(by-assume 9 "n11" 13)
(inst-with "PosProdSeqConcat" (pt "m10") (pt "m11") (pt "ps0") (pt "ps1"))
(inst-with "PosProdSeqConcat" (pt "n10") (pt "n11") (pt "qs0") (pt "qs1"))
(simphyp 14 (pf "PosProd Zero m10 ps0=p0"))
(drop 14)
(simphyp 16 (pf "PosProd Zero m11 ps1=p1"))
(drop 16)
(simphyp 15 (pf "PosProd Zero n10 qs0=q0"))
(drop 15)
(simphyp 18 (pf "PosProd Zero n11 qs1=q1"))
(drop 18)
(simphyp 17 1)
(simphyp 20 19)
(drop 19 20)
(inst-with "PosPrimeFactorisationsToPms"
	   (pt "m10+m11") (pt "n10+n11")
	   (pt "PosSeqConcat m10 m11 ps0 ps1")
           (pt "PosSeqConcat n10 n11 qs0 qs1")
	   "?"
	   "?"
	   "?")
(elim 22)
(drop 22)
(assume 23)
(elim)
(assume "ns")
(elim)
(assume "ms")
(elim)
(assume 27 28)
(drop 24 25 26)
(intro 0 (pt "PosProd Zero m10
 (PosSeqFilter (PosSeqConcat m10 m11 ps0 ps1) ([l] (ms l)<n10))"))
(intro 0 (pt "PosProd Zero m10
 (PosSeqFilter (PosSeqConcat m10 m11 ps0 ps1) ([l] negb ((ms l)<n10)))"))
(intro 0 (pt "PosProd m10 m11
 (PosSeqFilter (PosSeqConcat m10 m11 ps0 ps1) ([l](ms l)<n10))"))
(intro 0 (pt "PosProd m10 m11
 (PosSeqFilter (PosSeqConcat m10 m11 ps0 ps1) ([l]negb ((ms l)<n10)))"))
(simp "PosTimesProd")
(simp "PosTimesProd")
(simp "PosProdSplitZero")
(simp "PosProdSplitZero")
;; (simp "PosTimesProdBound")
;; (simp "PosTimesProdBound")
(split)
(use "PosEqTrans" (pt "PosProd Zero m10 (PosSeqConcat m10 m11 ps0 ps1)"))
(use "PosEqTrans" (pt "PosProd Zero m10 ps0"))
(use "PosEqSym")
(use 10)
(simp "PosProdSeqConcatSplit0" (pt "m11") (pt "ps1"))
(use "Truth")
(use "PosProdCompat")
(strip)
(ng #t)
(cases (pt "ms l<n10"))
(auto)
(split)
(use "PosEqTrans" (pt "PosProd m10 m11 (PosSeqConcat m10 m11 ps0 ps1)"))
(use "PosEqTrans" (pt "PosProd Zero m11 ps1"))
(use "PosEqSym")
(use 11)
;; (simp "PosProdSeqConcatSplit1" (pt "m10") (pt "ps0"))
(simp "PosProdSeqConcatSplit1")
(use "Truth")
(use "PosProdCompat")
(strip)
(ng #t)
(cases (pt "ms l<n10"))
(auto)
(split)
(simp 23)
(simp "PosProdSeqFilterProp0" (pt "ns"))
(use "PosEqTrans" (pt "PosProd Zero n10 qs0"))
(use "PosEqSym")
(use 12)
(use "PosEqTrans" (pt "PosProd Zero n10(PosSeqConcat n10 n11 qs0 qs1)"))
(use "PosProdSeqConcatSplit0")
(use "PosProdCompat")
(strip)
(use "PosEqSym")
(use 28)
(simp 23)
(use "NatLtLeTrans" (pt "n10"))
(use 30)
(use "Truth")
(simp "<-" 23)
(use 27)
(simp 23)
(simp "PosProdSeqFilterProp1" (pt "ns"))
(use "PosEqTrans" (pt "PosProd Zero n11 qs1"))
(use "PosEqSym")
(use 13)
(use "PosEqTrans" (pt "PosProd n10 n11(PosSeqConcat n10 n11 qs0 qs1)"))
(use "PosProdSeqConcatSplit1")
(use "PosProdCompat")
(strip)
(use "PosEqSym")
(use 28)
(simp 23)
(use 30)
(simp "<-" 23)
(use 27)
(use "PosPrimeFactorSeqConcat")
(use 10)
(use 11)
(use "PosPrimeFactorSeqConcat")
(use 12)
(use 13)
(use "PosEqSym")
(use 21)
(use 13)
(use 12)
(use 11)
(use 10)
;; (cp)
(save "PosProdEqProdSplit")


(define etermProdSplit (proof-to-extracted-term))

;;(pp etermProdSplit)

;; (animate "PosExPrimeFactorisation")
;; (animate "PosDivToProd")
;; (animate "PosPrimeFactorisationsToPms")
;; (animate "PosPrimeDivProdToDiv")
;; (animate "PosGcdToLinComp")
;; (animate "PosPrimeDivProdPrimesToInPrimes")
;; (animate "PosGcdPrime")
;; (animate "PosDivPrime")


;; PosGcdEqOneDivProdToDiv
(set-goal "all p,q1,q2( PosGcd p q1=1 -> PosDiv p(q1*q2) -> PosDiv p q2)")
(strip)
(inst-with "PosDivToProd" (pt "p") (pt "q1*q2") 2)
(by-assume 3 "p0" 4)
(inst-with "PosProdEqProdSplit" (pt "p0") (pt "p") (pt "q1") (pt "q2") 4)
(by-assume 5 "p1" 6)
(by-assume 6 "p2" 7)
(by-assume 7 "p3" 8)
(by-assume 8 "p4" 9)
(elim 9)
(assume 10)
(elim)
(assume 12)
(elim)
(assume 13 14)
(drop 9 11 13)
(simp 15)
(simp 12)
(simphyp 1 12)
(simphyp 16 14)
(assert "p3=1")
(use "PosDivAntiSym")
(use "PosDivTrans" (pt "PosGcd(p3*p4)(p1*p3)"))
(simp "PosDiv0CompRule")
(use "PosDivAntiSym")
(use "PosGcdDiv0")
(use "PosDivGcd")
(use "PosDivRefl")
(use "PosDivGcd")
(use "PosProdToDiv" (pt "p4"))
(use "PosTimesComm")
(use "PosProdToDiv" (pt "p1"))
(use "Truth")
(simp 17)
(use "Truth")
(use "Truth")
(assume 18)
(simp 18)
(use "PosProdToDiv" (pt "p2"))
(use "Truth")
;; (cp)
(save "PosGcdEqOneDivProdToDiv")

(animate "PosExPrimeFactorisation")
(animate "PosPrimeFactorisationsToPms")
(animate "PosPrimeDivProdPrimesToInPrimes")
(animate "PosDivToProd")
(animate "PosPrimeDivProdToDiv")

(terms-to-haskell-program
  "/home/fwiesnet/Minlog/minlog/fta_pos.hs"
  (list
   (list etermExPrime "toPrimes")
   (list etermToPms "genPms")
   (list etermProdSplit "prodSplit")))
